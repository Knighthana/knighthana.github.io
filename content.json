{"meta":{"title":"Knighthana的鸽子巢","subtitle":"Knighthana的WebLog","description":"WebLog of Knighthana","author":"Knighthana","url":"https://knighthana.github.io","root":"/"},"pages":[{"title":"404","date":"2023-04-20T11:20:09.000Z","updated":"2023-04-20T11:26:18.571Z","comments":true,"path":"404.html","permalink":"https://knighthana.github.io/404.html","excerpt":"","text":"404 这里什么都没有 返回主页"},{"title":"关于这这个站点","date":"2023-04-19T12:15:09.000Z","updated":"2023-05-05T17:34:15.884Z","comments":true,"path":"about.html","permalink":"https://knighthana.github.io/about.html","excerpt":"","text":"咕咕咕咕咕咕咕 咕咕咕咕咕咕咕～ 你在这个页面上什么都没有看到，只听到有鸽子在叫 还是换个地方继续参观吧 “文章归档”里面看到的文章目录会比较清楚哦 前往文件归档 或者查看博客维护日志"},{"title":"文章归档","date":"2023-04-19T13:23:23.445Z","updated":"2023-04-19T12:24:07.734Z","comments":true,"path":"archives.html","permalink":"https://knighthana.github.io/archives.html","excerpt":"","text":""}],"posts":[{"title":"为Boa Web Server的CGI增添自定义链接库","slug":"为BoaWebServer的CGI增添自定义链接库","date":"2023-11-17T15:16:02.000Z","updated":"2023-11-17T17:13:50.222Z","comments":true,"path":"Dev-Code/为BoaWebServer的CGI增添自定义链接库.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/%E4%B8%BABoaWebServer%E7%9A%84CGI%E5%A2%9E%E6%B7%BB%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5%E5%BA%93.html","excerpt":"","text":"为Boa Web Server传递给CGI的环境变量增添自定义内容 请注意，这是一篇草台教程，含有半懂不懂的内容 背景介绍 出于工作方面需要，得为Boa Web Server的服务器设置一个环境变量 于是我在不稳定版本0.94.14rc21上开始了工作 （为什么不在0.94.13稳定版本上开工？因为0.94.13版本使用了flex语法分析器辅助生成代码，而flex这个玩意搞出来的一坨东西在我的编译器上飘得满屏是warning，与之相比，使用了自定义Parser的0.94.14rc21的警告就少得多了，都是一些要求“不得忽略函数返回值”的warning） 显而易见的是，使用非稳定版肯定会有更多BUG，毕竟还是有很多地方写着fixme或者why一类的注释，不过相比这个快二十年的老项目的其他BUG还有已经广为人知的致命漏洞而言，这点可能会多出来的BUG不痛不痒（预感这句话未来会被打脸） 其实我个人还是比较敬佩这些写Boa代码的人的，不得不说，二十多年前写出来的这个东西，占用极其小，功能放在当年来说也是很全面的，性能也还不错 而且从注释里面都很能看出来他们的代码态度，比如0.94.13中的这段注释 We (I, Jon) have declined to support absolute-path parsing because I see it as a major security hole. Location: /etc/passwd or Location: /etc/shadow is not funny. Also, the below code is borked. request_uri could contain /cgi-bin/bob/extra_path 我是很喜欢有脾气的人做的活的——前提是脾气得和我对得上，或者换个说法，有人管这种叫“有态度”，反正就是那么一回事 废话不多说，开始正题 如何找到有关环境变量传递的部分代码？ 在boa.conf中有一个配置叫做“CGIPath”，跟随这个关键词搜索boa源代码目录，我们可以找到，除去boa.conf以外，有这么一个代码文件与它有关 config.c 12345struct ccommand clist[] = { ...... {\"CGIPath\", S1A, c_set_string, &amp;cgi_path}, ......} 即便看不太懂这是什么样的结构体，也能发现这里有个char指针cgi_path和前面的CGIPath对应 （其实稍微解读一下就能发现，这是一个结构体数组，结构体的四个成员分别是一个字符串，一个起枚举作用的宏定义量，一个函数指针，一个char指针） 那么搜索一下cgi_path，除去config.c之外，还有globals.h和cgi.c两个文件与cgi_path有关 globals.h 1extern char *cgi_path; cgi.c 1234common_cgi_env[common_cgi_env_count++] = env_gen_extra(\"PATH\", ((cgi_path != NULL) ? cgi_path : DEFAULT_PATH), 0); 那么不难猜测，我们要修改的文件就是这三个了，就像上次修改Linux系统调用一样 ほんとうですか 增加自定义环境变量，分三步走 第一步，增加声明 在globals.h中，传递PATH的那个变量的下面增加我们自己的声明语句 修改前 12extern char *cgi_path;extern short common_cgi_env_count; 修改后 123extern char *cgi_path;extern char *cgi_ld_library_path;extern short common_cgi_env_count; 第二步，向结构体数组插入一个结构体 在config.c中添加一个类似的东西 由于我们很清楚，LD_LIBRARY_PATH是一个很类似PATH的东西，因此照抄PATH的结构体 修改前 12{\"CGIPath\", S1A, c_set_string, &amp;cgi_path},{\"CGIumask\", S1A, c_set_int, &amp;cgi_umask}, 修改后 123{\"CGIPath\", S1A, c_set_string, &amp;cgi_path},{\"CGILdLibraryPath\", S1A, c_set_string, &amp;cgi_ld_library_path},{\"CGIumask\", S1A, c_set_int, &amp;cgi_umask}, 第三步，增加函数 照抄PATH的写法，我的写法是这样的 123common_cgi_env[common_cgi_env_count++] = env_gen_extra(\"LD_LIBRARY_PATH\", ((cgi_ld_library_path != NULL) ? cgi_ld_library_path : DEFAULT_LD_LIBRARY_PATH), 0); 当然不做这个三目运算判断也不是不行，但是我觉得万一conf里面忘了写，总不能真地传一个空的LD_LIBRARY_PATH给CGI程序吧，于是也写了这个宏，那就得顺便去头文件那边定义一个字符串宏 在defines.h里面加一行 1#define DEFAULT_LD_LIBRARY_PATH \"/the/original/library/path:/my/custom/library/path\" 第四步，增加 一共三步的教程里面有四步不是很合理嘛！ 如果真的只干了上面三步，兴冲冲地去make的话就会发现make出来的结果不能用 QAQ 反正我是make完了才发现报错 COMMON_CGI_COUNT not high enough. 啊这…… 其实cgi.c的create_common_env的注释写得很明白 1234567891011121314/* NOTE NOTE NOTE: If you (the reader) someday modify this chunk of code to handle more \"common\" CGI environment variables, then bump the value COMMON_CGI_COUNT in defines.h UP Also, in the case of document_root and server_admin, two variables that may or may not be defined depending on the way the server is configured, we check for null values and use an empty string to denote a NULL value to the environment, as per the specification. The quote for which follows: \"In all cases, a missing environment variable is equivalent to a zero-length (NULL) value, and vice versa.\" */ 所以说还有个后备隐藏变量需要我们改一下，也在defines.h里面 在defines.h里面找到 12345#ifdef USE_NCSA_CGI_ENV#define COMMON_CGI_COUNT 8#else#define COMMON_CGI_COUNT 6#endif 修改成 12345#ifdef USE_NCSA_CGI_ENV#define COMMON_CGI_COUNT 9#else#define COMMON_CGI_COUNT 7#endif 顺带一提，我数了一下cgi.c里面一共是PATH SERVER_SOFTWARE SERVER_NAME GATEWAY_INTERFACE SERVER_PORT 共5个环境变量，但为什么这里原本写的是6呢？ 在cgi.c的create_common_env函数开头有这么一处 123456789101112131415void create_common_env(void){ int i; common_cgi_env = calloc((COMMON_CGI_COUNT + 1),sizeof(char *)); common_cgi_env_count = 0; if (common_cgi_env == NULL) {/* ...........blahblah......... * ...........blahblah......... * ...........blahblah......... */ }} 里面写道：common_cgi_env = calloc((COMMON_CGI_COUNT + 1),sizeof(char *)); 为啥要这么写，咱也不知道，咱也不敢问，也不敢改 （好奇calloc是什么，查了一下，知道了calloc可以自动把分配的内存清零，顿时感觉写出malloc();memset(0x0)的自己非常地铁憨憨） 于是收工 1make -j16 修改boa.conf 在boa.conf里面，靠着CGIPath的地方，我们修改一下，弄这么一行 1CGILdLibraryPath /this/is/my/lovely/library.so/contained/path 就完事了 了……吗？ 非也 注意看……这个代码叫cgi.c 1env_gen_extra(\"PATH\",((cgi_path != NULL) ? cgi_path : DEFAULT_PATH), 0); 以及 12345678910111213141516171819202122232425262728293031/* * Name: env_gen_extra * (and via a not-so-tricky #define, env_gen) * This routine calls malloc: please free the memory when you are done */static char *env_gen_extra(const char *key, const char *value, unsigned int extra){ char *result; unsigned int key_len, value_len; if (value == NULL) /* ServerAdmin may not be defined, eg */ value = \"\"; key_len = strlen(key); value_len = strlen(value); /* leave room for '=' sign and null terminator */ result = malloc(extra + key_len + value_len + 2); if (result) { memcpy(result + extra, key, key_len); *(result + extra + key_len) = '='; memcpy(result + extra + key_len + 1, value, value_len); *(result + extra + key_len + value_len + 1) = '\\0'; } else { log_error_time(); perror(\"malloc\"); log_error_time(); fprintf(stderr, \"tried to allocate (key=value) extra=%u: %s=%s\\n\", extra, key, value); } return result;} 我来解读一下啊，这里说的是，要是有默认的宏定义DEFAULT_PATH，那就用这个默认的，要是conf里面有写内容，让cgi_path不为空，那就…… 把配置文件里面写的东西贴在这里然后加上等号……………………然后直接传给CGI程序 等 等 等 等 等 等 等 等 等 等 等 等 等 等 等 一下！ ちょっと待ってください！！！ env自带的$PATH呢？$LD_LIBRARY_PATH呢？ 全都没有啦！ 是的，直接没有了，不仅如此，连我们在宏里本来定义的DEFAULT_PATH和DEFAULT_LD_LIBRARY_PATH都没有顺便传进去 所以这里注意了…… Boa WebServer 的环境变量配置逻辑 Boa的环境变量就是假如配置文件boa.conf没写，就传个默认的进去，假如写了，就只传写在conf里面的内容进去 所以这也解释了为什么我之前有一次CGI拿到的PATH变量见了鬼的事件 实际上人家的逻辑本来就是那样，写得很清楚了(而且看了代码逻辑，感觉换我来写我也这么写) 1# CGIPath: The value of the $PATH environment variable given to CGI progs. 这里的提示写的是 given to 而不是add to，所以注意了， boa.conf里的环境变量要么不写，要写就一定要写全了 尾声 于是我打算fork一个boa web server，碰到哪里有啥问题就改一改 等到改不动了就弃坑跑路 Knighthana 2023/11/17","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"},{"name":"草台教程","slug":"草台教程","permalink":"https://knighthana.github.io/tags/%E8%8D%89%E5%8F%B0%E6%95%99%E7%A8%8B/"},{"name":"BoaWebServer","slug":"BoaWebServer","permalink":"https://knighthana.github.io/tags/BoaWebServer/"}]},{"title":"安装clangd协同vscode工作","slug":"安装clangd协同vscode工作","date":"2023-11-16T14:19:40.000Z","updated":"2023-11-16T15:04:24.481Z","comments":true,"path":"Dev-Env/安装clangd协同vscode工作.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E5%AE%89%E8%A3%85clangd%E5%8D%8F%E5%90%8Cvscode%E5%B7%A5%E4%BD%9C.html","excerpt":"","text":"安装Clangd 什么是Clangd？ What is clangd? clangd is a language server that can work with many editors via a plugin. Here’s Visual Studio Code with the clangd plugin, demonstrating code completion: clangd work with vscode example 不多介绍，很牛逼就是了，对于我这种希望对代码做最精细检查的人来说非常好用 怎么安装Clangd？ 对于 Debian Linux 或者 LinuxMint 用户（也包括对应的WSL用户，不再赘述）来说，输入 1sudo apt install clangd 即可安装Clangd，其他发行版也可以在包管理器内找到对应的软件包，一般来说叫clangd进行安装 安装名为“Clangd”的vscode插件 安装插件 点击vscode侧面的插件页面，搜索“Clangd”插件，作者为“LLVM”的那个就是 点击安装 对vscode的配置 基本不需要自己配置， 在安装了Clangd插件之后，它会自动提示“请禁用与Clangd冲突的插件”，点击允许的那个按钮就可以了 一般来说会禁用vscode自带的“IntelliSense” 如果不慎禁用了这个用于自动提示的对话框，可以在Clangd的插件设置里面找到关于这个对话框的设置clangd.detectExtensionConflicts 如何重新启用IntelliSense 假如出于各种原因，需要重新启用IntelliSense，怎么启用呢？ 打开vscode对应阶段的settings.json，一般来说，被clangd插件禁用的是用户层级的，那么 Linux在 1/home/user/.config/Code/User/settings.json Windows在 1%userprofile%/AppData\\Roaming\\Code\\User\\Settings.json 中找到对应的配置文件 但是，最稳妥的办法是按下ctrl+shift+P找到对应层级（用户级、工作区级、SSH连接级）的配置文件 查找这样一行 1\"C_Cpp.intelliSenseEngine\": \"disabled\", 根据需要和提示修改为\"disabled\"或者\"default\"，就可以控制IntelliSense的开关了 向clangd传递工程的情况 有时候自定义了一些头文件，放在了特殊的目录中，编译的时候也会使用gcc的-I来控制头文件目录，但是对于语法检查程序来说并不知道编译参数是什么 这里参考llvm给出的文档 Configuration 在工程目录下新建一个叫做.clangd的文件，然后根据文章中的语法要求书写配置即可 例如我最关心的CFLAGS （懒得翻译了） CompileFlags Affects how a source file is parsed. CompileFlags: # Tweak the parse settings Add: [-xc++, -Wall] # treat all files as C++, enable more warnings Remove: -W* # strip all other warning-related flags Compiler: clang++ # Change argv[0] of compile flags to clang++ clangd emulates how clang would interpret a file. By default, it behaves roughly as clang $FILENAME, but real projects usually require setting the include path (with the -I flag), defining preprocessor symbols, configuring warnings etc. Often, a compilation database specifies these compile commands. clangd searches for compile_commands.json in parents of the source file. This section modifies how the compile command is constructed. Add List of flags to append to the compile command. Remove List of flags to remove from the compile command. If the value is a recognized clang flag (like -I) then it will be removed along with any arguments. Synonyms like --include-directory= will also be removed. Otherwise, if the value ends in * (like -DFOO=*) then any argument with the prefix will be removed. Otherwise any argument exactly matching the value is removed. In all cases, -Xclang is also removed where needed. Example: Command: clang++ --include-directory=/usr/include -DFOO=42 foo.cc Configuration: Remove: [-I, -DFOO=*] Result: clang++ foo.cc Flags added by the same CompileFlags entry will not be removed. 比如我比较关心的-I参数，那么就在文件里面写 123CompileFlags: Add: [-I/home/knighthana/my/project/path/include] Compiler: gcc 重启vscode,发现语法检查已经跟上了，完事！ Knighthana 2023/11/16","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"}]},{"title":"(KM)设计模式一书开篇就解答的两个问题","slug":"(KM)设计模式一书开篇就解答的两个问题","date":"2023-05-23T16:00:00.000Z","updated":"2023-05-24T15:17:00.000Z","comments":true,"path":"KnowledgeMark/(KM)设计模式一书开篇就解答的两个问题.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E4%B9%A6%E5%BC%80%E7%AF%87%E5%B0%B1%E8%A7%A3%E7%AD%94%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98.html","excerpt":"","text":"设计模式一书开篇就解答的两个问题 进行项目开发的时候痛点有哪些？ 选择太多，无从下手 没有正确答案眼里看着别人的代码都是垃圾，而自己手里的代码写着写着也堆成了垃圾 怎样才能实现好的设计，什么才是好的设计？ 高可复用，高灵活，高扩展——高内聚，松耦合 如何实现？ 一下子就得到有可复用性的灵活性好的设计，根本不可能，或者非常困难 复用以前使用过的可行的软件设计解决方案是成熟的做法 已经被使用过多次，被现实验证过的设计就是好的设计 Knighthana 2023/05/24","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://knighthana.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"(KM)联合体和结构体","slug":"(KM)联合体和结构体","date":"2023-05-21T16:00:00.000Z","updated":"2023-05-30T13:54:48.797Z","comments":true,"path":"KnowledgeMark/(KM)联合体和结构体.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)%E8%81%94%E5%90%88%E4%BD%93%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93.html","excerpt":"","text":"联合体和结构体 很久之前的某次面试被问到这个，我只是隐隐约约记得联合体是“共用”关系，而结构体则是原来熟悉的样子 而且记得有个struct_addrin什么的 现在想起来，查了一下，刷新一下内存 结构体和联合体的区别 sockaddr_in 和 sin_addr 顺带一提，那个结构体的名字明明是sockaddr_in 而且它并不是联合体 看起来面试那天是猪脑过载了 虽然和本文主题无关，但是把概念搞清楚一点总没错 在man7.org得到了说明 An IP socket address is defined as a combination of an IP interface address and a 16-bit port number. The basic IP protocol does not supply port numbers, they are implemented by higher level protocols like udp(7) and tcp(7). On raw sockets sin_port is set to the IP protocol. 12345struct sockaddr_in { sa_family_t sin_family; /* address family: AF_INET */ in_port_t sin_port; /* port in network byte order */ struct in_addr sin_addr; /* internet address */}; 1234/* Internet address */struct in_addr { uint32_t s_addr; /* address in network byte order */}; sockaddr_in是一个联合体，三个成员分别指定了scoket的类型与版本、端口号、地址 在TCP/IP中，sin_family一般是AF_INET，也就是IPv4，对于IPv6则是AF_INET6，端口号当然是端口号，而且这一步应该还不能确定是TCP还是UDP，所以仅仅是个端口号，地址的话当然就是IP地址 是TCP或者是UDP？这是根据创建的socket不同来确认的，如果socket选择SOCK_STREAM那就是TCP，如果是SOCK_DGRAM那就是UDP Knighthana 2023/05/26","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"}]},{"title":"Docker入门与Hadoop的部署","slug":"Docker入门与Hadoop的部署","date":"2023-05-16T16:00:00.000Z","updated":"2023-05-17T16:00:00.000Z","comments":true,"path":"Dev-Env/Docker入门与Hadoop的部署.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/Docker%E5%85%A5%E9%97%A8%E4%B8%8EHadoop%E7%9A%84%E9%83%A8%E7%BD%B2.html","excerpt":"","text":"Docker入门与初步使用 之前折腾了一次安装docker，由于一直没什么用途，也就没有继续探索 现在需要使用docker完成另一项任务，因此先探索一下docker具体的用法 外部链接：其他教程 关于如何使用Docker,有三个教程 网站设在国内的，全中文，十分方便食用的 Docker 教程 | 菜鸟教程 来自官方的，比较标准的，但是全英文的 Overview | Docker Documentation 来自微软的，局限于vscode，但同样方便食用的 教程：使用 Visual Studio Code 创建 Docker 应用 BTW: 检测到环境中安装有Docker之后，vscode会自动提醒可以安装Docker插件 安装Docker 关于 安装Docker 的博客，我在之前写过，因此不再赘述 这篇博客中还提到了docker-ce的权限与用户组设置（以便以普通用户而不是超级用户的身份使用docker），docker的镜像设置 什么是映像，什么是容器？ 如 Docker objects 所言 映像是创建容器的指导性文件，只读，之后行文的时候可能也会写作“镜像” 容器是运行中的映像实例，有一个自己的读写文件系统 通过阅读这段文字，我可以认为，映像是程序，容器是进程 下载第一个映像 有一篇很有趣的小文章讲了一下常见映像的大小 Minideb: A Minimalist, Debian-Based Docker Image ，最有趣的是，Python在冗余方面从来不负众望 虽然教程给的是centos，但是我对yum或者说dnf的一套东西不太熟悉，我更加熟悉的是debian系的apt和arch系的pacman，所以本教程就用debian映像进行之后的操作了 通过 1docker pull debian 将会下载第一个映像 下载速度取决于镜像站设置，或者是否对这段网络连接进行了“加速处理” 下载完毕之后，会看到明显的提示 可以手动检查一下，输入 1docker image ls -a 可以看到以下输出： 1234➜ ~ docker image ls -aREPOSITORY TAG IMAGE ID CREATED SIZEdebian latest 34b4fa67dc04 2 weeks ago 124MBhello-world latest feb5d9fea6a5 20 months ago 13.3kB 其中的debian就是刚刚下载的映像了，可以发现它的大小只有124MiB，甚至远远小于debain-11.7.0-amd64-netinst.iso的389MiB 下面的hello-world是之前向世界宣布我们的docker-ce安装成功时自动下载来的映像，由于只有13Ki大，我打算留着它 进容器瞧瞧看看 此时，通过运行 1docker run -it debian /bin/bash 就会使用debian映像创建一个容器、进入容器、并且调用bash作为交互界面 由于之前下载过程的反馈提示中说下载了“最新版本”的Debian映像，我很好奇这究竟是哪个版本，那么不妨检查一下 常见的lsb_release或debian_version命令并没有打包在映像中，不过可以通过 1cat /etc/os-release 来查看系统信息 12345678910root@da62261bc436:~# cat /etc/os-release PRETTY_NAME=\"Debian GNU/Linux 11 (bullseye)\"NAME=\"Debian GNU/Linux\"VERSION_ID=\"11\"VERSION=\"11 (bullseye)\"VERSION_CODENAME=bullseyeID=debianHOME_URL=\"https://www.debian.org/\"SUPPORT_URL=\"https://www.debian.org/support\"BUG_REPORT_URL=\"https://bugs.debian.org/\" 不出所料，是“bullseye”，也就是“牛眼”版本 再看看都预装了什么软件包： Debian的Docker映像中预装软件包列表 root@da62261bc436:/etc/apt# apt list | grep installed WARNING: apt does not have a stable CLI interface. Use with caution in scripts. adduser/now 3.118 all [installed,local] apt/now 2.2.4 amd64 [installed,local] base-files/now 11.1+deb11u7 amd64 [installed,local] base-passwd/now 3.5.51 amd64 [installed,local] bash/now 5.1-2+deb11u1 amd64 [installed,local] bsdutils/now 1:2.36.1-8+deb11u1 amd64 [installed,local] coreutils/now 8.32-4+b1 amd64 [installed,local] dash/now 0.5.11+git20200708+dd9ef66-5 amd64 [installed,local] debconf/now 1.5.77 all [installed,local] debian-archive-keyring/now 2021.1.1+deb11u1 all [installed,local] debianutils/now 4.11.2 amd64 [installed,local] diffutils/now 1:3.7-5 amd64 [installed,local] dpkg/now 1.20.12 amd64 [installed,local] e2fsprogs/now 1.46.2-2 amd64 [installed,local] findutils/now 4.8.0-1 amd64 [installed,local] gcc-10-base/now 10.2.1-6 amd64 [installed,local] gcc-9-base/now 9.3.0-22 amd64 [installed,local] gpgv/now 2.2.27-2+deb11u2 amd64 [installed,local] grep/now 3.6-1+deb11u1 amd64 [installed,local] gzip/now 1.10-4+deb11u1 amd64 [installed,local] hostname/now 3.23 amd64 [installed,local] init-system-helpers/now 1.60 all [installed,local] libacl1/now 2.2.53-10 amd64 [installed,local] libapt-pkg6.0/now 2.2.4 amd64 [installed,local] libattr1/now 1:2.4.48-6 amd64 [installed,local] libaudit-common/now 1:3.0-2 all [installed,local] libaudit1/now 1:3.0-2 amd64 [installed,local] libblkid1/now 2.36.1-8+deb11u1 amd64 [installed,local] libbz2-1.0/now 1.0.8-4 amd64 [installed,local] libc-bin/now 2.31-13+deb11u6 amd64 [installed,local] libc6/now 2.31-13+deb11u6 amd64 [installed,local] libcap-ng0/now 0.7.9-2.2+b1 amd64 [installed,local] libcom-err2/now 1.46.2-2 amd64 [installed,local] libcrypt1/now 1:4.4.18-4 amd64 [installed,local] libdb5.3/now 5.3.28+dfsg1-0.8 amd64 [installed,local] libdebconfclient0/now 0.260 amd64 [installed,local] libext2fs2/now 1.46.2-2 amd64 [installed,local] libffi7/now 3.3-6 amd64 [installed,local] libgcc-s1/now 10.2.1-6 amd64 [installed,local] libgcrypt20/now 1.8.7-6 amd64 [installed,local] libgmp10/now 2:6.2.1+dfsg-1+deb11u1 amd64 [installed,local] libgnutls30/now 3.7.1-5+deb11u3 amd64 [installed,local] libgpg-error0/now 1.38-2 amd64 [installed,local] libgssapi-krb5-2/now 1.18.3-6+deb11u3 amd64 [installed,local] libhogweed6/now 3.7.3-1 amd64 [installed,local] libidn2-0/now 2.3.0-5 amd64 [installed,local] libk5crypto3/now 1.18.3-6+deb11u3 amd64 [installed,local] libkeyutils1/now 1.6.1-2 amd64 [installed,local] libkrb5-3/now 1.18.3-6+deb11u3 amd64 [installed,local] libkrb5support0/now 1.18.3-6+deb11u3 amd64 [installed,local] liblz4-1/now 1.9.3-2 amd64 [installed,local] liblzma5/now 5.2.5-2.1~deb11u1 amd64 [installed,local] libmount1/now 2.36.1-8+deb11u1 amd64 [installed,local] libnettle8/now 3.7.3-1 amd64 [installed,local] libnsl2/now 1.3.0-2 amd64 [installed,local] libp11-kit0/now 0.23.22-1 amd64 [installed,local] libpam-modules-bin/now 1.4.0-9+deb11u1 amd64 [installed,local] libpam-modules/now 1.4.0-9+deb11u1 amd64 [installed,local] libpam-runtime/now 1.4.0-9+deb11u1 all [installed,local] libpam0g/now 1.4.0-9+deb11u1 amd64 [installed,local] libpcre2-8-0/now 10.36-2+deb11u1 amd64 [installed,local] libpcre3/now 2:8.39-13 amd64 [installed,local] libseccomp2/now 2.5.1-1+deb11u1 amd64 [installed,local] libselinux1/now 3.1-3 amd64 [installed,local] libsemanage-common/now 3.1-1 all [installed,local] libsemanage1/now 3.1-1+b2 amd64 [installed,local] libsepol1/now 3.1-1 amd64 [installed,local] libsmartcols1/now 2.36.1-8+deb11u1 amd64 [installed,local] libss2/now 1.46.2-2 amd64 [installed,local] libssl1.1/now 1.1.1n-0+deb11u4 amd64 [installed,local] libstdc++6/now 10.2.1-6 amd64 [installed,local] libsystemd0/now 247.3-7+deb11u2 amd64 [installed,local] libtasn1-6/now 4.16.0-2+deb11u1 amd64 [installed,local] libtinfo6/now 6.2+20201114-2+deb11u1 amd64 [installed,local] libtirpc-common/now 1.3.1-1+deb11u1 all [installed,local] libtirpc3/now 1.3.1-1+deb11u1 amd64 [installed,local] libudev1/now 247.3-7+deb11u2 amd64 [installed,local] libunistring2/now 0.9.10-4 amd64 [installed,local] libuuid1/now 2.36.1-8+deb11u1 amd64 [installed,local] libxxhash0/now 0.8.0-2 amd64 [installed,local] libzstd1/now 1.4.8+dfsg-2.1 amd64 [installed,local] login/now 1:4.8.1-1 amd64 [installed,local] logsave/now 1.46.2-2 amd64 [installed,local] lsb-base/now 11.1.0 all [installed,local] mawk/now 1.3.4.20200120-2 amd64 [installed,local] mount/now 2.36.1-8+deb11u1 amd64 [installed,local] ncurses-base/now 6.2+20201114-2+deb11u1 all [installed,local] ncurses-bin/now 6.2+20201114-2+deb11u1 amd64 [installed,local] passwd/now 1:4.8.1-1 amd64 [installed,local] perl-base/now 5.32.1-4+deb11u2 amd64 [installed,local] sed/now 4.7-1 amd64 [installed,local] sysvinit-utils/now 2.96-7+deb11u1 amd64 [installed,local] tar/now 1.34+dfsg-1 amd64 [installed,local] tzdata/now 2021a-1+deb11u10 all [installed,local] util-linux/now 2.36.1-8+deb11u1 amd64 [installed,local] zlib1g/now 1:1.2.11.dfsg-2+deb11u2 amd64 [installed,local] 在-it，其实也就是-i -t模式中的体验，很像之前安装ArchLinux时的arch-chroot 简单的自定义 由于接下来我们需要进行一些安装，所以得先去修改一下apt的镜像站地址 很容易发现，映像为了节约空间，没有安装vi、vim、nano中的任何一个 无论是为了下载安装它们，或者是为了保留映像的tiny特性而不安装文本编辑器，都需要知道如何在只有基本工具的情况下修改sources.list文件 12mv /etc/apt/sources.list sources.list.bakecho -e \"deb http://linux.xidian.edu.cn/mirrors/debian/ bullseye main non-free contrib\\ndeb http://linux.xidian.edu.cn/mirrors/debian/ bullseye-updates main non-free contrib\" | tee /etc/apt/sources.list &gt; /dev/null 我使用了西电源，这个源不对外开放，请根据自己的情况修改源 为了换行方便，我使用了echo -e，在后面使用了\\n换行，请适当地予以替换 这里使用了http而不是https，因为我在学校内网中，并且不想在docker容器中安装apt-transport-https和ca-certificates 如果网络环境不安全的话，还是应该使用TLS加密的 这里用了一下tee是为了方便在中间做一些动作，如果不需要做额外的动作，或者假如映像中连tee都没有打包的话，应该可以直接省略关于tee的管道命令，用&gt;将内容重定向至/etc/apt/sources.list name download size install size nano 825KiB 3087KiB vim 8174KiB 36.9MiB 那么，还是安装一个nano吧 然后去修改一下~/.bashrc，取消有关颜色的注释、alias的注释，修改完之后，还需要在.bashrc文件的最上面上面添加单独一行export SHELL=/bin/bash，因为我们每次是通过在外面直接exec /bin/bash的方式进入容器的，所以这个环境变量目前需要设置在.bashrc中 之后如果交互的方式有所变化，我们需要更改这行环境变量SHELL修改命令的位置 退出容器，重新进入容器 第一次通过docker run -it运行的容器，在容器的交互式界面中，平常地使用用exit就会退出容器 但是我们不可以再次运行上一个run命令以期望进入刚才的容器，因为创建的容器已经是另一个分支了，如果我们此时再次运行docker run -it debian /bin/bash就会从debian映像上创建另一个全新的容器 先查询刚才在本地创建的容器叫什么 1docker ps -a 123➜ ~ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESda62261bc436 debian \"/bin/bash\" 2 hours ago Exited (0) 3 minutes ago distracted_shockley 这里提示容器的状态是“已退出”，如何重新运行容器并获取容器的控制呢？ 先说运行容器，这个非常简单 通过 1docker start distracted_shockley 就会在后台静默启动一个docker容器distracted_shockley，此时我们无法直接和它交互 但是此时运行docker ps，注意我们并没有附加-a选项，就会发现docker报告有一个容器已经启动了 123➜ ~ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESda62261bc436 debian \"/bin/bash\" 2 hours ago Up 4 seconds distracted_shockley 此时要进入容器，还需要做一些选择 attach 对于正在运行中的容器，通过 1docker attach distracted_shockley 交互式地返回正在运行中的容器distracted_shockley 如果此时在容器中的bash里输入命令 1exit 并回车，那么容器就会彻底关闭并退出 在宿主机上运行 1docker ps 只会看到空空如也的界面 exec 对于正在运行中的容器，通过 1docker exec -it distracted_shockley /bin/bash 就可以打开一个新的bash进入容器 退出这个bash并不会让整个容器停止运行 例如屏幕上的这段显示 123456➜ ~ docker exec -it distracted_shockley /bin/bashroot@da62261bc436:/# exitexit➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESda62261bc436 debian \"/bin/bash\" 2 hours ago Up About a minute distracted_shockley 中间虽然通过exit退出了容器中的bash，但是容器还是运行状态 不难猜到，容器中还有一个bash正在运行中，只有通过attach的方式才能访问到它 Docker的初步安装与配置到此结束，不难发现，Docker是一个内部“基本完整”的“操作系统”，因此，在谈论“一个容器”的时候，我们知道，这个“容器”里面一定是有操作系统的，虽然被简化了许多 接下来将结合Hadoop进行具体功能使用方面的的探索 Hadoop的下载与安装 Apache官方Hadoop稳定版介绍 介绍页面说了，对于初学者，请从单机模式开始学习配置，然后再使用集群模式 那么这是有关单机模式Hadoop的Apache官方的手册文件 最后是Apache官方的下载地址（访问较慢）或者说去访问镜像，镜像有CDN 如果彼时的stable还是3.3.5，可以用这个链接 还有国内的非常方便食用的Hadoop 教程 | 菜鸟教程 现在(2023.05.22)，最新稳定版本的Hadoop是3.3.5 先看着文档一步一步来 前置条件 GNU/Linux is supported as a development and production platform. Hadoop has been demonstrated on GNU/Linux clusters with 2000 nodes. 这没问题，我正在使用LinuxMint，是GNU/Linux Required software for Linux include: Java™ must be installed. Recommended Java versions are described at HadoopJavaVersions. ssh must be installed and sshd must be running to use the Hadoop scripts that manage remote Hadoop daemons if the optional start and stop scripts are to be used. Additionally, it is recommmended that pdsh also be installed for better ssh resource management. 需要java的支持和sshd的支持， 文档中推荐安装pdsh，我这里提一句，Hadoop会自动检测pdsh的安装与否，如果安装了它就会使用pdsh，除非你清楚pdsh如何配置和使用，否则不要安装pdsh 那就检查一下 HadoopJavaVersions Supported Java Versions Apache Hadoop 3.3 and upper supports Java 8 and Java 11 (runtime only) Please compile Hadoop with Java 8. Compiling Hadoop with Java 11 is not supported: HADOOP-16795 - Java 11 compile support Open Apache Hadoop from 3.0.x to 3.2.x now supports only Java 8 Apache Hadoop from 2.7.x to 2.10.x support both Java 7 and 8 也就是说只能在openjdk-8编译，对于openjdk-11，只能运行，但不能用于编译 但是注意到这篇文章的日期最后修改日期是2020年10月19日 访问 Java 11 compile support ，发现很多issue已经被标记为solved或者resolved 但是既然说明文档还没有标记openjdk-11已经完全得到支持，这里就采用它的说法，不要强行尝试用OpenJDK-11编译 因为主机这边已经安装了OpenJDK-11，可能需要再安装一个OpenJDK-8，Linux中的java支持用update-alternatives来切换提供java命令支持的JRE、JDK版本 Installing Multiple Java Versions On Linux Mint 20 How to work with multiple java versions under Linux 不过目前还不用执行这个方案，我的策略如下 如果获得了Hadoop的二进制文件，那么就在Docker中安装OpenJDK-11，这是为了安全 如果只能获取到Hadoop的源码，必须自己编译，那么一个更简单的方案是在Docker中安装OpenJDK-8负责编译和运行工作 一个稍稍复杂的方法是在本机安装OpenJDK-8，编译出二进制文件，再使用Docker中的OpenJDK-11来运行它 我的时间不多，只能考虑前两个方案 打包之前做好的debian镜像，其中包含了我修改过的镜像源配置，以及一个安装好的nano，如果我对JDK的选择有误，那么就回到这一步 先确保docker的容器关闭 1docker ps 结果显示 123➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES➜ ~ 没有容器处在运行状态，好的，准备打包 执行 1docker commit distracted_shockley debian_startpoint 运行结果是： 12345678➜ ~ docker commit distracted_shockley debian_startpointsha256:d11256cddabc2ea308e8e1bb7954de8c4457e7b635fcab53eb5c2627bed08a91➜ ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdebian_startpoint latest d11256cddabc 6 seconds ago 146MBdebian latest 34b4fa67dc04 2 weeks ago 124MBhello-world latest feb5d9fea6a5 20 months ago 13.3kB➜ ~ 镜像创建完毕，打开原来的容器，准备安装软件 1apt install openssh-client openssh-server openjdk-11-jre 提示我需要470MiB的磁盘空间 1apt install openssh-client openssh-server openjdk-11-jdk 提示我需要706MiB的磁盘空间 I think that we just don't have too much choice So, JUST DO IT 1apt install openssh-client openssh-server openjdk-11-jdk 此外，为了便于管理，还应该安装sudo 1apt install sudo 等待安装完毕，检查 1234root@da62261bc436:/# java -versionopenjdk version \"11.0.18\" 2023-01-17OpenJDK Runtime Environment (build 11.0.18+10-post-Debian-1deb11u1)OpenJDK 64-Bit Server VM (build 11.0.18+10-post-Debian-1deb11u1, mixed mode, sharing) 123456root@da62261bc436:/# sshd -v unknown option -- vOpenSSH_8.4p1 Debian-5+deb11u1, OpenSSL 1.1.1n 15 Mar 2022usage: sshd [-46DdeiqTt] [-C connection_spec] [-c host_cert_file] [-E log_file] [-f config_file] [-g login_grace_time] [-h host_key_file] [-o option] [-p port] [-u len] 但是当我尝试运行 1root@da62261bc436:/# systemctl enable ssh &amp;&amp; systemctl start ssh 的时候，提示 Synchronizing state of ssh.service with SysV service script with /lib/systemd/systemd-sysv-install. Executing: /lib/systemd/systemd-sysv-install enable ssh System has not been booted with systemd as init system (PID 1). Can't operate. Failed to connect to bus: Host is down docker的容器并非由systemd唤起，这好像也不难理解，注意到菜鸟教程创建容器时使用了--privileged参数，这会导致容器内的东西泄漏出来，这可不太明智 目前来看，也没必要现在就运行sshd，可以之后用exec运行它，注意，运行sshd需要使用绝对路径，也就是/usr/sbin/sshd 先执行 1mkdir /run/sshd/ 创建sshd所需的目录，以便稍后运行sshd 由于不应该允许通过ssh登录root，因此创建一个新用户remoteU用于ssh 1useradd -d /home/remoteU -m -s /bin/bash remoteU 其中-m选项新建了用户目录 修改remoteU的密码 1passwd remoteU su进去配置密钥 1su remoteU 1ssh-keygen -t rsa 一路回车过去，按照默认设置配好 然后，cd进~/.ssh/ 1nano authorized_keys 把自己的主机的公钥贴进去，然后应该就完事了 下载与校验Hadoop 另一边，主机也不用闲着，开始下载hadoop的二进制文件 12cd ~/Downloads/curl -fSL -O https://dlcdn.apache.org/hadoop/common/stable/hadoop-3.3.5.tar.gz 查看sha512为 SHA512 (hadoop-3.3.5.tar.gz) = cc170df24976543a3e961a1353a19422 5e3ffc5d53d594dd63d71422765e1d81 6d1ffa877c02bf93f0183fcfbe4c10f4 b7739deca69420ed83372a0b1f9d5dc7 核验本地 12➜ Downloads sha512sum hadoop-3.3.5.tar.gz cc170df24976543a3e961a1353a194225e3ffc5d53d594dd63d71422765e1d816d1ffa877c02bf93f0183fcfbe4c10f4b7739deca69420ed83372a0b1f9d5dc7 hadoop-3.3.5.tar.gz Hadoop的安装 这个软件需要手动安装，事实上，它的安装只是需要移动二进制文件到某个看起来很系统级的目录，然后配置几个环境变量 拷进容器里面 1docker cp ~/Downloads/hadoop-3.3.5.tar.gz distracted_shockley:/root/ 首先是确保我们能找到hadoop 在容器用户的~/.bashrc中添加 1export PATH=$PATH:/usr/local/hadoop/bin:/usr/local/hadoop/sbin 以便我输入有关hadoop的命令时，bash都了解如何找到hadoop 下来是让hadoop自己搞清楚方向， 修改/usr/local/hadoop/etc/hadoop/hadoop-env.sh 查找JAVA_HOME=，修改为java的路径，例如我通过whereis java查找java的二进制文件，查找它的软链接目标，最后确定路径是/usr/lib/jvm/java-11-openjdk-amd64 1export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64 查找HADOOP_HOME=，修改为hadoop的安装位置，例如此时安装在了/usr/local/hadoop，那么就写 1export HADOOP_HOME=/usr/local/hadoop 到这一步，hadoop的环境变量就配完了 1hadoop version 可以看到提示 1234567root@da62261bc436:/usr/local/hadoop/etc/hadoop# hadoop versionHadoop 3.3.5Source code repository https://github.com/apache/hadoop.git -r 706d88266abcee09ed78fbaa0ad5f74d818ab0e9Compiled by stevel on 2023-03-15T15:56ZCompiled with protoc 3.7.1From source with checksum 6bbd9afcf4838a0eb12a5f189e9bd7This command was run using /usr/local/hadoop/share/hadoop/common/hadoop-common-3.3.5.jar Hadoop的配置 按照 Hadoop: Setting up a Single Node Cluster. 的说明 修改etc/hadoop/core-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改etc/hadoop/hdfs-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 默认配置中，http监视服务运行在http://localhost:9870/ 但是我们可能需要从外部访问http监视服务 因此更改etc/hadoop/hdfs-site.xml，增添 1234&lt;property&gt; &lt;name&gt;dfs.http.address&lt;/name&gt; &lt;value&gt;0.0.0.0:9870&lt;/value&gt;&lt;/property&gt; 这样，http服务就会绑定在本机上，便于将来从容器外部访问 此外，不知怎地hadoop一定强调要求我配置好ssh，并且需要达成不通过密码访问本地的sshd的效果，也就是要用公私钥体制， 之前的说明也只是说脚本里有几个守护进程，依赖什么的 按照要求的做 123ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsacat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keyschmod 0600 ~/.ssh/authorized_keys 以防万一，我将两个用户root和remoteU都配了一遍，把自己的公钥加入到自己的ssh允许列表里面 虽然允许远程登录root很不安全，但这里是容器环境，所以先这样 容器环境不能够使用systemd的守护进程，所以sshd不会随“开机”自动启动，需要自己手动启动sshd服务器，因此输入 1/usr/sbin/sshd 以便在本地启用一个ssh服务器 测试一下： 12345678910root@da62261bc436:/usr/local/hadoop/etc/hadoop# ssh localhostLinux da62261bc436 5.15.0-72-generic #79-Ubuntu SMP Wed Apr 19 08:22:18 UTC 2023 x86_64The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.root@da62261bc436:~# 这说明ssh服务器已经按照要求配置完成 运行Hadoop的HDFS 格式化namenode 123456root@da62261bc436:/usr/local/hadoop/etc/hadoop# hdfs namenode -formatWARNING: /usr/local/hadoop/logs does not exist. Creating.# 此处的日志实在太长，故挪到了文章末尾处SHUTDOWN_MSG: Shutting down NameNode at da62261bc436/172.17.0.2************************************************************/root@da62261bc436:/usr/local/hadoop/etc/hadoop# 如此这般，没有报错，格式化应该是完成了 启动hdfs 运行 1start-dfs.sh 时遇到了问题 but there is no HDFS_NAMENODE_USER defined. Aborting operation. 由于我将容器运行在只有root的模式下，因此在文件中配置指定用户名 123456# SERVICE USER OPTIONSexport HDFS_NAMENODE_USER=\"root\"export HDFS_DATANODE_USER=\"root\"export HDFS_SECONDARYNAMENODE_USER=\"root\"export YARN_RESOURCEMANAGER_USER=\"root\"export YARN_NODEMANAGER_USER=\"root\" 由于hadoop会自动检测是否安装pdsh，但如果安装了但是没有配置pdsh,那么就容易得到拒绝连接的提示 因此应当apt purge pdsh卸载pdsh, 或者按照 Hadoop : start-dfs.sh Connection refused 的方式处理问题 无论如何，我得到了提示 12345root@da62261bc436:~# start-dfs.sh Starting namenodes on [localhost]Starting datanodesStarting secondary namenodes [da62261bc436]da62261bc436: Warning: Permanently added 'da62261bc436,172.17.0.2' (ECDSA) to the list of known hosts. 看起来相关服务已经运行起来了，用java进程检查器jps看一下有什么java服务正在运行 12345root@da62261bc436:~# jps3061 Jps2569 NameNode2863 SecondaryNameNode2671 DataNode 我的容器里面没有安装图形界面和浏览器，而且暂时还没有对外暴露端口，因此只能用w3m浏览器稍稍检查一下http服务的情况 1w3m http://localhost:9870 虽然终端下的浏览器渲染出来的网页很简陋，但是勉强能看出来，9870端口上有个http服务器正在努力地工作着，并且提供了一个动态的网页，之后只要把这个端口暴露出去，就可以在外面访问它了 进行文件操作 运行 1hdfs dfs -help 会得到一份命令清单 按照说明，新建一个 1hdfs dfs -mkdir /helloworld 要查看它，执行 1hdfs dfs -ls / 得到提示 12Found 1 itemsdrwxr-xr-x - root supergroup 0 2023-05-22 18:13 /helloworld 在本地新建一个示例文件 12cd ~touch thereisanexample 12hdfs dfs -put ./thereisanexample /helloworld/hdfs dfs -ls /helloworld 1hdfs dfs -mv /helloworld/thereisanexample /helloworld/thereisanotherexample 1hdfs dfs -ls /helloworld 12hdfs dfs -get /helloworld/thereisanotherexample ./ll 真是功夫不负有心人，进行到这一步，可以打包一下容器，使之成为映像，准备下一步工作 关闭服务，退出容器 12stop-all.shexit 1docker commit distracted_shockley hadoop_on_debian 这次打包耗时很久 123456➜ ~ docker images REPOSITORY TAG IMAGE ID CREATED SIZEhadoop_on_debian latest f6ddd02c25a0 12 seconds ago 2.96GBdebian_startpoint latest d11256cddabc 5 hours ago 146MBdebian latest 34b4fa67dc04 2 weeks ago 124MBhello-world latest feb5d9fea6a5 20 months ago 13.3kB 2.96Gi 不能说小 探索——在docker中组建Hadoop集群 先明确一下开机流程： 12/usr/sbin/sshdstart-dfs.sh 容器对外开放的端口必须在创建时确定 哪些端口需要得到调整呢？统计一下 名称 端口 sshd 22 hdfs 9000 dfs-webUI 9870 附录 hdfs namenode -format的日志输出 Debian的Docker映像中预装软件包列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283WARNING: /usr/local/hadoop/logs does not exist. Creating.2023-05-22 17:14:05,595 INFO namenode.NameNode: STARTUP_MSG: /************************************************************STARTUP_MSG: Starting NameNodeSTARTUP_MSG: host = da62261bc436/172.17.0.2STARTUP_MSG: args = [-format]STARTUP_MSG: version = 3.3.5STARTUP_MSG: classpath = /usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/netty-all-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/jetty-servlet-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/common/lib/kerb-simplekdc-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/kerb-identity-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-codec-redis-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/kerby-pkix-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-codec-haproxy-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-codec-xml-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/jsch-0.1.55.jar:/usr/local/hadoop/share/hadoop/common/lib/snappy-java-1.1.8.2.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-resolver-dns-classes-macos-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/jackson-annotations-2.12.7.jar:/usr/local/hadoop/share/hadoop/common/lib/kerb-core-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/curator-framework-4.2.0.jar:/usr/local/hadoop/share/hadoop/common/lib/commons-compress-1.21.jar:/usr/local/hadoop/share/hadoop/common/lib/protobuf-java-2.5.0.jar:/usr/local/hadoop/share/hadoop/common/lib/j2objc-annotations-1.1.jar:/usr/local/hadoop/share/hadoop/common/lib/commons-beanutils-1.9.4.jar:/usr/local/hadoop/share/hadoop/common/lib/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/usr/local/hadoop/share/hadoop/common/lib/jackson-databind-2.12.7.1.jar:/usr/local/hadoop/share/hadoop/common/lib/commons-logging-1.1.3.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-transport-udt-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/slf4j-reload4j-1.7.36.jar:/usr/local/hadoop/share/hadoop/common/lib/commons-text-1.10.0.jar:/usr/local/hadoop/share/hadoop/common/lib/hadoop-annotations-3.3.5.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-transport-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/jetty-xml-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/common/lib/slf4j-api-1.7.36.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-codec-memcache-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-transport-native-epoll-4.1.77.Final-linux-aarch_64.jar:/usr/local/hadoop/share/hadoop/common/lib/guava-27.0-jre.jar:/usr/local/hadoop/share/hadoop/common/lib/commons-math3-3.1.1.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-resolver-dns-native-macos-4.1.77.Final-osx-x86_64.jar:/usr/local/hadoop/share/hadoop/common/lib/jaxb-impl-2.2.3-1.jar:/usr/local/hadoop/share/hadoop/common/lib/jul-to-slf4j-1.7.36.jar:/usr/local/hadoop/share/hadoop/common/lib/reload4j-1.2.22.jar:/usr/local/hadoop/share/hadoop/common/lib/commons-collections-3.2.2.jar:/usr/local/hadoop/share/hadoop/common/lib/commons-daemon-1.0.13.jar:/usr/local/hadoop/share/hadoop/common/lib/nimbus-jose-jwt-9.8.1.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-resolver-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/woodstox-core-5.4.0.jar:/usr/local/hadoop/share/hadoop/common/lib/hadoop-shaded-guava-1.1.1.jar:/usr/local/hadoop/share/hadoop/common/lib/jackson-core-asl-1.9.13.jar:/usr/local/hadoop/share/hadoop/common/lib/kerb-admin-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/jersey-servlet-1.19.4.jar:/usr/local/hadoop/share/hadoop/common/lib/metrics-core-3.2.4.jar:/usr/local/hadoop/share/hadoop/common/lib/commons-configuration2-2.8.0.jar:/usr/local/hadoop/share/hadoop/common/lib/kerby-util-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/hadoop-auth-3.3.5.jar:/usr/local/hadoop/share/hadoop/common/lib/httpcore-4.4.13.jar:/usr/local/hadoop/share/hadoop/common/lib/animal-sniffer-annotations-1.17.jar:/usr/local/hadoop/share/hadoop/common/lib/jsp-api-2.1.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-transport-classes-kqueue-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/javax.servlet-api-3.1.0.jar:/usr/local/hadoop/share/hadoop/common/lib/asm-5.0.4.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-codec-stomp-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/curator-recipes-4.2.0.jar:/usr/local/hadoop/share/hadoop/common/lib/failureaccess-1.0.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-codec-socks-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-codec-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/token-provider-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/re2j-1.1.jar:/usr/local/hadoop/share/hadoop/common/lib/jersey-json-1.20.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-codec-smtp-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/httpclient-4.5.13.jar:/usr/local/hadoop/share/hadoop/common/lib/commons-io-2.8.0.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-codec-http2-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/jersey-server-1.19.4.jar:/usr/local/hadoop/share/hadoop/common/lib/jetty-webapp-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-resolver-dns-native-macos-4.1.77.Final-osx-aarch_64.jar:/usr/local/hadoop/share/hadoop/common/lib/avro-1.7.7.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-transport-native-epoll-4.1.77.Final-linux-x86_64.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-codec-mqtt-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/commons-cli-1.2.jar:/usr/local/hadoop/share/hadoop/common/lib/gson-2.9.0.jar:/usr/local/hadoop/share/hadoop/common/lib/kerby-config-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/checker-qual-2.5.2.jar:/usr/local/hadoop/share/hadoop/common/lib/jakarta.activation-api-1.2.1.jar:/usr/local/hadoop/share/hadoop/common/lib/kerby-xdr-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/kerb-common-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/jcip-annotations-1.0-1.jar:/usr/local/hadoop/share/hadoop/common/lib/jsr311-api-1.1.1.jar:/usr/local/hadoop/share/hadoop/common/lib/hadoop-shaded-protobuf_3_7-1.1.1.jar:/usr/local/hadoop/share/hadoop/common/lib/commons-codec-1.15.jar:/usr/local/hadoop/share/hadoop/common/lib/commons-net-3.9.0.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-codec-http-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/commons-lang3-3.12.0.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-transport-native-kqueue-4.1.77.Final-osx-x86_64.jar:/usr/local/hadoop/share/hadoop/common/lib/paranamer-2.3.jar:/usr/local/hadoop/share/hadoop/common/lib/kerb-server-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-common-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-codec-dns-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-handler-proxy-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-transport-sctp-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-transport-rxtx-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/jetty-util-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/common/lib/jetty-security-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/common/lib/kerb-crypto-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/jetty-server-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/common/lib/jetty-util-ajax-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-transport-native-kqueue-4.1.77.Final-osx-aarch_64.jar:/usr/local/hadoop/share/hadoop/common/lib/audience-annotations-0.5.0.jar:/usr/local/hadoop/share/hadoop/common/lib/jsr305-3.0.2.jar:/usr/local/hadoop/share/hadoop/common/lib/dnsjava-2.1.7.jar:/usr/local/hadoop/share/hadoop/common/lib/jetty-io-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/common/lib/jersey-core-1.19.4.jar:/usr/local/hadoop/share/hadoop/common/lib/jackson-core-2.12.7.jar:/usr/local/hadoop/share/hadoop/common/lib/jackson-mapper-asl-1.9.13.jar:/usr/local/hadoop/share/hadoop/common/lib/jettison-1.5.3.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-handler-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/zookeeper-3.5.6.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-resolver-dns-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/kerb-util-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/zookeeper-jute-3.5.6.jar:/usr/local/hadoop/share/hadoop/common/lib/json-smart-2.4.7.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-buffer-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-transport-classes-epoll-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/lib/jetty-http-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/common/lib/kerby-asn1-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/jaxb-api-2.2.11.jar:/usr/local/hadoop/share/hadoop/common/lib/kerb-client-1.0.1.jar:/usr/local/hadoop/share/hadoop/common/lib/stax2-api-4.2.1.jar:/usr/local/hadoop/share/hadoop/common/lib/curator-client-4.2.0.jar:/usr/local/hadoop/share/hadoop/common/lib/accessors-smart-2.4.7.jar:/usr/local/hadoop/share/hadoop/common/lib/netty-transport-native-unix-common-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/common/hadoop-common-3.3.5.jar:/usr/local/hadoop/share/hadoop/common/hadoop-registry-3.3.5.jar:/usr/local/hadoop/share/hadoop/common/hadoop-common-3.3.5-tests.jar:/usr/local/hadoop/share/hadoop/common/hadoop-kms-3.3.5.jar:/usr/local/hadoop/share/hadoop/common/hadoop-nfs-3.3.5.jar:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-all-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jetty-servlet-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerb-simplekdc-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerb-identity-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-codec-redis-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerby-pkix-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-codec-haproxy-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-codec-xml-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jsch-0.1.55.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/snappy-java-1.1.8.2.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-resolver-dns-classes-macos-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/json-simple-1.1.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jackson-annotations-2.12.7.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerb-core-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/curator-framework-4.2.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/commons-compress-1.21.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/protobuf-java-2.5.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/j2objc-annotations-1.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/commons-beanutils-1.9.4.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jackson-databind-2.12.7.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/commons-logging-1.1.3.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-transport-udt-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-3.10.6.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/commons-text-1.10.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/hadoop-annotations-3.3.5.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-transport-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jetty-xml-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-codec-memcache-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-transport-native-epoll-4.1.77.Final-linux-aarch_64.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/guava-27.0-jre.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/commons-math3-3.1.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-resolver-dns-native-macos-4.1.77.Final-osx-x86_64.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jaxb-impl-2.2.3-1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/reload4j-1.2.22.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/commons-collections-3.2.2.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/commons-daemon-1.0.13.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/nimbus-jose-jwt-9.8.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-resolver-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/woodstox-core-5.4.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/hadoop-shaded-guava-1.1.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jackson-core-asl-1.9.13.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerb-admin-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jersey-servlet-1.19.4.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/commons-configuration2-2.8.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerby-util-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/hadoop-auth-3.3.5.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/httpcore-4.4.13.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/animal-sniffer-annotations-1.17.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/leveldbjni-all-1.8.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-transport-classes-kqueue-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/javax.servlet-api-3.1.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/asm-5.0.4.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-codec-stomp-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/curator-recipes-4.2.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/failureaccess-1.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-codec-socks-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-codec-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/token-provider-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/re2j-1.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jersey-json-1.20.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-codec-smtp-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/httpclient-4.5.13.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/commons-io-2.8.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-codec-http2-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jersey-server-1.19.4.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jetty-webapp-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-resolver-dns-native-macos-4.1.77.Final-osx-aarch_64.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/avro-1.7.7.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kotlin-stdlib-common-1.4.10.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-transport-native-epoll-4.1.77.Final-linux-x86_64.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-codec-mqtt-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/commons-cli-1.2.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/gson-2.9.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerby-config-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/checker-qual-2.5.2.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jakarta.activation-api-1.2.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerby-xdr-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerb-common-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jcip-annotations-1.0-1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jsr311-api-1.1.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/hadoop-shaded-protobuf_3_7-1.1.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/commons-codec-1.15.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/commons-net-3.9.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-codec-http-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/commons-lang3-3.12.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-transport-native-kqueue-4.1.77.Final-osx-x86_64.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/paranamer-2.3.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerb-server-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-common-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kotlin-stdlib-1.4.10.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-codec-dns-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-handler-proxy-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-transport-sctp-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-transport-rxtx-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jetty-util-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jetty-security-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerb-crypto-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jetty-server-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jetty-util-ajax-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-transport-native-kqueue-4.1.77.Final-osx-aarch_64.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/audience-annotations-0.5.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/okio-2.8.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/okhttp-4.9.3.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jsr305-3.0.2.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/dnsjava-2.1.7.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jetty-io-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jersey-core-1.19.4.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jackson-core-2.12.7.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jackson-mapper-asl-1.9.13.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jettison-1.5.3.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-handler-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/zookeeper-3.5.6.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-resolver-dns-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerb-util-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/zookeeper-jute-3.5.6.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/json-smart-2.4.7.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-buffer-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-transport-classes-epoll-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jetty-http-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerby-asn1-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/jaxb-api-2.2.11.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/kerb-client-1.0.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/stax2-api-4.2.1.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/curator-client-4.2.0.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/accessors-smart-2.4.7.jar:/usr/local/hadoop/share/hadoop/hdfs/lib/netty-transport-native-unix-common-4.1.77.Final.jar:/usr/local/hadoop/share/hadoop/hdfs/hadoop-hdfs-client-3.3.5-tests.jar:/usr/local/hadoop/share/hadoop/hdfs/hadoop-hdfs-nfs-3.3.5.jar:/usr/local/hadoop/share/hadoop/hdfs/hadoop-hdfs-native-client-3.3.5.jar:/usr/local/hadoop/share/hadoop/hdfs/hadoop-hdfs-3.3.5-tests.jar:/usr/local/hadoop/share/hadoop/hdfs/hadoop-hdfs-rbf-3.3.5-tests.jar:/usr/local/hadoop/share/hadoop/hdfs/hadoop-hdfs-native-client-3.3.5-tests.jar:/usr/local/hadoop/share/hadoop/hdfs/hadoop-hdfs-client-3.3.5.jar:/usr/local/hadoop/share/hadoop/hdfs/hadoop-hdfs-httpfs-3.3.5.jar:/usr/local/hadoop/share/hadoop/hdfs/hadoop-hdfs-rbf-3.3.5.jar:/usr/local/hadoop/share/hadoop/hdfs/hadoop-hdfs-3.3.5.jar:/usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-client-jobclient-3.3.5-tests.jar:/usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-client-shuffle-3.3.5.jar:/usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-client-nativetask-3.3.5.jar:/usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-client-common-3.3.5.jar:/usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-client-hs-3.3.5.jar:/usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-client-core-3.3.5.jar:/usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-client-uploader-3.3.5.jar:/usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-client-app-3.3.5.jar:/usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-client-hs-plugins-3.3.5.jar:/usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.5.jar:/usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-client-jobclient-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/HikariCP-java7-2.4.12.jar:/usr/local/hadoop/share/hadoop/yarn/lib/snakeyaml-1.32.jar:/usr/local/hadoop/share/hadoop/yarn/lib/guice-servlet-4.0.jar:/usr/local/hadoop/share/hadoop/yarn/lib/jackson-module-jaxb-annotations-2.12.7.jar:/usr/local/hadoop/share/hadoop/yarn/lib/jetty-client-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/yarn/lib/jline-3.9.0.jar:/usr/local/hadoop/share/hadoop/yarn/lib/asm-tree-9.3.jar:/usr/local/hadoop/share/hadoop/yarn/lib/javax.websocket-client-api-1.0.jar:/usr/local/hadoop/share/hadoop/yarn/lib/websocket-server-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/yarn/lib/jna-5.2.0.jar:/usr/local/hadoop/share/hadoop/yarn/lib/javax.websocket-api-1.0.jar:/usr/local/hadoop/share/hadoop/yarn/lib/aopalliance-1.0.jar:/usr/local/hadoop/share/hadoop/yarn/lib/jakarta.xml.bind-api-2.3.2.jar:/usr/local/hadoop/share/hadoop/yarn/lib/jackson-jaxrs-base-2.12.7.jar:/usr/local/hadoop/share/hadoop/yarn/lib/jersey-guice-1.19.4.jar:/usr/local/hadoop/share/hadoop/yarn/lib/json-io-2.5.1.jar:/usr/local/hadoop/share/hadoop/yarn/lib/metrics-core-3.2.4.jar:/usr/local/hadoop/share/hadoop/yarn/lib/geronimo-jcache_1.0_spec-1.0-alpha-1.jar:/usr/local/hadoop/share/hadoop/yarn/lib/asm-commons-9.3.jar:/usr/local/hadoop/share/hadoop/yarn/lib/websocket-common-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/yarn/lib/fst-2.50.jar:/usr/local/hadoop/share/hadoop/yarn/lib/guice-4.0.jar:/usr/local/hadoop/share/hadoop/yarn/lib/mssql-jdbc-6.2.1.jre7.jar:/usr/local/hadoop/share/hadoop/yarn/lib/jackson-jaxrs-json-provider-2.12.7.jar:/usr/local/hadoop/share/hadoop/yarn/lib/javax-websocket-server-impl-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/yarn/lib/websocket-servlet-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/yarn/lib/objenesis-2.6.jar:/usr/local/hadoop/share/hadoop/yarn/lib/websocket-client-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/yarn/lib/bcprov-jdk15on-1.68.jar:/usr/local/hadoop/share/hadoop/yarn/lib/javax.inject-1.jar:/usr/local/hadoop/share/hadoop/yarn/lib/ehcache-3.3.1.jar:/usr/local/hadoop/share/hadoop/yarn/lib/jetty-plus-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/yarn/lib/asm-analysis-9.3.jar:/usr/local/hadoop/share/hadoop/yarn/lib/jersey-client-1.19.4.jar:/usr/local/hadoop/share/hadoop/yarn/lib/java-util-1.9.0.jar:/usr/local/hadoop/share/hadoop/yarn/lib/websocket-api-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/yarn/lib/swagger-annotations-1.5.4.jar:/usr/local/hadoop/share/hadoop/yarn/lib/jetty-annotations-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/yarn/lib/javax-websocket-client-impl-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/yarn/lib/bcpkix-jdk15on-1.68.jar:/usr/local/hadoop/share/hadoop/yarn/lib/jetty-jndi-9.4.48.v20220622.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-server-tests-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-api-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-services-api-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-server-common-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-server-applicationhistoryservice-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-registry-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-client-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-server-nodemanager-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-applications-distributedshell-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-server-resourcemanager-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-server-sharedcachemanager-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-applications-mawo-core-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-server-router-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-server-web-proxy-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-common-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-services-core-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-applications-unmanaged-am-launcher-3.3.5.jar:/usr/local/hadoop/share/hadoop/yarn/hadoop-yarn-server-timeline-pluginstorage-3.3.5.jarSTARTUP_MSG: build = https://github.com/apache/hadoop.git -r 706d88266abcee09ed78fbaa0ad5f74d818ab0e9; compiled by 'stevel' on 2023-03-15T15:56ZSTARTUP_MSG: java = 11.0.18************************************************************/2023-05-22 17:14:05,608 INFO namenode.NameNode: registered UNIX signal handlers for [TERM, HUP, INT]2023-05-22 17:14:05,711 INFO namenode.NameNode: createNameNode [-format]2023-05-22 17:14:06,455 INFO namenode.NameNode: Formatting using clusterid: CID-a4ea0573-7af8-4f0d-b9e8-ef59910dc1552023-05-22 17:14:06,547 INFO namenode.FSEditLog: Edit logging is async:true2023-05-22 17:14:06,610 INFO namenode.FSNamesystem: KeyProvider: null2023-05-22 17:14:06,611 INFO namenode.FSNamesystem: fsLock is fair: true2023-05-22 17:14:06,612 INFO namenode.FSNamesystem: Detailed lock hold time metrics enabled: false2023-05-22 17:14:06,673 INFO namenode.FSNamesystem: fsOwner = root (auth:SIMPLE)2023-05-22 17:14:06,673 INFO namenode.FSNamesystem: supergroup = supergroup2023-05-22 17:14:06,673 INFO namenode.FSNamesystem: isPermissionEnabled = true2023-05-22 17:14:06,673 INFO namenode.FSNamesystem: isStoragePolicyEnabled = true2023-05-22 17:14:06,674 INFO namenode.FSNamesystem: HA Enabled: false2023-05-22 17:14:06,783 INFO common.Util: dfs.datanode.fileio.profiling.sampling.percentage set to 0. Disabling file IO profiling2023-05-22 17:14:06,962 INFO blockmanagement.DatanodeManager: dfs.block.invalidate.limit : configured=1000, counted=60, effected=10002023-05-22 17:14:06,962 INFO blockmanagement.DatanodeManager: dfs.namenode.datanode.registration.ip-hostname-check=true2023-05-22 17:14:06,964 INFO blockmanagement.BlockManager: dfs.namenode.startup.delay.block.deletion.sec is set to 000:00:00:00.0002023-05-22 17:14:06,964 INFO blockmanagement.BlockManager: The block deletion will start around 2023 May 22 17:14:062023-05-22 17:14:06,965 INFO util.GSet: Computing capacity for map BlocksMap2023-05-22 17:14:06,965 INFO util.GSet: VM type = 64-bit2023-05-22 17:14:06,978 INFO util.GSet: 2.0% max memory 3.9 GB = 79.7 MB2023-05-22 17:14:06,978 INFO util.GSet: capacity = 2^23 = 8388608 entries2023-05-22 17:14:07,005 INFO blockmanagement.BlockManager: Storage policy satisfier is disabled2023-05-22 17:14:07,005 INFO blockmanagement.BlockManager: dfs.block.access.token.enable = false2023-05-22 17:14:07,009 INFO blockmanagement.BlockManagerSafeMode: dfs.namenode.safemode.threshold-pct = 0.9992023-05-22 17:14:07,009 INFO blockmanagement.BlockManagerSafeMode: dfs.namenode.safemode.min.datanodes = 02023-05-22 17:14:07,009 INFO blockmanagement.BlockManagerSafeMode: dfs.namenode.safemode.extension = 300002023-05-22 17:14:07,010 INFO blockmanagement.BlockManager: defaultReplication = 12023-05-22 17:14:07,010 INFO blockmanagement.BlockManager: maxReplication = 5122023-05-22 17:14:07,010 INFO blockmanagement.BlockManager: minReplication = 12023-05-22 17:14:07,010 INFO blockmanagement.BlockManager: maxReplicationStreams = 22023-05-22 17:14:07,010 INFO blockmanagement.BlockManager: redundancyRecheckInterval = 3000ms2023-05-22 17:14:07,010 INFO blockmanagement.BlockManager: encryptDataTransfer = false2023-05-22 17:14:07,010 INFO blockmanagement.BlockManager: maxNumBlocksToLog = 10002023-05-22 17:14:07,106 INFO namenode.FSDirectory: GLOBAL serial map: bits=29 maxEntries=5368709112023-05-22 17:14:07,107 INFO namenode.FSDirectory: USER serial map: bits=24 maxEntries=167772152023-05-22 17:14:07,107 INFO namenode.FSDirectory: GROUP serial map: bits=24 maxEntries=167772152023-05-22 17:14:07,107 INFO namenode.FSDirectory: XATTR serial map: bits=24 maxEntries=167772152023-05-22 17:14:07,123 INFO util.GSet: Computing capacity for map INodeMap2023-05-22 17:14:07,124 INFO util.GSet: VM type = 64-bit2023-05-22 17:14:07,124 INFO util.GSet: 1.0% max memory 3.9 GB = 39.8 MB2023-05-22 17:14:07,124 INFO util.GSet: capacity = 2^22 = 4194304 entries2023-05-22 17:14:07,135 INFO namenode.FSDirectory: ACLs enabled? true2023-05-22 17:14:07,135 INFO namenode.FSDirectory: POSIX ACL inheritance enabled? true2023-05-22 17:14:07,135 INFO namenode.FSDirectory: XAttrs enabled? true2023-05-22 17:14:07,135 INFO namenode.NameNode: Caching file names occurring more than 10 times2023-05-22 17:14:07,143 INFO snapshot.SnapshotManager: Loaded config captureOpenFiles: false, skipCaptureAccessTimeOnlyChange: false, snapshotDiffAllowSnapRootDescendant: true, maxSnapshotLimit: 655362023-05-22 17:14:07,145 INFO snapshot.SnapshotManager: SkipList is disabled2023-05-22 17:14:07,150 INFO util.GSet: Computing capacity for map cachedBlocks2023-05-22 17:14:07,150 INFO util.GSet: VM type = 64-bit2023-05-22 17:14:07,150 INFO util.GSet: 0.25% max memory 3.9 GB = 10.0 MB2023-05-22 17:14:07,150 INFO util.GSet: capacity = 2^20 = 1048576 entries2023-05-22 17:14:07,160 INFO metrics.TopMetrics: NNTop conf: dfs.namenode.top.window.num.buckets = 102023-05-22 17:14:07,160 INFO metrics.TopMetrics: NNTop conf: dfs.namenode.top.num.users = 102023-05-22 17:14:07,160 INFO metrics.TopMetrics: NNTop conf: dfs.namenode.top.windows.minutes = 1,5,252023-05-22 17:14:07,163 INFO namenode.FSNamesystem: Retry cache on namenode is enabled2023-05-22 17:14:07,163 INFO namenode.FSNamesystem: Retry cache will use 0.03 of total heap and retry cache entry expiry time is 600000 millis2023-05-22 17:14:07,165 INFO util.GSet: Computing capacity for map NameNodeRetryCache2023-05-22 17:14:07,165 INFO util.GSet: VM type = 64-bit2023-05-22 17:14:07,165 INFO util.GSet: 0.029999999329447746% max memory 3.9 GB = 1.2 MB2023-05-22 17:14:07,165 INFO util.GSet: capacity = 2^17 = 131072 entries2023-05-22 17:14:07,197 INFO namenode.FSImage: Allocated new BlockPoolId: BP-633437213-172.17.0.2-16847756471752023-05-22 17:14:07,340 INFO common.Storage: Storage directory /tmp/hadoop-root/dfs/name has been successfully formatted.2023-05-22 17:14:07,425 INFO namenode.FSImageFormatProtobuf: Saving image file /tmp/hadoop-root/dfs/name/current/fsimage.ckpt_0000000000000000000 using no compression2023-05-22 17:14:07,561 INFO namenode.FSImageFormatProtobuf: Image file /tmp/hadoop-root/dfs/name/current/fsimage.ckpt_0000000000000000000 of size 399 bytes saved in 0 seconds .2023-05-22 17:14:07,676 INFO namenode.NNStorageRetentionManager: Going to retain 1 images with txid &gt;= 02023-05-22 17:14:07,699 INFO namenode.FSNamesystem: Stopping services started for active state2023-05-22 17:14:07,699 INFO namenode.FSNamesystem: Stopping services started for standby state2023-05-22 17:14:07,702 INFO namenode.FSImage: FSImageSaver clean checkpoint: txid=0 when meet shutdown.2023-05-22 17:14:07,702 INFO namenode.NameNode: SHUTDOWN_MSG: /************************************************************SHUTDOWN_MSG: Shutting down NameNode at da62261bc436/172.17.0.2************************************************************/ Knighthana 2023/05/30","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"LinuxMint","slug":"LinuxMint","permalink":"https://knighthana.github.io/tags/LinuxMint/"},{"name":"2023","slug":"2023","permalink":"https://knighthana.github.io/tags/2023/"},{"name":"Docker","slug":"Docker","permalink":"https://knighthana.github.io/tags/Docker/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://knighthana.github.io/tags/Hadoop/"}]},{"title":"(KM)转载-技术人员的发展之路","slug":"(KM)转载-技术人员的发展之路","date":"2023-05-15T16:00:00.000Z","updated":"2023-05-15T16:00:00.000Z","comments":true,"path":"KnowledgeMark/(KM)转载-技术人员的发展之路.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)%E8%BD%AC%E8%BD%BD-%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E7%9A%84%E5%8F%91%E5%B1%95%E4%B9%8B%E8%B7%AF.html","excerpt":"","text":"转载-技术人员的发展之路 转载事由 缅怀陈浩先生 我之前并不认识陈浩先生，也没有关注他的社交账号，而到现在想要认识，或者关注他，已再无意义 只是由于推特不知道通过什么方式识别出来我是一个程序员，我又恰好关注了vue.js的初创者尤雨溪，所以推特经常基于兴趣向我推送一些程序员们的账号 我是觉得，推送给我的这么些账号中，陈浩先生的看法往往是很独特，很切中要害的，而且他不是一个贩卖焦虑的人——我最讨厌那种人，他只是分享一些观点，可能是希望对年轻人们起到一些作用 这些观点，我看了不一定有用，但也没有什么害处 前两天他还发送过一条很有意思的推文，这条被推送到我的时间线上，我阅读了之后，感觉到他看问题的角度就是和我们这些缺乏经验的人不一样，尽管有可能有些时候立场不同，但是他有逻辑，能说服明事理的人，这就足够了 今天晚上突然看到一片说陈浩先生已于上周六去世的消息 我对他说熟悉也实际上并不熟悉，但是我只能说，从不多的了解来看隐约觉得这是一个好人，到了现在只能感叹，人命脆弱，世事无常 作为程序员，我应当关注自己的身体健康了，健康饮食，少熬夜，多锻炼，这些以前天天说，天天做不到，但是确实很重要，尤其是心脑血管健康的问题，我得重视了 打开了他生前建设的博客网站，2016年有这么一篇技术人员的发展之路，很遗憾只能在他去世之后深入了解他的思想 转载一下 虽然我不见得有那个人生经历看得懂，能对此有什么感悟 但是，转载一下吧 这几天遇到的陌生人身上的遗憾的事情太多了 另外，顺便提一下，陈浩先生的朋友yihong0618将陈浩的推特转成了数据，保存在yihong0618/twint 他的另一位朋友，也是合伙人zhao-kun为他创建的纪念页面 技术人员的发展之路 pic 2012年的时候写过一篇叫《程序算法与人生选择》的文章，我用算法来类比如何做选择，说白了就是怎么去计算，但是并没有讲程序员可以发展的方向有哪些。 所以，就算是有这些所谓的方法论，我们可能对自己的发展还是会很纠结和无所事从，尤其是人到了30岁，这种彷徨和迷惑越来越重。虽然我之前也写过一篇《编程年龄和编程技能》的文章，但是还是有很多做技术的人对于自己能否在年纪大时还能去做技术感到没有信心。我猜测，这其中，最大的问题的是，目前从事技术工作的种种负面的经历（比如经常性的加班，被当成棋子或劳动力等等），让人完全看不到希望和前途，尤其是随着年纪越来越大，对未来的越来越没有信心。 同时，也是因为在GIAC的大会被问到，程序员老了怎么办？而在年底这段时间，也和几个朋友在交流中不断地重复谈到个人发展的这个话题。我的人生过半，活到“不惑”的年纪，自然经常性的对什么事都会回头看看总结归纳，所以，在交谈过程中和交谈过后，自己也有一些思考想记录下来。因为我本人也是在这条路上的人，所以，谈不上给他人指导，我同样也是在瞎乱折腾同样每天在思考自己要去哪儿的“一尘世间迷途老生”。况且，我的经历和眼界非常有限，因此，下面的这些关于个人发展的文字和思考必然是受我的眼界和经历所局限的。也欢迎大家补充和指正。 这些东西不一定对，也不一定就是全部，期许可以让你在年底的时候有所思考，在明年的时候有所计划。 目录 一个重要阶段和标志 个人发展的三个方向 一、在职场中发展 1、去顶尖公司 2、去真正的创业公司 3、职业生涯的发展阶段 二、追求人生的经历 三、追求自由的生活 总结 一个重要阶段和标志 在讲个人发展之前，我需要先说一下人生中的一个非常重要的阶段——20到30岁！ 这个阶段的首要任务，就是提升自己学习能力和解决难题的能力。这是一个非常非常关键的时间段！这个时间段几乎决定着你的未来。 30岁以前，这个时间段，应该是人学习和积累的时间段，这个时间段，就是努力学习的时间段。这个时间段，你一定要把时间花在解决问题的技能上。就是说，你一定要练就成的技能是——你能解决大多数人不能解决的问题。使蛮力埋头加班苦干，当一个搬砖老黄牛的是肯定没有前途的。如果你不幸呆在了一个搬砖的地方，天天被业务压得喘不过气来，我建议你宁可让你的项目延期被老板骂，也要把时间挤出来努力学习基础知识，多掌握一些技术（很多技术在思路上是相通的），然后才能有机会改变自己目前的状况。因为，比起你的个人未来，项目延期被老板骂、绩效不好拿不到奖金，都不是什么事儿。 总结一下，你在30岁前，工作5-7年，你需要拥有： 高效的学习能力。这意味着——基础知识扎实、触类旁通、读英文文档不费劲、有寻找前沿知识的能力、能够看到问题和技术的本质、善于思辩、能独立思考。 解决问题的能力。这意味着——你要高效的学习能力、见过很多的场景、犯过或是处理很多错误、能够防火而不是救火。 如果你拥有这两个能力的现象是—— 在团队或身边的人群中的显现出Leadership。 Leadership并不是当领导和经理，而是一种特征，这种特征有如下两个简单的表象： 帮人解问题。团队或身边中大多数人都在问：“这问题怎么办？”，而总是你能站出来告诉大家这事该怎么办？ 被人所依赖。团队或身边中大多数人在做比较关键的决定时，都会来找你咨询你的意见和想法。 一但你在在30岁之间出现了Leadership这样的特征，那么，你会进入一个正循环的阶段： 因为你学习能力强，所以，你会有更多的机会解决难题。 你有更多的机会解决难题，你就会学更多的东西，于是你就会更强。 上面这个循环，只要循环上几年，就会让你人生的各种可能性大大的增加。 【 注意 】 要达到这样的特质，需要找到自己的长处、以及适合自己的环境。就像鱼的特长是呆在水里，让鱼儿去追求陆上动物的刺激生活并不靠谱。 一般说来，有这样的潜质的人，在学校中就应该要出现。如果你在大学中还没有出现这样的潜质，那么，你在工作当中要加倍努力了（注：所谓的加倍努力，不是让你使蛮力加班，而是让你多学习成长，使蛮力拼命是弥补不了能力、思维、眼界上的缺陷的）。 Leadership也有范围的，比如，身边的朋友，工作中的团队/部分，圈内，整个行业。Leadership的范围越大，你的个人发展的选择性就越高。反之则越小。 如果已到了30岁左右，还是没有出现这样的特征。那么，可能未来你也很难有这样的Leadership了。而你的个人发展的可能性可能也就不多了（sigh…） 读到这里，我必需要说一下，如果你已开始显现出你的Leadership，那么你才谈得上个人发展，这篇文章后续的内容也可能才会对你有意义。 个人发展的三个方向 以我个人短浅的经历和视野，目前只看到的人的发展有如下三个大方向（他们之间可能会有重叠）： 1）在职场中打拼 2）去经历有意义有价值的事 3）追求一种自由的生活 这三个方向，我个人或多或少都体验过，我也见过身边的很多人走这三个方向走的比较成功。也许还有别的方向，没办法，现在，我的视野就这么大，所以，我在这里，我主要就是谈谈这三个方向。Again，人有资格去走这三个方向的前提是——已有了上面我说的Leadership那种特质！ 一、在职场中发展 在职场中发展应该是绝大多数人的选择。通过加入公司来达到人生的发展。 我们经常可以看到很多所谓的“职业规划”，但是大多数职业规划只不过人力资源搞出来的东西，和实际其实是有很大出入的。我的人生经历中，有18年左右是在公司中度过的，在过银行，小公司，大公司，民营公司，外国公司，传统IT公司，互联网公司，不同的公司完全有不同的玩法和文化，我的经历还算丰富，但也不算特别成功，这里只分享一些我在职场中的心得（不一定对，仅供参考）。 1、去顶尖公司 去顶尖公司的一个目的就是让你的Leadership的范围的可能性扩大。 因为公司和公司的差距也不小，所以，就算你在低端公司里是骨干份子，但在高端公司里可能只是一个普通员工（就像中国足球队的主力到了英超可能都无法入选）。所以，在职场中，如果你要让你的个人价值最大化的话，你一定要去顶尖的公司。因为顶尖公司里有非常不错的工作方法和场景，这并不是能看书或是交流得来的，这是必需要去亲身体验的。所以说，在顶尖公司掌握的技能，开阔的眼界，通常来说都会比低端公司的要多得多。 另外，每个公司的工作级别都是有相互对标的，比如：阿里的P几对应于百度的T几。国内的一线公司职位还相当，但是如果和国外一线公司的比，那就有差距了，而且差距还很大。比如，Google或Facebook的某个高级工程师，可能就对应于阿里的P8/P9甚至更高。 是的，对于职场来说，如果你在顶尖公司是骨干，那么，你去低端公司，则有很大机会会成为他们高管和核心。就好像你在Facebook里干三五年成为他们的技术骨干，那么你到BAT去成成为高管概率是非常大的。反过来，如果你毕业主去了BAT成为了一个螺丝钉，在天天加班中度过你的青春，你干个十年能成为BAT的高管的概率可能会非常的低。 2、去真正的创业公司 去顶尖公司和去创业公司在某些时候并不冲突。不过，这里我想讲的是，一个技术能力强的人在大公司可能会被埋没掉。因为大公司业务成功后， 成功的公司在招聘各种高级技术人才都不会成为问题，于是少你一个不少，多你一个不多。 成功的公司其整个技术体系已经完成，Legacy的问题也比较多，所以，可以供你发挥的余地不大。 成功的公司更多的可能会想要稳定的系统，稳定必然会产生保守，而保守则产生不思进取。 所以，对于中高级人才来说，在大公司里的能产生的个人价值，可能远远不如那些求贤若渴、没有包袱、可以尽情施展、相对更为灵活和自由的创业型公司。 不过，去创业公司需要小心仔细的挑选和评估，创业公司的不确定因素很多，也和创始人的因素太大了，所以，你需要小心了解创始人和他们的业务情况，想法和理念差不多才能更好的共事。 好多创业公司其实并不是真正的创业公司，他们创业有很大的侥幸和驱利心理，要小心甄别。因为那不是真正的创业公司。 3、职业生涯的发展阶段 首先，有一个不争事实——整个社会是会把最重要的工作交给30岁左右的这群人的。也就是说，30岁左右这群人是这个社会的做事的中坚力量。 所以，这是一个机遇！如果你有了Leadership，你就一定能在这个时间段内赶得上这个机遇——公司和领导对你寄于信任和厚望，并把重要的团队和工作交给你。 于是，你的30岁到40岁就成了一个职业生涯的发展期，也就是你的事业上升期。如果你到40岁都没有赶上，那么你的职业生涯也就这样了，老有所成的人是少数。 在你事业的上升期，你需要更多的软技能，比如： 带领产品和业务的发展的能力 推行自己喜欢的文化的能力 项目管理的能力——在任务重、时间紧中求全 沟通和说服别人的能力 解决冲突的能力 管理和发展团队的能力 解决突发事件的应急能力 …… …… 另外，你还要明白在职场里的几个冷酷的事实： 你开始要关心并处理复杂的人事。尤其在大公司，大量的人都是屁股决定脑袋，利益关系复杂，目标不一致，每个人心里都有不一样的想法。这个时候再也不是talk is cheap, show me the code！而是，code is cheap，talk is the matter。你需要花大量的时间去思考和观察形形色色的人。需要耗费大量的精力在不同的人之间周旋，而不是花时间去创造些什么有价值的东西。 你要开始学会使用各种政治手段。办公室政治不可避免，越大的公司越重，自从你开始成为一线的leader的那一天起，你就开始成为“里外不是人”的角色，需要在下属和领导，员工和公司之间周旋。随而你的级别越来越高，你需要使用更多的政治手段，你会学会审时度世的站队，学会迎合员工和领导，学会用官员的语言说话，学会此一时彼一时，学会妥协和交换，学会忍气吞声，学会在在适当的时机表现自己，学会波澜不惊，学会把自己隐藏起来，甚至你还会迷失自我，开始学会一些厚黑学，比如不得不在适当的时机在背后捅人刀子……你可能会成为一个你自己都讨厌的人 听上去真的好无聊，所以，你现在也明白为什么高层们都看上去很忙很累，而且抽不出时间来关心细节问题，因为，他们更多的是要协调整个组织和系统来运转，甚至还要四处周旋，各种博弈，没办法，这是职场的必需的东西！听起来是不是感觉人类很愚蠢？这真是没办法的事。如果你不想或是也没有能力玩这些东西，那么你需要去那些可以让技术人员安安心心做技术的公司。这类的公司，我见过Microsoft、Google、Amazon或是一些创业公司里都有。国内的大公司中也有让技术人员成长的职业成长线，但老实说，表面上看似是一个让人专心做技术的升职成长线，但其实还是管理岗位。 所以，技术人员在职场中的归宿有两条路 —— 到真正的技术公司成为一个专心做技术的人，或是在成为一个职业的经理人。 二、追求人生的经历 先说三个故事， 第一个，是在阿里的时候，有一天在内网里看到一个贴子，一个做产品的女孩说自己准备离职要去法国学烘培厨艺，引得大家热评。 第二个，是在亚马逊的美国老板，他每年都要去报个培训班学一个技能，比如：厨艺、开双翼飞机、夜总会里的DJ……、甚至去华盛顿去学当一个政客。 第三个，是在汤森路透工作时，一个英国的同事，有一天他说他离职了，和自己的老婆准备用余生去周游世界，我问他是不是有足够多的钱了？他和我说，钱不够，他俩口子的计划是，边旅游边打工，打工打够到下一站的钱就走。他还说，那种用假期去另一个城市的旅游太没意思了，如果你不在那个地方生活上一段时间 ，你怎么能算是好的旅游体验呢？好吧，无法反驳。 我是觉得他们把自己的人生过得如此有意思，令我很佩服。虽然跨界跨得有点猛，但是 Why Not？ 在这里，我想说，去追求一种和众人不一样的人生经历也是一件挺好的事，我个人感觉，比起在职场里有趣地多多了。如果你厌倦了职场，其实为什么不去追求一下不同的人生经历呢。就算你不想去追求跨度比较大的人生经历，那么，在技术圈里，也有很多有价值有意思的经历也可以去的。追求刺激有意义的与众不同的经历的人，其实也能算是一种人生的成功，不是吗？ 如果只说技术方面，我个人看到的去追求经历的人，有两种追求的人其实也很成功的： 到技术创新的发源地去经历创新。计算机互联网各种技术的创新引擎，基本上来说，就是在美国了。我们赶上了这个时代，也选对了这个时代最火热的行业，那么，有什么理由不去这个时代的技术发动机那里去经历呢？在美国硅谷湾区，无论是大公司，还是创业公司，都在迸发着各式各样的创新，如果有能力有机会，为什么不努力去经历一下呢？不经历一下，老了不会觉得错过了是一种后悔吗？ 去经历下一个热点技术的发展。从IT，到互联网、再到移动互联网、云计算、大数据，再到未来的AI，VR，IoT……，技术创新的浪潮一波接一波的过来，你是想在那继续搬砖搬下去，是想迎浪而上去经历浪潮，还是想成为一个随波逐流的人？ 打工也好，创业也好，在国内也好，在国外也好，这些都是形式，不是内容。内容则是你有没有和有想法的人去经历有意义有价值事？人生苦短，白驹过隙，我们技术人员最大的幸运就是生在这样一个刺激的时代，那么，你还有什么理由不去追逐这些前沿刺激的经历呢？ 三、追求自由的生活 我相信“自由”这个事，是所有人的心中都会想去追求的。“生命诚可贵，爱情价更高，…… ”（哈哈） 但一说起自由，绝大多数人都想到的是“财富自由”或是“财务自由”，其实，并不完全是这样的，在自由的通路上，我个人的经历告诉我，其实，你会有很多的不同类型的自由。下面，是我对几个层次的“自由”的理解。 第一层自由——工作自由。人的第一层自由的境界是——“工作自由”，我到不是说你在工作单位上可以很自由，虽然有特例，但并不普遍。我想说的“工作自由”是——你不会有失业危机感了。也就是说，你成了各个公司的抢手货，你不但不愁找不到工作，而且你是完全不愁找不到好工作。试想一下，如果是工作来找你，一方面，你就有真正意义上的工作选择权了，另一方面，你都不愁工作了，你完全就可以随时离职去干你想干的事了。此时，你就达到了“工作自由”。 第二层自由——技能自由。工作自由已是不错，不过前提是你还是需要依赖于别人提供的工作机会。而技能自由则是你可以用自己的技能养活自己，而不需要去公司里工作。也就是所谓的自由职业者了，社会上，这样的人也不少，比如，一些健身体育教练、设计师、翻译者、作者……这些都可以算是自由职业者，程序员这个职业中只要不是搬砖的，有想法的，就有可以成为自由积业者的潜质，想一想，你拥有的编程能力，其实是一种创造的能力，也就是创造力，只要你Make Something People Want（YC创业公司的slogan），你是完全可以通过自己的技能来养活自己的。如果你通过某些自动化的东西，或是你在App上做了一个软件个体户，让自己的收入不断，甚至你做了一个开源软件，社区每个月都给你捐款捐到比你打工挣的还多，那么你就真正的有了技能自由了。 第三层自由——物质自由。我把财务自由换了一种说法。我个人觉得，除了有个好爸爸之外这种特例的情况，如果你想有物质自由的话，本质上来说，你一定要学会投资，投资不一定是你的钱，时间也是一种财富，年轻更是，你怎么投资你的时间还有你的青春？你要把你的投资投到什么样的事，什么样的人？对于投资这个事，风险也比较大。但是，人生不敢冒险可能才是最大的冒险。这个世界有很多技术不是你能看书学来的，而要只能在实战中学会的，比如：游泳。投资可能也是一种。只有真正懂投资的人，或是运气非常好的人，才可能实现物质自由。 追求自由的生活，其实也是个人发展道路上的一个不错的选择。通常来说，自由的人，能力都不差，钱也不会少。因为，他们懂得投资。 也就是说，拥有追求自由能力的的人， 不但有领导力和创造力（也可指导大多数人并走在大多数人前面） 同时他还懂得怎么投资（知道时间和精力和金钱应该投在什么地方） （注：这里我没有提精神自由，老实说，精神上的自由我也不清楚是什么东西，因为我还没有见过，眼界有限，所以先按不表了，不然真成鸡汤文了） 总结 无论是在职场中打拼，还是追求精彩的经历，还是去实现自由，我觉得都是不错的个人发展的方向。 他们都有重叠，比如： 你可以在职场中去追求那些刺激的经历的公司。 同样也可以通过加入有潜力高速发展的公司来达到自由。 你也可以通过追寻不一样的经历来达到人生的自由。 …… 总之，这里的逻辑是—— 能够去规划自己的个人发展的人，通常都是有很多机会和可能性的人。 有很多机会和可能性的人，通常都是有Leadership，喜欢冒险的人。 有Leadership喜欢冒险的人，通常都是学习能力强，思维活跃，喜欢折腾，懂得“投资”的人。 学习能力强思维活跃的人，通常来说，都是喜欢看书，喜欢实践和新鲜事物，不怕艰难和挑战，用智力而不是使蛮力的人。 懂得“投资”的人，通常来说，他们更多的关注的是未来和长远的成长，而不是当下的KPI、奖金和晋升。 插图来自电影《飞屋环游记》 最后祝大家新年快乐，来年大展鸿图。 （全文完） （转载本站文章请注明作者和出处 酷 壳 – CoolShell ，请勿用于任何商业用途） 陈浩 2016年12月28日 So, that's it 人生匆匆，没有太多时间留给我用来缅怀一位陌生人，尽管他是一位可敬的陌生人 所以就到这里为止了 Rest in peace Knighthana 2023/05/16","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"career","slug":"career","permalink":"https://knighthana.github.io/tags/career/"}]},{"title":"(KM)ls的用法","slug":"(KM)ls的用法","date":"2023-05-15T10:36:00.000Z","updated":"2023-05-15T10:15:44.129Z","comments":true,"path":"KnowledgeMark/(KM)ls的用法.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)ls%E7%9A%84%E7%94%A8%E6%B3%95.html","excerpt":"","text":"ls的用法 按照时间顺序显示项目(新前旧后) 1ls -t 按照时间顺序显示项目(reverse新前旧后) 1ls -tr 按照时间顺序打印出文件详细信息列表，并确保在终端屏幕上自己看到最近修改的文件 1ls -ltr 使用ls --help可以获取说明 不过，这篇可以用来参考的文章也许更加简单一些： ls命令按时间排序 不过，其中说 -g无用 事实上，根据 1ls --help | grep \\-g 的执行结果，g参数的意思是 类似 -l，但不列出所有者 Knighthana","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"ls","slug":"ls","permalink":"https://knighthana.github.io/tags/ls/"}]},{"title":"(KM)git clone --depth=1","slug":"(KM)git clone --depth=1","date":"2023-05-14T14:36:00.000Z","updated":"2023-05-15T00:36:35.134Z","comments":true,"path":"KnowledgeMark/(KM)git clone --depth=1.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)git%20clone%20--depth=1.html","excerpt":"","text":"git clone --depth=1 对于陈年型活跃项目，使用git clone时可以加上--depth=1参数，避免克隆早期的项目历史记录造成网络和硬盘负担 1git clone --depth=1 参考： 介绍git clone --depth=1的用法 git clone --depth=1时的一些问题 Knighthana 2023/05/14","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"git","slug":"git","permalink":"https://knighthana.github.io/tags/git/"}]},{"title":"(KM)思考职业生涯问题的角度","slug":"(KM)思考职业生涯问题的角度","date":"2023-05-14T14:27:00.000Z","updated":"2023-05-15T00:36:35.134Z","comments":true,"path":"KnowledgeMark/(KM)思考职业生涯问题的角度.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)%E6%80%9D%E8%80%83%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%92%E5%BA%A6.html","excerpt":"","text":"思考职业生涯问题的角度 摘录自知乎问题 我爸对计算机行业的看法，是否准确？ 现在有很多人想当码农，他们都很努力，无论是刷题，还是加班，看上去内卷的很厉害。我看见他们这种状态，觉得自己也非学计算机不可，而且也必须很拼。我问了我爸的意见，我爸跟我说：“无论你从事什么行业，首先要对市场有概念。你选择了一个行业，首先要去想怎么切入市场。对于计算机行业而言，市场被大公司所占据，对于个人而言，切入市场的方式就是迎合这些公司的招聘要求，这相当于从被动的角度去解决问题。但是如果你有自己的爱好，对这个爱好能保持长期的热情，并且这个爱好也可以切入市场，这时候，你可以选择去迎合大公司，但是同样，你也可以从社会的供需关系来切入市场，从最底层来塑造一个模式，利用复利的原理来扩大这个模式。这个模式，很可能不是技术书、面试题所能衡量的，它可能并不是高科技，也不漂亮，但是你的目的是让它增长，然后再复制这个模式。如果你的兴趣就在这里，那你就仔细思考思考这个社会的经济形势和人与人之间的利益关系，想明白之后，塑造你的产品，为别人创造价值。慢慢你会发现，你自己有一个小圈子，在这个圈子里，你了解其中的一切，你明白游戏规则，这里的一切你做主。相反，如果你只知道学技术，刷题，即便你的技术再好，内心深处仍然会有被别人支配的恐惧感。而且，你时常会疑问，技术到底学多少，才能没有恐惧感？答案是，越学技术，很可能你会越质疑自己。因为你在一个无比复杂的圈子里，但是很难塑造自己的圈子，就是那个你自己做主的圈子” 市场经济决定了以“需求”为导向，而不是生产因素，例如“技术水平”为导向 无论做不做学术，这都是不得不考虑的问题 Knighthana 2023/05/14","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"career","slug":"career","permalink":"https://knighthana.github.io/tags/career/"},{"name":"be aware","slug":"be-aware","permalink":"https://knighthana.github.io/tags/be-aware/"}]},{"title":"The Ph.D. Grind Book Mark and Notes","slug":"(BM)ThePhdGrindBookMark&Notes","date":"2023-05-13T16:00:00.000Z","updated":"2023-05-14T15:50:00.000Z","comments":true,"path":"Book-Mark/(BM)ThePhdGrindBookMark&Notes.html","link":"","permalink":"https://knighthana.github.io/Book-Mark/(BM)ThePhdGrindBookMark&Notes.html","excerpt":"","text":"The Ph.D. Grind 读书笔记（初读） 我经常会花⼏个⼩时设置好 Klee 所需的复杂的实验环境，以分析某⼀个驱动程序的程序缺陷；但这种⼯作又往往以 Klee 因为其⾃⾝的程序缺陷⽽崩溃告终，让我的努⼒付诸东流。 随着时间的流逝，我对于⼿头的⼯作越来越感到沮丧，我觉得⾃⼰被分配的任务就是单纯的苦⼒，毫⽆知识含量——我的时间都⽤在让 Klee 能正常运⾏上了。 痛苦的代码细节工作，身为科学家，却觉得自己做的事情和苦工没什么区别 这种痛苦太容易设身处地的感受到了，想象一下就让人犯恶心 之所以要留在学校，就是不愿意做打螺丝的苦工，但如果留在学校里，不仅做着打螺丝的苦工，还拿的低得可怜的工资，头上还悬着着“毕业”这样的达摩克利斯之剑，该怎么办呢？ ⽽现在的学术研究在情绪上和⼼理上都是⽆休⽆⽌的。我晚上⼏乎没法让⼤脑停⽌思考问题，尽情放松休息——后来我发现⼏乎所有的博⼠研究⽣都有类似的困扰。 突然想到，做学术更会难以休息，这么想，突然变得有些难受起来 Klee 实际上只能在不超过⼤概 3000 ⾏，由 C 语⾔写成的代码中找到缺陷。最⼩的 Linux 驱动程序代码⼤概有 100⾏，所以 Klee 分析它们游刃有余。⽽稍微⼤⼀些的驱动程序就有⼤约 1000⾏代码，⽽这些代码还与⼤约⼀万⾏到两万⾏的 Linux 操作系统代码密不可分。这就导致问题⼀下远远超过 Klee 可以分析解决的范围，因为 Klee并不能把这 1000 ⾏代码和其他部分“斩断联系”⽽单独分析。 啊，极高的耦合度，依赖地狱，到处都是像触手一样乱戳的调用，根本没法把代码单独划出来进行封装吗？ 原来像Linux这样成熟的项目里也全是这样的问题吗？ 但是这⾥有个巨⼤的问题。等到我们得到那些不错的结果时，到论⽂截⽌⽇期已经只剩下三天了，⽽我们都完全没有着⼿开始写论⽂。在这么短的时间⾥，撰写、编辑、完善⼀篇⽂章，使得它能被顶级计算机科学学术会议录⽤是完全不可能的。但我们还是努⼒这么做了。在提交截⽌前的 72⼩时⾥，Dawson 和我们五个学⽣（其中⼀位现在已经退学了）两个通宵住在办公室，以期完成实验和论⽂。我们所有学⽣⼼⾥都知道这篇论⽂不可能被接收，但我们还是在 Dawson 的带领下，顺从地向⽬标前进。 这三天的时间必然是地狱般的三天，估计是“度日如年”了 最终，我们提交了⼀篇令⼈尴尬的⽂章，⾥⾯充满了错误拼写、不通顺的句⼦⽚段、没有解释的图表，甚⾄连结论段都没有。整个是⼀团乱麻。 赶工是这样的，赶出来的东西往往都不太好 我把⾃⼰完全与世隔绝，⼼理上基本处于崩溃状态，但我仍然试着每天能有所进步。我尝试着每天阅读⼏篇计算机科学的学术论⽂，并做好笔记，以帮助我激发⾃⼰的灵感。但因为没有良好的引导和研究背景，我最后浪费了很多时间，有时读完了论⽂却⼀⽆所获。我曾经骑着⾃⾏车在校园⾥漫⽆⽬的地游荡，试图在过程中思考⾃⼰的研究思路但常常⽆功⽽返。最终，我把时间都浪费在了拖延上，可能甚于我这辈⼦⾄今为⽌的任何⼀段时光：我看了很多电视节⽬，睡了很多觉，花了⽆数个钟头在⽹上蹉跎。 这不就是“停摆”吗？ 我对此深有体会 也许这段时间可以去看看《EVA》，虽然这没什么帮助 但话说回来，停摆状态下干啥事有帮助呢？ 不解决导致停摆的困扰因素，别的都是白扯，而且越拖越严重 找⼈抱怨也毫⽆意义 这种现实简直可悲到可笑的地步。但我觉得⼤家凑在⼀起互倒苦⽔也毫⽆裨益 孤独，真的孤独啊 一肚子苦水也没人可倒，闷在肚子里越闷越苦 光是能听懂倒的是什么苦水，就要很高的门槛了 即便是一个对学术、科研略有知情的本科生，也会觉得做学问做研究是一件光鲜亮丽的事情，如果有博士开始对着本科生倒苦水，本科生也理解不了 那更多的人就更理解不了了 连“你为什么倒苦水”都理解不了，还怎么倾听你倒苦水呢？大家又不是人均心理医生 至于听得懂的人，本来也就没那么熟悉 真的熟的人，也觉得这样倒，把别人的苦水也勾出来了就真是不大好了，毕竟做朋友的总给别人带来坏心情，算是怎么一回事呢 和想象中⼀位孤独的学者坐在路边，⼀边喝着拿铁咖啡⼀边在⼀张笔记纸上涂涂画画这种浪漫化的场景不同的是，真正的学术研究从来就不是在“真空”中完成的。为了创新，⼀个⼈需要有坚实的知识、历史、甚⾄物质基础（⽐如实验室设备）。 就像别的学校的学生曾经对我说“很羡慕做物理实验的人，感觉他们在搞一些很有学问的东西”一样 我似乎对读硕士研究生、博士研究生有着不切实际的期待 也许真相往往是一地鸡毛 就像后来我无数次抱怨抄物理实验预习报告浪费了我很多时间，而且这些实验于我的专业学科毫无用处一样 也许真正的科研都是这样的焦油坑也说不定 在那⼏周中，我应该追寻的更明智的路线是找更多机会和Dawson 谈话，并积极寻求和其他教授以及⾼年级学⽣的合作。 这种经验也是非常宝贵的 但是既然Dawson的热情，和经费都绑定在Klee上，我仍然怀疑Dawson能不能给出设身处地的建议呢？并不是从人品方面，我是说，人家也未必能想到你这个情况该做什么吧。当然这只是揣测 不过从另一个方向来思考，既然也没有更好的办法了，那还不如找导师谈谈呢 最坏的情况，导师表示“我不管你在想什么，无论你遇到什么实际困难，我不管你也不会给你建议，而且你必须做我的项目”，那最坏不过退学算了 教授就得从他们的经费中拿出⼤约 1500 美元，来承担学⽣参加研讨会并作报告产⽣的车旅费、住宿费和注册费。 “注册费”？ 虽然说不出所料吧 但怎么干啥都要交钱啊？？？ 我学着扮演⼀个⼀半推销员⼀半乞求者的⾓⾊，坚持不懈地询问同学是否有 Python 程序可以拿来给我⽤作案例研究，或者更好的是，是否愿意安装并使⽤ IncPy，以此作为⽇常⼯作的基础，并向我提供他们的使⽤感受。 本社恐看到这里痛苦面具已经戴上了 在我那个⼀⼩时报告的过程中，我被三个研究员稍稍吓了⼀跳，他们⽼是打断我，反复纠缠⼀些 IncPy 在实际中表现如何的细节问题。 如果有人反复地问细节问题，也许正是对这个被推销的东西感兴趣，所以我觉得，也许大可以从他们那里收集他们实际感兴趣的地方——会上或者会下 总之，那肯定不是挑刺，毕竟对不感兴趣的会议议题，“睡一觉”会更舒服一些 在我尝试给伯克利这些神经科学家的电脑上安装 IncPy 之前，我已经搭建和测试了⼏个⽉，所以我很⾃信也能给他们安装成功。然⽽，安装之后没⼀会⼉，我们就发现 IncPy 与这些科学家天天都在使⽤的很多第三⽅Python 插件（称为拓展模块）并不相容。我⾃⼰测试的时候，只测试了⼀些基本⽤例，⽽没有考虑到这些扩展模块。这给了我⼀个关于现实部署的深刻教训：失败可能以你没有料到的形式出现，⽽⼀旦给⽤户留下⼀个不好的第⼀印象，就全完了！ 我对“第一印象”深有体会，至今为止，我都对KDE和Jekyll有非常糟糕的第一印象，尽管我知道这是一种初期技术力不足导致的个人偏见；即便我也不会真的去尝试因为这些偏见做什么，但我还是会下意识地避免使用这两个项目 如果一个冒冒失失的博士研究生的“垃圾项目”在我的研究环境中“连基础都跑不通”，真的只会留下糟糕的第一印象，因为会对这样的程序抱有不切实际的期待，无暇顾及这根本只是一个试验性项目，而且仅仅只有一个人编写和维护 但是，开发者面对这样的困境，应该怎么办呢？ 但我并没有放弃。我花了接下来⼏个星期的时间重新设计和实现了IncPy 中⼀个关键部分的代码，使它能够与任何 Python 拓展模块⼀起完美⼯作。 无法想象这种工作该有多复杂，让它适配所有可能的外部插件吗？那些插件各有各的不同，这到底是怎么做到的？ “插件”到底说的是什么东西？import的包吗？ 这是本来就可以实现的功能，只是在这次改进之后把原型项目改成了标准的形式，还是说……我还是没搞明白，这几个星期到底做了什么，得以让这个解释器去适配截然不同领域的Python插件？ 我又给伯克利那⼏位神经科学家发了封邮件，希望他们再给我⼀次机会，但我没有得到任何回复。 毕竟大家都是很忙的，时间是很有限的 没人会当面问，但是一定会在心里问的问题是，“用你的项目，如果不成功，那么浪费掉的时间算谁的” 我仍然还没拥有⼀条通往毕业的康庄⼤道，但我⾄少能开始⾃我管理⾃⼰的研究内容，⽽不是跟着别⼈⼀起做他们的研究项⽬了。 唉，但是这样的话，难道心里一点都不发愁“毕业\"的事情吗，感觉挺悬…… 我感到了⼀种紧迫感，因为我的外源奖学⾦只持续到这⼀年结束。 挺幸运，还有机会感受到紧迫感 想象有多少人申请不到奖学金，就只能且不得不去做导师布置的那种“破项目”？而不是真的有精力去找适合自己且有内源驱动力的项目？ 复刻这样经历的，又能有几个人呢？ 最值得注意的是，我介绍 IncPy 时采⽤了⼀种不太明智地包装策略，这使得我的论⽂被安排给⼀些来⾃对我的研究理念不太“友好”的⼦领域的学者来审阅。 有人因为这样的机制可以“作弊”让自己的论文更容易被接收而受益，就有人为这样的机制要付出代价 我看不起SEO技术，平常称之为“SEO作弊”，但是，这投论文又何尝不是一种SEO呢？ 不过他还有⼀个更为具体的建议：另⼀个能到达博⼠论⽂⽔准的项⽬，就是能够把我对 Python 的兴趣以及他所喜爱的类似 Klee 的想法结合起来，从⽽做出⼀个能够⾃动查找Python 程序中漏洞的⼯具。 我有理由相信，Klee是Dawson的青春岁月 只要把我的原始想法稍加改进，CDE 就能帮⽤户打包他们的程序，从⽽让其他⽤户能够成功运⾏，⽽不再⽤担⼼环境不⼀致的问题。我感到⼗分激动，因为 CDE 有可能缓解 Linux ⾥存在了⼗余年的依赖地狱问题。 该不会是Docker吧，不会是Docker吧，不会是Docker吧？？？ 叫系统调用重定向的技术 虚拟机？ 他还给我提供了⼀个实习⽣职位，我可以在即将来临的这个暑假来⾕歌开展有关 CDE 的⼯作。 这就是美国的博士生吗？几乎每学期都有机会实习…… 我和Dawson 聊了聊我这⼀左右为难的感受，他很⽀持我去实习，于是我接受了这个实习邀请。 不错啊……这么一看倒也挺顺利的 我只是研究细节并继续改善 CDE。在暑期实习结束、我博⼠第六年开始时，我最终停⽌了在CDE 上的全职⼯作。 忽然就在想，那个“Torch”没人继续维护，是不是也是这种原因啊（无端妄测 他就发表了 19 篇基本全都是顶级会议的论⽂，这是⼀个普通博⼠⽣发表数的五到⼗倍。这也是获得⼀个像斯坦福这样⼀流⼤学的教职所需要的硬性条件。 QAQ？ 我需要再有⼀个灵感的爆发，⽽这个灵感最后来源于⼀个意想不到的地⽅。 既不是斯坦福，也不是MIT，也不是谷歌或者微软吗？ 什么程度上的“意想不到”？ 我猜是之前的成果的用户那边给出的灵感，所以说是NASA或者某个其他领域实验室，比如说生物、神经学一类的领域来的灵感吗？ 暂且蒙在鼓里 ⼏年来我⼀直在思考离开学术界，⽽现在我觉得我有了合理的原因来这样做：我领教了计算机科学中的“学术游戏”是怎么玩的，也知道我并不想再继续玩下去了。 很沉重，很现实，没有人的工作是容易的。 对这些资历较浅的研究者来说，会议上的职业交际也是⼀个需要认真对待的全职⼯作，因为他们初期的职业⽣涯和学术声誉都依赖于在这⽅⾯的良好表现。 唔，完全没想到呢 我和 Dawson 聊了下，他很⼤度地愿意出经费⽀持我这⼏个⽉，即使我没有在 Klee 上开展⼯作（我的外源奖学⾦那时已经到期了）。 考虑到每个人都不容易，这真的很大度 如果我没有积极地抓住幸运地降临在我⾝上的这些机会的话，研究⽣最后的这段征途也不会变成可能。…… 那么我现在还在斯坦福，挣扎着四处寻找最后⼀个项⽬和论⽂委员会的成员。 原来是哈佛吗？ 这时，我已经懂得了保持与⽼资历的合作者（以及论⽂审稿⼈）的主观偏好相⼀致的重要性，即使我是在⼀个所谓客观的技术领域内做科研。 是说“只要想，什么学术课题都能打出交叉来”的意思吗？ 虽然我的外表和动作都像⼀个准⼈类（即，不修边幅、⾐冠不整），我的内⼼状态却是欣喜若狂的。我每天都要编程和调试⼗余个⼩时，但我的脑⼦还是很放松的，因为我的技术技艺应付所⾯对的挑战已经是游刃有余了。 看着就感觉好爽啊！！！！！ 经历了研究⽣早期在不确定并且失败的项⽬上数年的研磨之后，我现在感到精⼒充沛，并朝⼀个我知道能够实现的⽬标紧张地⼯作着。 without any of self-suspicious！！！ 在⼀个学⽣坐下来“写”毕业论⽂之前，所有的挥洒汗⽔的⾟苦劳动其实都已经做完了。 啊？写论文之前工作肯定已经做完了啊，这不是常识吗？ 尽管没有得到主流的认可，我还是觉得我的博⼠⽣涯画上了圆满的句号，因为我成功地让我的创意结出了果实，并且以⼀个我⼗分引以为豪的博⼠论⽂成功毕业。 至少在本科生看来，这太强大了 如果没有在斯坦福六年中前五年的外源奖学⾦⽀持，我不会有如此多的⾃由。 自由永远不是免费的…… 最终，我的博⼠论⽂也像⼤多数博⼠论⽂那样，将⼈类知识的边界向外拓宽了⾮常⾮常⼩的⼀点。 想要推动边界是很艰辛的啊……多少人在里面打转连边界在哪都看不到 如果有任何⼈想投⼊到这个荣耀的战役中去，我很愿意帮助他，但我却不够勇敢把我⾃⼰的⽣涯放到这上⾯去。相反，我现在计划去追求⼀个完全不同的职业热情，可能某⼀天它会成为我另⼀本书的主题 总觉得做学术研究会更自由，但现在看来并不是这样的…… 但不可否认，学术研究的环境肯定是最优的，不是说“理论上最优”，而是说“最”的那个含义，就是说，找不到更好的了 这就更加困苦了 让我吃惊的是这个笔记是我六年前写的，也就是 2006 年夏天我即将要开始我在斯坦福的博⼠⽣项⽬的时候。 我现在看自己几年前写的东西，有时候也是会感觉到陌生的……就是那种，仰望的那种陌生 这个常见问题⾮常重要，因为⼤多数博⼠⽣都不能获得⼀份像他们⼤学⾥的指导者以及⾏为榜样——终⾝制教授——⼀样的⼯作。 教职并不容易拿到，尤其是，想要在自己就读的学校拿到教职，基本是不可能的，并不是说，读了博，就能拿到稳定的教职 虽然知道这是理论上的事实，还是真令人沮丧…… 面前的山高耸入云不知道山顶在哪，现在说，爬到了山顶也不太可能拿到想要的东西 “这么折磨自己不是有病吗”，很难不冒出这样的念头 ⽐如，我六年的博⼠训练让我⽐起还是⼀个研究⽣新⽣时，变得更加智慧、有悟性、坚韧、刚毅、专注、有创造⼒、有⼜才、感觉敏锐，并且专业地⾼效。（两个明显的警⽰：不是每⼀个博⼠⽣都能如此受益——很多⼈也因挣扎⽽变得厌倦、疲惫不堪。当然，也有很多⼈在没有读博⼠的情况下，同样培养出了这些积极的品质。） 我觉得，即便写了这两条警示，这也不是令人满意的答案 从某种意义上来说，读博⼠就是智⼒上的⾼强度体育训练。 通篇看下来，训练的磨难是有了 相反，我知道⼀些有着最理想主义⽬的的学⽣——梦想着并热切地希望彻底变⾰他们的领域——但他们没做出什么结果，最终他们的幻想也破灭了。 不做“圣人” 获得博⼠学位的唯⼀途径就是成功地产⽣科研输出（例如，发表的论⽂），⽽不仅仅是靠上课或者读他⼈的论⽂这些吸收来输⼊。 虽然都是学生身份，但是做研究和单纯的学习是很不一样的 想想无论如何，随着本科即将画上句号，轻松的“学习”生涯就要结束了，接下来，即便能继续做学生，恐怕也不会再这样轻松地只要好好吸收了前人的成果就能得到认可，这多少令人有些难过 相反，对毕业论⽂项⽬的相关⼯作⽂献的搜索则有效得多了，因为我的阅读是紧紧朝着⼀个清晰的⽬标的：找出竞争者，以及可以修改加到我⾃⼰的项⽬中的好创意。 但是得先找到一个项目不是么 要不然，即便有了个想法，打开知网，输入关键词，看着满屏的结果也并不知道该从哪开始，拿着别人的论文，一看不出好坏，二不知道从哪开始 与传统的课堂学习不同，当我做科研的时候，我并没有教材，没有课堂笔记，没有授课教师提供给我的标准答案。 而且找到的“答案”也可能是错的 做研究和做学习真的不一样 但如果我没有持续尝试，那么我可能也不会这么幸运。 幸运如果可以预测的话，就不叫“幸运”了 但行好事莫问前程，即便从最功利的角度来理解，也是因为前程根本没法预知，也无法量化自己做的努力的大小——量化一个计算机程序尚且如此困难，难道还真能量化自己的努力不成 唯一有帮助的，也许就是自己脑子里学到的经验带来的“判断力”了——诶嘿，还不知道是不是对的，真—是—刺—☆—激—呢（棒读） 作为⼀个博⼠⽣，我处于社会等级的底层，没有能⼒去改变这个“学术游戏”。具体⽽⾔，尽管我惧怕我的论⽂⼀次又⼀次地被拒，我也没有其他办法，只能继续学着怎么尽⾃⼰所能去玩发表论⽂的游戏。 不可改变的事情有很多，无奈地发现改变自己的方式是最简单的道路 当我通过阅读 Margo 的论⽂和资⾦申请书，知道了她的研究品味之后， 啥叫“研究品味”啊，感兴趣的那种方向，致力于解决的社会问题那种的？ 因此对教授既是专家也是⼈类这⼀点⼼领神会很重要。 只可意会不可言传的话题了属于是 再写下去确实会得罪人 总的来说，我努⼒地找出天性就和我相处融洽的那些⼈，然后再花时间来培养这份关系。 确实，如果有机会选择，一定要找那些能处得来的人 而且不见得就一定要是志趣相投，也许志趣不相投，但只要一些相处原则一致也是可以的 与之相反，志趣相投的人，在一些相处原则上不见得一致，也就不见得相处得来 作为⼀个资历较浅的实验室成员，尽⼀些义务、做⼀个“好⼠兵”是很有必要的，⽽不是从第⼀天就开始提⼀些蛮横的要求。 权力持有者向权力的来源表示服从，经费申请者向经费的来源服从，不可避免 学⽣们必须⾃我判断他们被默认安排的项⽬是否有前景， 有人受得起摔倒在坑里的代价，如果自己受不起，就早早跑路 问题不在于如何下决心 问题在于有没有能力看出来这是“不合适”的，而不是抱着“我再努努力就可以了”的幻想催眠自己，如果有那样的坚决意志果敢地认识到这个事实，必然能够对需要做出的决定不抱疑惑 接下来的困难应该是“去哪找一个能让我毕业的项目”，因为这个是自己能做主的事情 而不是“我该如何向教授提出我的要求”，因为就这件事情本身而言，自己做不了主，如果之前当了一段时间的好士兵，固然能提高可行性，如果有自己的经费来源，那么事情更容易成功，但这些都已经不是这一阶段可以考虑的问题了 从失败中站起来 说起来容易，也是老生常谈的话题，但是从失败中站起来真的不太容易，失败对于人心境的打击、扰乱是很严重的 站起来之后也很难不盲目，病急乱投医，是常理，是人情 当我与专业的圈内⼈合作时，我发表论⽂变得更为容易了 但是显而易见地，想认识人家可真的不太容易啊 毕竟大家都很忙啊 在整个博⼠阶段中，我做了⼆⼗余个科研报告，从在⼤学实验室组会上的⾮正式报告，到⼤型酒店舞会厅的会议报告。 不说别的，勤作报告不就没那么怯场了 但我觉得，怯不怯场还是和自己做的东西有关，熟练了，投入到自己的东西里面了，自然就不怯场了 我刚开始做毕业设计答辩的时候，就很害怕，但是随着我开始往下讲，套到自己的思路里面之后，就一点都不害怕了，还只恨时间太短，我的想法说不完 但我意识到令⼈信服地将⾃⼰的⼯作推销出去才是发表、获得任何、顺利毕业的关键。 首先需要时刻相信之前和朋友们探讨问题时总结出的一个结论 “人类文明是一个草台班子” 这句话永远正确 人对社会的影响太严重了，而且并没有那么多理性，更多的是直觉和感性 有时候想想真不可思议，这么不靠谱的两样东西，是怎么撑起这个社会来的？ 博⼠⽣经历中我最喜欢的⼀个特征就是我并没有⼀直处于和同学们的竞争中 这种环境一定得设法避免，毕竟本来做的研究，整个领域只有自己一个人就已经够孤独的了，要是身边的人全都是竞争对手，那还不如别读了 因此，我们中的⼤多数都慷慨地互相帮助，尤其是在遭受外部审稿⼈严厉的批评之前，就互相给予关于想法和论⽂草稿的反馈。 靠谱的朋友圈太重要了 “到底是朋友们成就了一个人，还是一个人成就了他的朋友们？” 无论是哪个，找到好的朋友是很重要的 另外，这一小节的标题“慷慨地提供帮助”，我觉得也是上面那节“幸运”所说的，但行好事，莫问前程——谁知道前程在哪 在过去的六年⾥，我变得善于决定何时、找谁、以及如何来寻求帮助。 很有用的技能……但看起来太复杂，很难掌握 这些年来，我学会了向给予过我帮助的⼈表达感谢。 这个倒是很重要，注重正向反馈，不能因为太忙或者觉得“没啥用处”就不做 正如我第⼀年结束时发现的那样，凭空想出⼀个实质性的想法⼏乎是不可能的。 想法不是天上掉下来的 在做学习的时候很容易产生这种不切实际的念头：“我可以拍脑袋想出一个研究方向” 这种想法不切实际，需要避免 聪明地研磨需要有感知⼒、直觉和⼀种乐于寻求帮助的意愿 必须在有益的方向“折磨自己” 事实上，如果这个方向足够好，足够把自己放进去契合起来，只是会感觉有点累——并且主要来自身体而不是精神——而已，并不会“折磨”，我对此深有体会 并且⾮常⾼兴我最终还是决定去做⼀个⼤学教授！ 所以教职还是未来啊（doge 可它就是我获得博⼠学位必须要玩的游戏。 我基于我六年博⼠⽣阶段所看到的，把我认为这些过程是如何进⾏的最诚实的解释写了出来。 由于你所处的环境可能和我的有很⼤不同，我觉得我没有资格给你提供建议。欢迎你以任何合理的⽅式来理解我的话，然后⽤你最好的判断⼒来决定。祝你好运！ 每个人都有每个人的游戏要玩 即便因为阅读这本书产生了多大的共鸣 面对每个人不同的实际情况，陌生人们之间除了一句“祝你好运”以外也实在没什么能说的话了 尽管同⾏评议的发表规则是⼀个不甚完美的游戏，我也没有⼀个能够控制质量的更好的解决⽅案。 反正关于学习和学术，“面向考试”、“同行评议”各有各让人憎恨的地方 但是确实想不到什么更好的办法 有时候想到了一些观点，但是也没能力推动它，更没法验证它是不是合理，那怎么办呢？ 反正目前我也不可能想出什么来 只能说，在积攒到足以做出评论的实力（提出真正可行的想法，或者有那个能力对它动手）之前，还是先保持沉默比较好，毕竟只是个nobody 因为这些是都和获得博⼠学位⽆关的活动。我选择排他性地把我的回忆录聚焦在做科研的过程上，因为这才是博⼠经历的核⼼。 看起来读个博要做的破事还是有不少，好麻烦啊…… 阅后感： 这本书挺短的，读完只花了半个晚上 待办清单上的事情划掉一个，这个周末也算是做了点事 鉴于时间已经不早了，不发表其他感想了，要说的都在笔记里面了 感谢两位译者 齐鹏 (pengqi@cs.stanford.edu) 罗宇男 (luoyunan@gmail.com) 带来这本书的中文版本，如果让我研读英文原版的话，半晚上肯定读不完 当然，不可能不感谢作者 Philip J. Guo (philip@pgbovine.net) 带来这本书 这是作者本人Philip J. Guo提供的英文原著链接，也是合法的电子版获取渠道 上面这些东西就是初读的体会了，就这样。 Knighthana 2023/05/15","categories":[{"name":"Book Mark","slug":"Book-Mark","permalink":"https://knighthana.github.io/categories/Book-Mark/"}],"tags":[{"name":"career","slug":"career","permalink":"https://knighthana.github.io/tags/career/"}]},{"title":"2023年5月在Arch上折腾KVM的记录","slug":"2023年5月在Arch上折腾KVM的记录","date":"2023-05-11T13:16:00.000Z","updated":"2023-05-14T14:00:00.000Z","comments":true,"path":"Dev-Env/2023年5月在Arch上折腾KVM的记录.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/2023%E5%B9%B45%E6%9C%88%E5%9C%A8Arch%E4%B8%8A%E6%8A%98%E8%85%BEKVM%E7%9A%84%E8%AE%B0%E5%BD%95.html","excerpt":"","text":"2023年5月在Arch上折腾KVM的记录 突(tū)发(rán)奇(fàn)想(bìng)打算折腾一下KVM 决定一作死到底(bushi)，直接用ArchLinux来安装KVM(为什么不用Manjaro？好问题) 那么还得复习一下ArchLinux的安装流程，边做边查 因为是做实验，所以就在VirtualBox上进行了 首先用浏览器打开Arch Wiki关于KVM的介绍，放在旁边备用 第一步核验本机的虚拟化技术支持情况 KVM需要芯片带有虚拟化技术支持，因此必须先验证机器支不支持虚拟化技术 使用命令 1LC_ALL=C lscpu | grep Virtualization 核验本机的虚拟化技术支持情况 If nothing is displayed after running either command, then your processor does not support hardware virtualization, and you will not be able to use KVM. CPU_Virtual 如果出现如图所示的情况，那么就是支持虚拟化技术 核验内核是否支持KVM模块 检查必要的模块是否可用 1zgrep CONFIG_KVM /proc/config.gz The module is available only if it is set to either y or m. 基本上需要确认kvm、kvm_amd、kvm_intel三个选项都是y或者m Kernel_Module_Support 检查这些模块是否自动加载 1lsmod | grep kvm 这一步什么都没有显示，我突然意识到，操作系统还没有安装，那没法查啊 所以先进入操作系统安装流程 安装ArchLinux 若干年前安装Arch的时候还要照着贴吧的教程一步一步来 今非昔比，我们直接用原始材料 ArchLinux Installation Guide ArchLinux安装指南 如果发生了任何错误，都可以通过重新加载archiso，进入arch-chroot解决，所以不必慌乱 前略 获取安装映像 验证签名 准备安装介质 启动到 Live 环境 控制台键盘布局 几个步骤因为各自不同的原因略去 验证引导模式 检查网络连接 更新系统时间 要验证引导模式，请用下列命令行出 efivars 目录： 1ls /sys/firmware/efi/efivars 如果命令结果显示了目录且没有报告错误，则系统以 UEFI 模式引导。 如果目录不存在，则系统可能以 BIOS 模式 (或 CSM 模式) 引导。如果系统未以您想要的模式引导启动，请参考您的主板说明书。 要在 Live 环境中配置网络连接，请跟随以下步骤： 使用 1ip link 检查系统是否启用了网络接口 对于VirtualBox虚拟机来说，是不用操心这些事情的，至于其他情况如下 以太网——连接网线 Wirless-LAN——使用iwctl验证并连接无线网络 移动宽带调制解调器——使用mmcli连接到移动网络 获取IP地址： 对于局域网中带有DHCP服务器的情况，不需要操心这个问题 手动配置IP的情况参考IP地址 用 ping 检查网络连接： 1ping archlinuxcn.org 使用 1timedatectl status 确保系统时间是准确的，例如ssl协议等需要准确的时间才能使用 格式化硬盘 在 创建硬盘分区 提到使用 1fdisk 我不太确认fdisk是否支持GPT分区 虽然据称 fdisk (link to manual); note: fdisk from linux-utils 2.30.2 partially understands GPT now Should I use fdisk for partitioning or GPT aware tools? 但我还是不太愿意冒这个风险， 另外，工具parted parted也提供了GPT的分区功能 但感觉这个工具的包装做的不是很好，泄露的东西太多 比较符合传统操作习惯的是gdisk 和fdisk类似，它也有一个友好界面版本cgdisk 于是，我使用 1cgdisk 作为本次的磁盘分区工具 the secondary header's self-pointer indicates that it doesn't reside at the end of the disk 这个虚拟磁盘经过扩容，但其中的GPT分区表没能认知到这个变化过程 于是gdisk中使用v，或者直接运行cgdisk，就会提示 the secondary header's self-pointer indicates that it doesn't reside at the end of the disk rebuilding GPT on cloned disk 从bash中运行gdisk打开磁盘分区工具 然后输入x回车，进入专家模式 (疑惑：在主界面杵那么多东西，你跟我说主界面不是“专家模式”？) 然后输入e回车执行重映射， 再输入v回车检查 一般来说到这一步问题就解决了，最后记得w回车向硬盘写入更改 there is a gap between the main partition table (ending sector 33)and the first usable sector 然而我遇到了问题，那就是使用v检查之后，提示 There is a gap between the main partition table (ending sector 33)and the first usable sector 根据提示，在专家模式输入j回车， 再次回车，输入默认设置， 这时候再次使用v回车检查硬盘情况，会发现一切良好 于是w回车，将更改写入磁盘，并进入下一步 开始分区 在处理完硬盘的一些glitch之后，准备开始分区工作 我的虚拟机只有一块SATA硬盘，因此使用 1cgdisk /dev/sda 进入友好的GPT硬盘分区界面 左右方向键选择下方的功能 上下方向键选择分区 用上下方向键选中free space （对于一个空硬盘，可以略过此步，因为默认所有空间都是free space） 用左右方向键选择下面的[ New ]创建新的分区，起始位置按照默认，直接回车， 第二步会询问 Size in sectors or {KMGTP} 这个“KMGTP”的意思其实就是传统的单位 由于EFI特有的对启动分区的格式要求，我们得留一个FAT32分区给它用作ESP(EFI system partition) 注意，手册中有提示 如果要启动的磁盘已经有一个EFI系统分区，不要新建 EFI 分区，请使用现有的分区。 但这是虚拟机，当然没有，所以得自己新建 那么这一步输入 1512Mi 回车确认 之后会询问分区的类型 查询Partition type 可知，应该输入ef00回车，将其设置为EFI分区 如此这般，分出一个512MiB的分区留给EFI 然后在下方的free space里面再[ New ]一个分区，起始位置默认，大小默认（会使用所有剩余的空间），类型默认（默认是8300，也可以手动指定为8304，这样的话只能用来挂载根目录） 因为这是虚拟机，我没有留SWAP分区，如果需要的话，可以建立一个需要大小的，类型为8200的分区 这样的话硬盘里的分区们就做好了 不放心的话，可以用[ Verify ]检查一下，应该会提示 No problems found. 如果之前有些步骤做错了，可以通过[ Delete ]删掉分区重做 如果只是类型设置错误，可以通过[ Type ]修改 那就可以了，使用[ Write ]向硬盘写入更改 这一步是危险操作，会有所提示，不过既然之前检查之后没什么问题，那就继续 比如我执行到这一步的时候看起来是这样的 CGDISK 请注意，分区表上、下方留出空白的未使用空间是正常现象，不要想着全榨干净 右侧的Partition Name列中的字符串只是标识符，可以自己在下方用[ naMe ]定义，留空也没有影响，我为了辨识方便做了一些标记 最后使用[ Quit ]退出cgdisk 那么硬盘上往分区表里面要写入的内容完毕了，下来是建立文件系统。 建立文件系统 经过上面的步骤之后，硬盘内应当会有一些分区 使用 1ls /dev/ 检查目前的情况，不出意外的话，硬盘相关的应该是sda sda1 sda2三个条目，其中sda1是sda上的首个主分区，之后会把ESP放到这个分区里 sda2是sda上的第二个分区，之后会将主要的文件系统放在这里 但它们现在还不能使用，得往里面建立文件系统 1mkfs.fat -F 32 /dev/sda1 稍候片刻，一个为ESP而建立的FAT32文件系统就建立在sda1中了 然后 1mkfs.ext4 /dev/sda2 稍候片刻，一个ext4文件系统就建立在硬盘分区sda2中了 挂载 挂载这一步比较迷惑，因为在广泛使用UEFI的今天，并不清楚应该把ESP挂在哪里 是/boot或/EFI/或/boot/EFI还是别的什么玩意 查了一圈，各有各的说法 我决定遵循这个回答What is the difference between /boot and /boot/efi, do I need both partitions? Although this is old, there are some incorrect points here. Most distros mount EFI System Partition (esp) on /boot/efi . This means the efi folder in /boot is a partition. /boot is just a folder in your root / partition. /boot/efi is FAT32 filesystem (as neccessary for esp ) and /boot is probably ext4 in this case. Arch linux doesn't care if esp is /boot or /boot/efi But that isn't the case for other distros ( mainly debian and its deivatives). If your using only arch, there's nothing wrong with esp in /boot If you are mult-booting or has debian based ones then use /boot/efi as esp 那么，在ext4中建立/boot，然后把FAT32挂载到/boot/efi中看起来是一个比较稳妥的方案 1mount /dev/sda2 /mnt 1234cd /mntmkdir bootcd bootmkdir EFI 1mount /dev/sda1 /mnt/boot/EFI 这样的话应该就挂载完毕了 对于需要swap分区的情况，请参考挂载分区 为ArchLinux设置镜像源 并 安装必需的软件包 1vim /etc/pacman.d/mirrorlist 然后遵照自己使用的镜像源的说明添加对应的URL项目 注意，务必添加在其他Server项目的前面，这样优先级更高 之后 1pacman -Syy 可以更新一下缓存，虽然由于我们正在使用archiso做不做都行，但还是做一下，检查一下自己的镜像设置有没有写错什么的 pacman -Syy 带宽跑满，看来没写错，进入下一步 执行 1pacstrap -K /mnt base linux linux-firmware 安装base软件包、Linux内核、固件 这个K参数的意思是 Initialize an empty pacman keyring in the target (implies -G). 由于是虚拟机，所以“可以不执行固件安装”，但管他呢，全打进去，以及vim什么的趁手的软件都带上，最后回车！ 一共121个软件包，设置好软件源非常重要 fstab 使用 1genfstab -U /mnt &gt;&gt; /mnt/etc/fstab 为在/mnt中的操作系统生成需要的fstab信息 注意使用&gt;&gt;，因为NEWOSROOT/etc/fstab（比如现在是/mnt/etc/fstab）是一个已经存在的文件，我们需要的是在它的后面增补信息，而不是全抹掉写新的 使用 1vim /mnt/etc/fstab 查看生成的fstab文件是否有问题 我们记得硬盘上设置了两个分区，每个分区挂载在不同的目录中，因此这个文件中应该有两个条目，一条是/dev/sda1，另一条是/dev/sda2 fstab 这样应该就算是写入正确了 注意，这是最后一步在archiso操作系统中的操作，接下来会转移到新的操作系统中，所以还有什么要做的都得赶紧咯 换目录 1arch-chroot /mnt 于是我们进入了新的操作系统 之前几步忘了给新的操作系统安装zsh，于是暂时没有zsh用了，淦！ 时区 中国是亚洲上海时区，因此这一步输入 1ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 勤用TAB自动补全，也避免输错。 然后 1hwclock --systohc 生成/etc/adjtime 设置完时区之后，应该可以顺便安装点程序，我在这一步之后安装了vim 本地化 编辑/etc/locale.gen文件，取消掉需要使用的本地化前面的注释，其中en_US.UTF-8 UTF-8是必须去掉注释的 那么我就照做，把en_US.UTF-8 UTF-8前的注释去掉 再去掉zh_CN.UTF-8 UTF-8前的注释，顺便去掉了ru_RU.UTF-8 UTF-8 ja_JP.UTF-8 UTF-8前的注释 按照推荐， 也可以设置为 en_GB.UTF-8 或 en_SG.UTF-8，附带以下优点： 进入桌面环境后以 24 小时制显示时间； LibreOffice 等办公软件的纸张尺寸会默认为 A4 而非 Letter(US)； 可尽量避免不必要且可能造成处理麻烦的英制单位。 就把英国和新加坡的英语本地化一并开启，它们同属英语，应该不会额外占用太多空间 执行 1locale-gen 生成locale信息 1vim /etc/locale.conf 添加 1LANG=en_SG.UTF-8 网络配置 hostname 在 1/etc/hostname 中写上主机名 安装网络管理器 坑爹的官方安装教程对这里是一点没提，网络配置里面也写得含糊其辞，但是这一步很重要 通过 1pacman -S networkmanager 安装网络管理器 必须安装！ 等待它安装完毕 这是一个守护进程，但是我们目前在chroot模式下，因此只能在重启机器，以systemd启动后，才能为它设置启动项 ROOT用户自己的密码 1passwd 这一步很重要，务必记得修改root密码 用户管理 用户和用户组 虽然安装页面中没有提，但是安装期间最好还是为自己建立一个用户，避免日常使用root用户 1useradd -m -s \"/bin/zsh\" \"username\" 由于没有通过-G指定用户所在的组，因此会为用户单独创建一个组 如果这是第一个用户，那么uid和gid应该都是1000 虽然sudo不是用户管理的一部分，但是sudo是一个很重要的工具，一并安装 1pacman -S sudo 使用 1visudo 以便打开配置文件/etc/sudoers，修改文件，在保存前visudo会检查格式是否正常 顺便把其他杂七杂八要用的工具，例如网络连接实用程序、git一类的也一起装上并配置好，免得待会手忙脚乱，安全起见，shell有关的成功开机之后再配 安装引导程序 一般来说是GRUB GRUB 首先把工具安装上： 1pacman -S grub efibootmgr 然后让grub去做剩下的工作 1grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=GRUB 如无意外，提示 Installation finished. No error reported 安装就成功了 如果遇到问题，查看 UEFI 故障排查 接下来是配置 配置GRUB 使用 1grub-mkconfig -o /boot/grub/grub.cfg 来生成配置文件 当启动的内核发生变化，比如安装了新的内核之后，就需要更新这个文件，也就是重新运行grub-mkconfig 探测其他操作系统 有这个可行性，参考探测其他操作系统 但目前虚拟机中不需要 安装完成 在配置好GRUB之后，ArchLinux的安装就算是完成了，退出chroot，关机 12exitpoweroff 弹出虚拟光盘，重启一下试试能否正常引导 如果发生了任何错误，都可以通过重新加载archiso，进入arch-chroot解决，所以不必慌乱 进入系统 先检查一下shell、文件系统有无故障 如无意外，系统此时是连不上网的 启动网络管理器 一般来说，在带有DHCP的环境中，照顾好自己计算机系统的网络配置就可以了 启动服务进程 1sudo systemctl restart NetworkManager 注意大小写 用 1ping 工具检查网络管理器是否正常工作，例如ping www.sina.com 如果没有回应，换一个网站再试试 如果有回应，说明网络管理器工作正常，那么将网络管理器添加进入开机启动项 1sudo systemctl enable NetworkManager 注意大小写 至此，ArchLinux安装完毕 安装KVM 继续之前KVM安装前的检查部分 1zgrep CONFIG_KVM /proc/config.gz 1lsmod | grep kvm ls mod grep kvm 检查到的结果发现，模块没有加载，那么就需要手动加载这些模块 但我偏不这么做，我要让系统自动加载 1sudo vim /etc/modules-load.d/kvm-init.conf 输入以下内容： 1234567# Load KVM modules at boot 2023/05/12kvm_intelkvmgtmdevvfiokvmirqbypass :wq退出，reboot重启 启动时有一行标红报错一闪而过，不过我并没有注意到，其实那是 failed to start load kernel modules 开机之后，按照教程的说法，检查内核模块加载的情况 1lsmod | grep kvm 会发现没有kvm_intel选项，下方的说法提到 提示：如果 modprobe kvm_intel 或 kvm_amd 失败，但 modprobe kvm 成功，并且 lscpu 声称支持硬件加速，检查 BIOS 设置。某些厂商，特别是笔记本电脑厂商，默认禁用这些处理器扩展。modprobe 失败后，dmesg 的输出可以告诉你这些扩展是硬件不支持还是在 BIOS 中禁用。 使用 1sudo dmesg | grep kvm 之后，会发现提示kvm_intel : vmx not supported by cpu 0 然而，根据VirtualBox管理页面的显示，我的虚拟计算机是启用了VT-x硬件加速的，VBox BIOS中也并没有类似的选项 这期间我在互联网上找了很多东西，都没有满意的答案，事情陷入了困局 注意到，VBox的管理页面有一个选项叫“启用嵌套 VT-x/AMD-V”(Nested Virtualization)，这个选项是灰色的，默认不可选，考虑到主页提示过“VT-x已经启用”，也许使用这个选项是没有必要的？ 无论如何试试看 启用VirtualBox的嵌套VT-x/AMD-V 首先关闭虚拟计算机 参考VirtualBox启用套嵌VT-x/AMD-V 我的解决方案是，在Windows中打开Powershell 12cd 'C:\\Program Files\\Oracle\\VirtualBox\\'.\\VBoxManage.exe list vms 得到输出 123........................\"ArchLinux\" {e2f0d5f5-bd01-401b-9ffd-3d63b597061b}........................ 然后对其进行修改 1.\\VBoxManage.exe modifyvm \"ArchLinux\" --nested-hw-virt on 然后退出PowerShell 检查KVM内核模块情况 这次启动虚拟计算机，就没有任何内核模块加载失败的提示了 进入界面，输入 1lsmod | grep kvm 提示 1234567kvmgt 479232 0mdev 24576 1 kvmgtvfio 61440 2 kvmgt,vfio_iommu_type1i915 3837952 1 kvmgtkvm_intel 458752 0kvm 1327104 2 kvmgt,kvm_intelirqbypass 16384 1 kvm 可以看到kvm_intel已经正确加载，问题得以解决 1egrep -o 'vmx | svm' /proc/cpuinfo | wc -l 显示的数值不再等于0 OK！准备下一步 添加ArchLinuxCN社区源（可以不做） 这一步和今天的主题没啥关系，但是我得记录一下，以备之后的维护 1sudo vim /etc/pacman.conf 我使用了本校的源，但是我校的开源镜像站并不对外部网络连接开放，那么文章里写本校源不是很好 当然，Arch Linux CN的源原本就在国内，所以用最上流的源也很合适 或者可以用清华TUNA源，地址是Tuna: Arch Linux CN 软件仓库镜像使用帮助 12[archlinuxcn]Server = https://repo.archlinuxcn.org/$arch 12sudo pacman -Sysudo pacman -S archlinuxcn-keyring GUI？ or not？ 这一步我犹豫了一下，因为Linux的GUI那个安装管理使用实在是一言难尽，而且现在是在做实验，引入不必要的部分可能会带来“unforeseen consequences”，比如已经可以预见到显卡驱动全崩，需要在640x480的分辨率下去不知道哪个目录里面装卸驱动的惨状了 不过GUI确实会方便监视系统和虚拟计算机的运行状况，所以还是装吧 说实话我想给这一步的系统打个快照，但是目前的情况似乎不太允许 用什么呢？ 虽然我很讨厌KDE，但我考虑要不要在这台虚拟机里使用KDE，或者避免KDE和Gnome44中的任何一个，去用MATE，要不然就是继续用xfce4，这也是我最熟悉的桌面环境 还是试试MATE吧 1234sudo pacman -Syysudo pacman -S --needed xorgsudo pacman -S xorg-xinitsudo pacman -S mate mate-extra 12cd ~vim .xinitrc 1exec mate-session :wq 测试一下 1startx 肉眼可见地卡卡的，考虑到我只分配了2核心2GiB内存，显存只有16MiB的情况，还是去VBox里把显存调到支持的上限，128MiB吧，内存也加到8GiB，毕竟要跑图形界面 情况稍微有所改善 退出桌面，目前暂时还不需要图形环境 在菜单栏中寻找“登出”，也就是logout，将用户从MATE登出，即可关闭图形界面 安装QEMU 参考QEMU/KVM 虚拟化环境的搭建与使用 12sudo pacman -Syysudo pacman -S qemu-full virt-manager virt-viewer dnsmasq vde2 bridge-utils openbsd-netcat 1sudo pacman -S libguestfs 启动守护进程 启用libvirtd守护进程 12sudo systemctl enable libvirtd.servicesudo systemctl start libvirtd.service 修改配置文件，组管理 1sudo vim /etc/libvirt/libvirtd.conf 查找 12unix_sock_group=\"libvirt\"unix_sock_rw_perms=\"0770\" 去掉注释，使之生效 回到终端，进行组管理 12sudo newgrp libvirtsudo usermod -aG libvirt $USER 如此操作之后，目前正在使用的用户就被加入了一个允许读取socket的用户组libvirt中 最后检查一下/etc/group文件，确保刚才操作中的更改没有出错 1vim /etc/group 找到libvirt用户组，参考用户组文件，和用户组 一般来说，在libvirt这个用户组后面看到自己的用户名，并且其他地方没有预料之外的修改，那就对了 重启libvirtd服务 1sudo systemctl restart libvirtd.service 嵌套虚拟化 就像刚才在VBox中为ArchLinux开启嵌套虚拟化一样 现在需要为Arch带有的KVM启用嵌套虚拟化，方便将来要用的虚拟机使用 1cat /sys/module/kvm_intel/parameters/nested 如果提示Y，则说明启用了嵌套虚拟化 对于农企U，则是 1cat /sys/module/kvm_amd/parameters/nested 我这里提示开启了，真是不枉刚才折腾了半天KVM 如果没有开启，可以查看启用嵌套虚拟化 检查虚拟化环境的情况 之前安装了qemu-full，和libvirt，进图形界面检查一下 1startx GUI libvirt 如图，打开这个桌面应用，完成！ 在KVM中安装Windows XP 为什么要安装Windows XP呢？ 因为Windows具有和Linux完全不同的内核 而XP是目前手头能找到的，最简单的Windows操作系统安装映像了 如果需要的话之后试一下Windows 7 把镜像搞到虚拟机里面 由于这个ArchLinux刚刚安装完毕，文件拷贝有些不太好办，懒得装VBox的客户工具了（主要是客户工具涉及到内核模块，不想引入额外的复杂度） 用HTTP协议传到虚拟机里面吧 cURL 启动GUI下的QEMU 初学KVM，先看看要怎么用这个东西 用起来感觉和VBox没什么不同啊（ VBox-like GUI 啊，熟悉的界面，爷少回！ Windows Setup 等待安装，已经开始显示汉字了 Windows XP Setup Chinese 关于虚拟计算机的硬件信息 Hardware Info 在磁盘上查找了一下对应的文件，发现所有者是单独的一位用户libvirt-qemu，这一点很有意思 file-owner 以及Windows XP由于缺少驱动的原因是既没声音也没网，就这样吧 No Driver 如此这般之后，感觉没什么事做了 用又没甚用，卡又卡得慌，毕竟是在VB虚拟机里面的，也不能指望KVM表现出它正常情况下的性能 至于命令行调度虚拟机，用到的时候再说 总之，这个KVM用起来，感觉就是一个普通的虚拟机而已，不可否认，由于获得了来自内核模块的加速支持，它的性能肯定是要强一些的 本以为KVM会是一种单独的操作系统什么的，最后看来并不是这样呢，完全可以理解为一种QEMU的内核级加速(虽然QEMU只是KVM的一种适配形式，但除了QEMU，民用也拿不到别的东西来用了)呢 Knighthana 2023/05/12","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"2023","slug":"2023","permalink":"https://knighthana.github.io/tags/2023/"},{"name":"ArchLinux","slug":"ArchLinux","permalink":"https://knighthana.github.io/tags/ArchLinux/"},{"name":"KVM","slug":"KVM","permalink":"https://knighthana.github.io/tags/KVM/"}]},{"title":"奇加偶减-容斥原理","slug":"(KM)奇加偶减-容斥原理","date":"2023-05-06T14:50:00.000Z","updated":"2023-05-06T14:50:01.000Z","comments":true,"path":"KnowledgeMark/(KM)奇加偶减-容斥原理.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)%E5%A5%87%E5%8A%A0%E5%81%B6%E5%87%8F-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86.html","excerpt":"","text":"奇加偶减-容斥原理 在学习概率论与数理统计时提到过一个技巧，对于多个事件，计算其并事件时，遵循一个口诀“奇加偶减” 这个口诀的背后是容斥原理 容斥原理 - Wikipedia 容斥原理（inclusion-exclusion principle）又称排容原理， 在组合数学里，其说明若 为有限集，则 其中 表示 的基数。 例如在表示两个集的情况时，我们可以通过将 和 相加，再减去其交集的基数，从而得到其并集的基数。 描述 两个集合的容斥原理 三个集合的容斥原理 n个集合的容斥原理 或 或 (转载者注：还是分别组合、奇加偶减) 概率论中的容斥原理 在概率论中，对于概率空间 中的事件 有 两个事件的容斥原理 三个事件的容斥原理 推广 自行推广 Knighthana 2023/05/06","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://knighthana.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Math","slug":"Math","permalink":"https://knighthana.github.io/tags/Math/"},{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://knighthana.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}]},{"title":"从光电鼠标到光流法","slug":"(KM)从光电鼠标到光流法","date":"2023-05-06T14:00:00.000Z","updated":"2023-05-06T14:50:00.000Z","comments":true,"path":"KnowledgeMark/(KM)从光电鼠标到光流法.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)%E4%BB%8E%E5%85%89%E7%94%B5%E9%BC%A0%E6%A0%87%E5%88%B0%E5%85%89%E6%B5%81%E6%B3%95.html","excerpt":"","text":"从光电鼠标到光流法 突然对光电鼠标的工作原理感兴趣 虽然说以前大概知道个原理，类似照相机，但是凭借如今的知识储备，已知道，即便其原理类似照相机，其实现方式不可能真的用照相机一类的东西——数据流太大。 目前搜集到的资料显示，光电鼠标搭载了一个对极小像素区域(约32×32到40×40左右的区域)进行图像分析的DSP，这些DSP分析速度达到每秒上千帧或是每秒上万帧 而且，这些图像信息不会被存储，DSP只对位移信息感兴趣，也只输出位移相关的内容，所以说和相机还是有很大的不同 尽管图形界面上的光标总是以坐标的形式运用，鼠标硬件在现实中也是以坐标的形式使用，但是鼠标的电学部分并不输出坐标信息，而是位移，这些位移信息被计算机系统内部再次处理成为坐标信息，也就是说从现实到屏幕上的光标位置变化，经过了坐标→位移→坐标的转化 这里有两个非常关键的算法， 一个是“互相关” 另一个是“光流法” 光流法在CV领域也有广泛的应用 这里也有一个鼠标光学传感器厂商的产品简介 普通的光电鼠标使用LED作为光源，激光型的光电鼠标使用激光器作为光源 激光是相干光，具有一致的特性，因此激光光源相比LED光源从物品表面反射回的图像细节更加完善，这也是为什么所谓的“蓝光鼠标能在玻璃上使用而红光鼠标就不行”，这是因为鼠标里常用的激光器一般是蓝色种类的，而便宜实惠的LED一般是红色的，事实上也有使用蓝光LED的普通光电鼠标，但是蓝光LED毕竟是LED家族中比较薄弱的一环，用的也没那么广泛，因此这种说法就会具有“某种意义上”的普遍适用性 互相关 互相关 - Wikipedia 互相关实质上类似于两个函数的卷积。 离散 对于离散函数 和 来说，互相关定义为 其中和在整个可能的整数 j 区域取和，星号表示复共轭。 连续 对于连续信号 f(x) 和 g(x) 来说，互相关定义为 其中积分是在整个可能的 t 区域积分。 特性(节选) 互相关与卷积通过下式发生关系： 光流法 光流法 - Wikipedia 光流(Optical flow or optic flow)是关于视域中的物体运动检测中的概念。用来描述相对于观察者的运动所造成的观测目标、表面或边缘的运动。光流法在样型识别、计算机视觉以及其他影像处理领域中非常有用，可用于运动检测、物件切割、碰撞时间与物体膨胀的计算、运动补偿编码，或者通过物体表面与边缘进行立体的测量等等。 光流的测算 光流法实际是通过检测图像像素点的强度随时间的变化进而推断出物体移动速度及方向的方法。 假设该移动很小，那么可以根据泰勒级数得出： HOTs: Higher-order terms 因此可以推出： 或 最终可以得出结论： 这里的 ， 是 和 方向上的速率，或者称为 的光流。 而 ， 和 则是图在 在对应方向上的偏导数。 、 和 的关系可用下式表述： 或 这是两个未知数中的一个方程，不能这样求解。这被称为光流算法的孔径问题。为了找到光流，需要另一组方程，由附加的约束给出。所有光流方法都引入了估算实际流量的附加条件。 Knighthana 2023/05/06","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"DSP","slug":"DSP","permalink":"https://knighthana.github.io/tags/DSP/"},{"name":"鼠标","slug":"鼠标","permalink":"https://knighthana.github.io/tags/%E9%BC%A0%E6%A0%87/"},{"name":"互相关","slug":"互相关","permalink":"https://knighthana.github.io/tags/%E4%BA%92%E7%9B%B8%E5%85%B3/"},{"name":"光流法","slug":"光流法","permalink":"https://knighthana.github.io/tags/%E5%85%89%E6%B5%81%E6%B3%95/"}]},{"title":"pandoc的一些用法","slug":"pandoc的一些入门用法","date":"2023-05-05T17:45:00.000Z","updated":"2023-05-05T18:56:19.893Z","comments":true,"path":"Dev-Code/pandoc的一些入门用法.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/pandoc%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%A5%E9%97%A8%E7%94%A8%E6%B3%95.html","excerpt":"","text":"pandoc的一些用法 Pandoc是一个非常强大的转换文本呈现方式的转换器 我愿称之为文本类代码编译器 我想一般情况下，这个软件应该是用来将LaTeX文档转换成PDF， 不过我用了它的另一个用法，将markdown转换为HTML 众所周知，markdown只是一个方便书写但呈现效果随缘的语言，而HTML是一种专门设计用来呈现内容的标记语言 一般来说，支持markdown排版的程序会顺便支持html语法，以便呈现一些高级的效果 我觉得这和markdown便于书写的本质有所冲突，但如果要求创作时直接书写html，那更是和创作的本意大大地冲突了 但是目前还没有那个能力制定一套规则与对应的实现，因此闲话不多说，回到正题，我如何使用pandoc转换markdown文章到HTML 一般来说是 1pandoc --mathml --from=markdown README.md --output=html README.html 当然，pandoc支持简单的传参方式，因此写成 1pandoc --mathml -f README.md -t README.html 也是可以的 Pandoc手册的页面是Pandoc User’s Guide 数学公式 科学文章内难免需要用到数学公式，这也是--mathml参数出现在这里的原因 pandoc提供了这几种数学公式呈现方式： --mathjax[=URL] 这种方式要求数学公式必须以 1\\(...\\) （行内） 或 1\\[...\\] （段落） 的方式记录 URL参数指向一个含有MathJax.js的地址，如果不指定，默认使用一个指向CloudFlare CDN的地址 这种方式需要客户端方面保证网络状况良好 --mathml 这个参数会将\"TeX\"形式的数学公式转换成\"MathML\" 由于MathML在各主流浏览器中得到了广泛的支持，因此使用这种方式可以将所有呈现问题在服务端期间处理给HTML文件本身，仅仅把渲染方式交由客户端的浏览器决定 基本上，只要客户端有一个主流的浏览器，就不需要考虑诸如网络状况好坏一类的问题了 这也是我目前使用的方式 --webtex[=URL] 这个参数会通过外部服务器将\"TeX\"形式的数学公式转换成HTML中的&lt;img&gt;标签， URL参数指定希望调用渲染公式的服务器所提供接口的URL，例如pandoc网站上给出的例子分别是 1--webtex https://latex.codecogs.com/svg.latex? 和 1--webtex https://latex.codecogs.com/png.latex? 前者生成一个SVG矢量图，后者生成一个PNG位图 如果不指定，会默认采用CODECOGS(R)提供的PNG方式，也即示例中的第二种方式 这种方式将渲染交给了远程服务器，这无疑会对公益服务器造成负担，或者需要自己建立一个兼容\"webtex\"解析渲染方式的服务器，也需要客户端方面保证网络状况良好 不过从另一方面来说，显然地，这种方式对那些老旧或者小众的浏览器支持较好 --katex[=URL] 用KaTeX进行渲染，这里可以指定一个URL地址，这个地址应当存有katex.min.js和katex.min.css两个文件 如果不指定，将会默认使用一个指向\"KaTeX CDN\"的链接 这种方式需要客户端方面保证网络状况良好 顺带一提，vscode使用的渲染方式就是KaTeX --gladtex 将文件处理为一个可被GladTex理解的HTML文件(扩展名为.htex)，需要用户稍后手动指定图像输出目录和文件后执行\"GladTeX\"，渲染公式为本地SVG图像 手册网站给出的示例如下 123pandoc -s --gladtex input.md -o myfile.htexgladtex -d image_dir myfile.htex# produces myfile.html and images in image_dir 无疑，这种方式兼顾了客户端网络问题和客户端浏览器支持的问题， 虽然手动操作起来有点复杂，但从网站维护者的角度来看，它的稳定性极佳 总结 总之，pandoc真的很强大（pupil并感） 为了避免和小学生感想一样，引用一张图描述一下它有多强大： what pandoc do 以后如果还用到了其它用法，大概也会补到这篇文章里面 但目前的话就是这样了 参考 [1] John MacFarlane.Pandoc User’s Guide[EB/OL].(2006-2022)[2023-05-06].https://pandoc.org/MANUAL.html Knighthana 2023/05/06","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://knighthana.github.io/tags/HTML/"},{"name":"pandoc","slug":"pandoc","permalink":"https://knighthana.github.io/tags/pandoc/"},{"name":"markdown","slug":"markdown","permalink":"https://knighthana.github.io/tags/markdown/"}]},{"title":"生灭过程","slug":"生灭过程","date":"2023-05-05T15:04:16.000Z","updated":"2023-05-16T18:49:00.000Z","comments":true,"path":"subject-note/生灭过程.html","link":"","permalink":"https://knighthana.github.io/subject-note/%E7%94%9F%E7%81%AD%E8%BF%87%E7%A8%8B.html","excerpt":"","text":"生灭过程 我的理解将会和教科书上的不太一致，因此我也不能保证这里的理解一定是对的 ，如果与教材^1有冲突，那么以教材为准 “生灭过程”这个叫法是教科书上给出的，按照目前的实际使用体会而言，我更愿意称之为涨落过程、非跳跃过程一类的词汇。 如果我们将一个马尔可夫链按照“锁链”的形状绘制出来，成为一个一维的长链， 那么，我们认为一个“生灭过程”中的所有状态变化，都是每次只能由一个状态向其自身或者“左右相邻”的状态发生； 例如对于某一链状态的状态空间集合： 某一时刻，系统的状态是 ,那么下一时刻，系统的状态只能是 中的任意一个，要么从 状态转移为 状态，要么从 状态转移为 状态，要么保持 状态不变，只有这三种转移方式 既不允许从 状态跳跃到 状态，也不允许从 状态跳跃到 状态 “生”过程 第一种过程，从 状态转移到 状态 或者由“生”的字面意义理解，从 增加一个 为了避免照本宣科行为导致读者只见树木不见森林，不妨对这个公式做一些解释 首先，解释 含义是一个状态转移概率，就是“在极短暂时间 内，从 状态转移到 状态的概率” 而 是一个条件概率公式，含义是，在此时刻 ，系统的状态为 的条件下，系统下一时刻（也即极短暂的 时间后）的状态为 的概率 式子 的含义是，在时间 内，转移速率 （单位时间到达的顾客数，属于瞬时转移速率——又称为转移强度、转移密度——的一种），与时间 相乘，加上一个高阶无穷小量（可以忽略） (2023-05-17更新)： 经过询问老师“为什么一个算概率的公式里面会出现‘速率’”，老师的解答是，此处 与 的含义，可以理解为一种“带概率的转移速率”， 那么我的理解就是，这个过程是在一定概率下发生的，算出来的也就还是概率 “灭”过程 从 状态转移到 状态，也就是说，从 减少一个 与“生”过程相似的数学描述，只是将 这个表示增加的瞬时转移速率换成了 这个表示减少的瞬时转移速率 于是有 注意，此处的 含义是， 属于 但是不属于那个带0的集合，就是说不能光看这里的公式造一个 状态出来 “跳”过程 由于规定了生灭过程中不允许跳跃的出现，因此我们可以认为跳跃基本不发生，于是有 把这个高阶无穷小量忽略掉，我们认为这种情况不会发生 “不变”过程 不变就是保持原状，就是说，如果当前状态是 ，则下一时刻状态仍然为 之前绘制状态转移矩阵的时候，可以知道，这包含了进一出一和不进不出两种情况， 正难则反，将“不变”理解为上面所有变化事件的反事件，于是可以列出基于反事件的条件概率式： 总结 其实也没什么好总结的，生灭过程无外乎于此，逐次生一灭一，或者不变，仅此而已。 生灭过程之后将会成为一个简化工具，用来将复杂的过程变化简化，从而减少我们在研究排队问题的随机过程中需要考虑的情况。这是我目前个人的理解。 Knighthana 2023/05/06 更新：2023/05/17 参考资料 [1]曾勇，董丽华，马建峰.排队现象的建模、解析与模拟[M].西安：西安电子科技大学出版社,2011.9:9-14.","categories":[{"name":"subject-note","slug":"subject-note","permalink":"https://knighthana.github.io/categories/subject-note/"}],"tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://knighthana.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"随机过程","slug":"随机过程","permalink":"https://knighthana.github.io/tags/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/"},{"name":"排队论","slug":"排队论","permalink":"https://knighthana.github.io/tags/%E6%8E%92%E9%98%9F%E8%AE%BA/"},{"name":"生灭过程","slug":"生灭过程","permalink":"https://knighthana.github.io/tags/%E7%94%9F%E7%81%AD%E8%BF%87%E7%A8%8B/"}]},{"title":"(KM)5s管理法","slug":"(KM)5s管理法","date":"2023-05-03T16:00:00.000Z","updated":"2023-05-05T14:40:00.000Z","comments":true,"path":"KnowledgeMark/(KM)5s管理法.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)5s%E7%AE%A1%E7%90%86%E6%B3%95.html","excerpt":"","text":"5S现场管理法 这个管理方法并非仅仅用来管理企业，它的思想还可以用于日常对自我周围环境的管理、对个人项目的管理等等感觉因为杂乱而影响效率的场合 这篇文章只是摘抄，具体如何进行还需要进一步地消化吸收，做一些本地化工作 5S现场管理法的条目 seiri 整理 seiton 整顿 seiso 清扫 seiketsu 清洁 shitsuke 素养 对于5S管理法的解释 整理（日文读音：Seiri，英语：Sort） 对工作时身边的设备、物资、产品等物品区分要与不要的。 对要的物品进行井井有条的分类管理。 对不要的物品又区分有用的和无用的物品。 1. 有用的物品转移到现场之外，进行有关处理。 2. 无用的物品坚决清除。 整顿（日文读音：Seiton，英语：Set In Order） 需要的物品要能很快的拿到，不需要寻找，用后放回原处。以达到安全、高效、提高工作效率。 各个物品应有明确的标示。 三定原则：定点、定量、定容 进行整理阶段后，区分出现场物品要与不要，并依据使用频度，将所需工具/检具进行定位及标示 利用颜色管理，提升物品拿取速度及正确性 六定:定容，定量，定位，定姿，定质，定时 清扫（日文读音：Seiso，英语：Shine） 美化环境，使桌面干净整齐，形成明亮的、赏心悦目的现场环境，可以方便的检查出是否发生问题。 利用前两个步骤的挂牌及取牌，将重复发生的问题寻找出来 - 发生源:利用断绝，减少，隔离，容易(断/减/离/易)的手法进行改善 - 困难部位:利用目视化，透明化，省时省力化，集中化的手法进行改善 清洁（日文读音：Seiketsu，英语：Standardize） 维持上述清扫的效果，做到持续保洁。 素养（和制汉字：躾，日文读音：Shitsuke，英语：Sustain） 每位成员(自我)养成良好习惯，遵守规则做事，文明的员工(自我)是文明管理(高效生活生产)的根本保证。 对于5S管理法在软件项目管理领域应用的解释 整理（SEIRI） 定义：区分要与不要的物品，现场只保留必需的物品。 软件应用中：区分代码库中无用代码，代码库里只保留有用的代码。 整顿（SEITON） 定义：把必要的东西放在规定的地方，并能很快取出，规定放置区，明确标示。 软件应用中：对代码要有明确的命名规范，对必要的代码写上工整的注释，便于维护和理解。 清扫（SEISO） 定义：清除职场内的脏污，并防止污染的发生。 软件应用中：对代码库中冗余的代码做\"清扫\"，让代码简洁可读。 清洁 （SEIKETSU） 定义：将整理、整顿、清扫实施的做法制度化、规范化，维持其成果。 软件应用中：将整理、整顿、清扫定期化和规范化，以达到代码库整洁的目的。 素养 （SHITSUKE） 定义：培养文明礼貌习惯，按规定行事，养成良好的工作习惯。 软件应用中：遵循代码规范，养成好的工作习惯，提高职业素养。 日本语解释 (日文看不懂啦) 名前は、5項目のローマ字での頭文字がいずれもSとなっている事に由来する。5Sに基づいた業務管理を5S管理・5S活動などと呼ぶ。 整理（せいり、Seiri） いらないものを捨てる 整頓（せいとん、Seiton） 決められた物を決められた場所に置き、いつでも取り出せる状態にしておく 清掃（せいそう、Seisou） 常に掃除をする 清潔（せいけつ、Seiketsu） 3S（上の整理・整頓・清掃）を維持し職場の衛生を保つ 躾（しつけ、Shitsuke） 決められたルール・手順を正しく守る習慣をつける 5S自体による効果は職場環境の美化、従業員のモラル向上などが挙げられる。5Sの徹底により得られる間接的な効果として、業務の効率化、不具合流出の未然防止、職場の安全性向上などが挙げられているが、メリットもデメリットもある。 日本で生まれた概念だが、日本国外で用いられることもあり、「ファイブ・エス (five S)」と言う。 参考 zh wikipedia: 5S管理 jp wikipedia: 5S 5S管理如何应用到软件开发中 Knighthana 2023/05/05","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"管理","slug":"管理","permalink":"https://knighthana.github.io/tags/%E7%AE%A1%E7%90%86/"}]},{"title":"(KM)日语中的一些词语词组","slug":"(KM)日语中的一些词语词组","date":"2023-05-03T14:25:00.000Z","updated":"2023-05-03T16:00:00.000Z","comments":true,"path":"KnowledgeMark/(KM)日语中的一些词语词组.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)%E6%97%A5%E8%AF%AD%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%8D%E8%AF%AD%E8%AF%8D%E7%BB%84.html","excerpt":"","text":"日语中的一些词语词组 包含汉字的写法 片假名 罗马字 汉语意义 こちら こちら kochira 那个(离我近的) そちら そちら sochira 那个(离你近的) あちら あちら achira 那个(离我们都远的) どちら どちら dochira 哪个 お願いします おねがいします onegaishimasu 拜托了 しばらく お待ちください しばらく おまちください shibaraku omachikudasai 请稍等 お疲れ様です おつかれさまです otsukaresamadesu 辛苦了 Knighthana","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"日语","slug":"日语","permalink":"https://knighthana.github.io/tags/%E6%97%A5%E8%AF%AD/"}]},{"title":"vim的一点介绍","slug":"vim的一点介绍","date":"2023-05-02T08:25:00.000Z","updated":"2023-05-05T17:41:12.762Z","comments":true,"path":"Dev-Env/vim的一点介绍.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/vim%E7%9A%84%E4%B8%80%E7%82%B9%E4%BB%8B%E7%BB%8D.html","excerpt":"","text":"vim的一点介绍 最近在网络社交论坛上经常(“多次”、“反复”)看到关于vim的话题，讨论的双方中，一方认为不知道vim鼎鼎大名的人不配做程序员，另一方认为2023年还在用vim的人除了装逼之外没有别的目的。 就感觉……挺无聊的，有这个功夫不如去争论一下“PHP到底是不是最好的语言”，哦对，时过境迁，现在的话应该是争论“JavaScript是不是最好的语言”，毕竟人家都已经有Webassembly这种玩意了； 首先声明，我现在已经不把vim当做主要的代码工具来用了，但是，如果需要临时快速编写或处理一些文本、调整配置文件，乃至提交git的commit，都是会使用vim的，有使用习惯和高效率两方面的原因。因此这篇文章的水平也不会高到哪里去，我只能保证它比初学者的水平高。 这篇文章是面向初学者的，我觉得，假如之前还有初学者在围观这种无聊的争论，不知道自己是不是应该使用这个“逼格很高”的工具，现在看到这篇文章，也差不多该学一学然后散了，各做各的事情去。 生命苦短，不看吵架。 在 讲一些vimtutor中没有的东西 一节中会讲一些常用的高阶用法，阅读前半节打开vimtutor zh窗口的同时，可以直接跳到后面看一看“讲一些vimtutor中没有的东西”的内容，至于前面的半节内容，其实不看也无妨。 （善用目录功能） vim的入门——vimtutor zh vim的入门不应该有太复杂的心理负担，虽然说有人声称vim的学习曲线非常高耸，画了一条骇人听闻的曲线，确实，它的操作比起记事本和micro$oft word是有些反常识了，但这是思路的问题，是常识本来就不兼容的问题。 最基本的hjkl交互逻辑，在Unix、GNU/Linux中本就是经常可以看到的，这也是常识的一种，比如man。 我觉得任何人，入门vim的最佳方式，都应该是抽出半个小时，甚至半个小时都用不上，十几分钟，把vimtutor过一遍；我想不到还有什么比这个交互式教程更快的学习方式了。 而不是先打开搜索引擎：我惊讶于有这么多人从网站开始学习vim，他们会表示太难，太反直觉，往往在浏览器窗口和终端窗口来回切换，叫苦连天；但是却对它自带的教程充耳不闻； 就vim而言，这种学习方式不太妥当； 对于初学者来说，直接在终端中输入vimtutor即可，不过由于每个人使用的系统语言设置不同，此条命令有可能会打开一个英文版本的教程，所以请使用 1vimtutor zh 打开中文教程。 它会在/tmp/中创建一个副本，所以基本不用担心修改到原文件。 vimtutor zh的作者有 Michael C. Pierce Robert K. Ware (创意) Charles Smith (修订) Bram Moolenaar (翻译) 梁昌泰 (翻译) 赵涛 (通信) Sven Guckes 移动 hjkl 移动是非常基础的操作，虽然vim支持使用方向键←↑↓→移动，但适应hjkl的操作有右手不离开主键区一直处于准备位置且只有最灵活的食指需要移动的好处； 按j往下一行翻动页面。 虽然说当初刚开始使用vim的时候，即便在这篇教程内，我也是用方向键的，但是现在已经更习惯hjkl了，甚至有时会在nano里面打出hijk。 退出 我记得有个经久不衰的笑话， 如何最快获得一串完全随机的字符 找一个新手，让他试着退出vim或者emacs vim的退出这么奇怪，是因为，作为一个命令行环境的编辑器它必须提供命令和编辑两种交互逻辑，粗略来说，vim有两种模式， “正常模式”，这种情况下，输入被视为命令；我觉得叫它“命令模式”也无妨； 插入模式，或者说，编辑模式，非正常模式，这种情况下，输入被视为字符； 当然还有其他模式，但是将它们基本归类在正常模式之内也无妨， 从插入模式到正常模式的方式是按esc键，如果不确定自己在哪个模式，多按几下esc总是能回到正常模式的； 在正常模式下，各种键盘输入会被当做命令来理解，最简单的退出，需要先输入一个冒号，也就是shift+;，然后输入w，这大概是\"write to file\"的意思，再输入一个q，也许是\"quit\"的意思，然后回车， 如果不想保存，那么输入:q也是可以的，但是问题在于，假如对文件有过改动，vim会阻止不保存而退出的行为，所以需要强制执行，那就是:q! 也就是说:wq+回车，或者:q!+回车，就可以退出vim 在终端界面中输入vimtutor zh以重新回到教程； 进入插入模式 编辑文档，这是一个文本编辑器最重要的功能；上面的内容算是简单介绍GUI中的菜单栏，下面说说中间的窗口，编辑文档，或者说插入模式； 从正常模式到插入模式的转换方式有很多，最常见的是按i，这是从GUI转过来的人觉得最熟悉的方式， 但是vim比起GUI的编辑器强大的地方在于，正常模式下，vim有26个小写英文字母和26个大写英文字母，一共52个字母用于精细地进行控制，它不像严重依赖光标的GUI编辑器，而是可以非常精准地表达自己要做的事情，例如： r，替换光标位置的单个字符，替换结束之后自动返回正常模式，是基于单个字符的替换，并且保留在正常模式，一般用来替换文本中已有的单个不当字符 R(大写r)，连续替换，类似insert键的功能 s，删除光标所在字符，并进入编辑模式，也是基于单个字符的替换，但是会进入编辑模式，类似于GUI的delete+输入 o，在下方直接插入一个新行，并进入编辑模式，类似enter+输入 A(大写a)，在行尾进入编辑模式；这个操作在GUI中基本需要右手离开键盘，用鼠标精准地定位到行尾点击，然后右手回到键盘进行操作；当然，简单来说，对于具有104键键盘的GUI使用者来说，一个end键就可以搞定了；但是用大写A可以不用伸出右手去摸控制键位的位置； a(小写a)，这个并不是很常用，它会在光标之后插入文本； 还有很多，不一一举例了，因为其它的我也没怎么用过； 基于字符或单词粒度的光标位置或命令控制 有点抽象，所谓字符粒度，单词粒度，说的是一次移动多少，停留在哪里，例如： w，这个输入使光标一次跳过一个单词，出现在下一个单词开始的位置，对于中文的分词能力则较弱，一般是跳到下一个空格后的第一个字符的位置，w的跳转不限于单行内； e，这个输入也会使光标一次跳过一个单词，但是光标会出现在单词末尾的位置，同样，对于中文的分词它就不是那么聪明了，一般是根据空格和特殊符号决定自己何时出现的； 命令则是另外的一些东西， x，删除单个字符(实际上是剪切) d，是删除命令的开头，后面需要跟一个描述需要删多长的命令字符，比如dd，表示删除一整行，dw，表示删掉一个单词 介绍到此为止 之后的内容我觉得应该全部交给 1vimtutor zh 无论是撤销，查找替换，高亮搜索，还是可视模式与剪切复制粘贴一类的东西，这些通过阅读vimtutor讲解，在其中练习，都比阅读一篇教程要来得好。 vim在处理很长的单行文档方面的能力，是我目前见过的编辑器之中最强大的，不用担心它会崩溃卡死；如果vim也崩溃卡死了，那么这个文档可能确实是很难处理了。 讲一些vimtutor中没有的东西 有些东西教程里面没有写，可能是觉得过于高级不必介绍，但我觉得这些挺常用的，因此写在这一节 分窗 正常模式中，输入 1:vs +回车以将窗口竖直切开一分为二以便打开多个文件，这个最常用，因为代码竖着看比较方便； 输入 1:sp +回车以将窗口水平切开一分为二，如果要用的话也是可以的； 还可以组合执行，例如将已经vs切开的窗口再度sp切开，这样会得到三个窗口； 按下两次ctrl+w以便在多个窗口之间来回切换， 用:q或:wq或:q!来退出单个窗口，如此原来被切开的窗口会重新占据两个窗口的位置 使用ctrl+p或ctrl+n进行补全 教程没有讲这些进阶操作，但是对于经常用vim码代码的人来说，补全是挺常用的功能， ctrl+p或者ctrl+n会给出可供选择的补全列表，p是在变量名之间选择可能的补全，n是在所有输入过的字符串中选择可能的补全 在帮助命令 1:help compl-generic 中会有其它更加详细的补全介绍 临时调用sudo提高权限保存文档 这是很经常的事情，比如去/etc/里面修改配置文件，退出的时候发现忘了使用超级用户权限， 假如直接退出，那么编辑的内容就没了，但是想写入的话，却因为缺乏权限完全做不到。 1:w !sudo tee % 使用这个命令需要安装有tee这个文本编辑输入输出工具，一般来说在各大发行版中tee是默认安装的 这将会是这种困境下最方便也基本是最优雅的选择。 vim的鼠标模式 vim支持鼠标 1:set mouse=a 可以通过窗口中的冒号命令，如上，临时启用鼠标支持， 也可以通过修改~/.vimrc持久启用或关闭鼠标的支持，将这条命令去掉冒号，单独一行保存在.vimrc中即可 a是启用了所有情况下的鼠标支持，可能用不到那么多情况，vim支持针对场景进行自定义的鼠标支持 可以阅读 vim鼠标模式打开与关闭 获取直观的介绍 或者在vim中输入 1:help mouse 获取来自帮助文档中的更加详细的说明 不看草台教程，浪费时间， 不看吵架，浪费生命！ Knighthana 2023/05/02","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://knighthana.github.io/tags/vim/"}]},{"title":"2023年4月折腾Hexo和Node","slug":"2023年4月折腾Hexo和Node","date":"2023-04-19T13:04:00.000Z","updated":"2023-11-16T13:38:16.437Z","comments":true,"path":"Blog-Maintenance/2023年4月折腾Hexo和Node.html","link":"","permalink":"https://knighthana.github.io/Blog-Maintenance/2023%E5%B9%B44%E6%9C%88%E6%8A%98%E8%85%BEHexo%E5%92%8CNode.html","excerpt":"","text":"2023年4月折腾Hexo和Node 记录一下从白板开发机开始安装Hexo需要经历的事情 build-essential和git之类的肯定就不用提了，再白板也是开发机 安装nvm 首先，在Linux下，“不要通过系统包管理器安装一个包管理器”。 我想gems那边的教训已经足够深刻了。 文章 Resolving EACCES permissions errors when installing packages globally 也提到了 If you see an EACCES error when you try to install a package globally, you can either: Reinstall npm with a node version manager (recommended), or Manually change npm's default directory 谨慎才能保护好开发环境 那就先装一个nvm罢。 下载并安装nvm 下载nvm 1wget https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh 如有必要，注意打上“网络环境稳定维持器前缀” 安装nvm 1bash ./install.sh 这其实是一个含有下载的脚本，因此如果网络环境不佳，这一步也需要做好网络状况不佳情况下的处理工作 设置源 Use a mirror of node binaries To use a mirror of the node binaries, set $NVM_NODEJS_ORG_MIRROR: export NVM_NODEJS_ORG_MIRROR=https://nodejs.org/dist To use a mirror of the io.js binaries, set $NVM_IOJS_ORG_MIRROR: export NVM_IOJS_ORG_MIRROR=https://iojs.org/dist 也就是说，为了一个小程序，我还得去改一下我每次开机都会自动执行一遍的.zshrc，不知道为什么要这么设计 那就改吧 打开.zshrc 在最下面一行添加注释 1# setting NVM mirrors (bon-NO-jour) 2023-04-17 然后添加内容 1export NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node/ 安装Node 鉴于Node.js 版本限制说了 我们强烈建议永远安装最新版本的 Hexo，以及 推荐的 Node.js 版本。 那我不仅hexo要装最新版本，node也装最新版本 老夫装环境，不管什么稳定性，最新版，给我装！ (bushi) 1nvm ls-remote 2023年4月17日，node的最新版本是v19.9.0，最新版给我装！ 1nvm install 19.9.0 回车！！！ 然后就装好了 下一步是给npm换源，找一下， 1npm config get registry 和 1npm config set regisry https://whatisthatidontknowandyoudontcopy.unsc 分别是查询当前镜像设定和修改镜像设定的命令，目前国内最大的npm源那肯定是原淘宝源现npmmirror.com 顺便提一下,首页写着 📢📢 「重要通知」原淘宝 npm 域名即将停止解析 📢📢， 抄过时教程抄成taobao.org的记得改一下源 那就很简单了， 1npm config set registry https://registry.npmmirror.com/ ，然后用 1npm config get registry 查看一下，应该是没有问题了 更新npm 更新npm的命令非常地递归 1npm install npm 作为一名工科男我觉得太酷了，很符合我对包管理器的想象，科技并...... 禁止释放何武器！！！(捂嘴) 安装Hexo 参考 安装 Hexo 不难发现，只需要一条命令 1npm install -g hexo-cli 对了，这种情况下，npm包的位置在哪？ 查了一下你抄我我抄你的草台教程，都说在/usr/local/lib/node_modules/ 实际上如果按照推荐方式安装nvm再安装node的话就不是这样的，用一下whereis命令就知道了，当然，前提是这个路径已经注册到环境变量里面了，不然用whereis是查不出来的，这里权当满足一下好奇心 12whereis hexohexo: /home/knighthana/.nvm/versions/node/v19.9.0/bin/hexo 所以很显然，通过nvm搞起来的环境里面，npm包的安装位置是~/.nvm/version/node/v.x.x.x/bin/ 出于好奇心顺便查了一下我的$PATH，不知道是从哪混进来一个/snap/，好在去查询了一下根目录，发现没有/snap/这个目录，最终也并不知道是被哪个夹带进来的 准备建站 由于不同的主题配置方式可能有所不同，所以先确定主题，再进行下一步配置 在Themes|Hexo挑一个喜欢的主题 配置Volantis 我只关注美观和功能(比如支持搜索)两个部分，所以选择了Volantis 那么接下来就是转到主题配置网站上，跟着教程修改_config.yml文件了 (三天之后)然后改了三天，发现这玩意真难改， 占用老子写文时间，焯！🤡 改到一半试着跑了一下然后启动server，发现视觉效果还行，但是这报错那报错，标题还全都是日期(日期还都是前天) 不是说人家Volantis做得不好吧，其实配置文件写得挺详细的，就是感觉我和这东西的相性不太好，再改配置文件下去拖延症就要犯了，遂换之 老规矩，先明确自己的需求 我需要达成的目标虽然不太多，但好像还挺全方位的（ 我想只负责写markdown，不想操心别的事情，这个模板需要快速根据markdown生成html网页，最好是一键生成 对中文使用者友好，最好是支持万国语言，打两个日文和俄文字符不要宕机 支持标签和搜索功能，方便我出门在外用手机解决问题的时候找文章 优良的数学公式渲染能力，我的博客现在已经有一些数学公式要渲染了，将来估计还有更多 明了，不要花里胡哨(或者不花里胡哨但是啥都没有半天显示不出来那种)以至于找不到文章在哪 开箱即用(尽量，我稍微有点技术傍身，但不多) 美观(尽量美观，做不到美观的话可以明了，不要太难看就行) 尝试nexmoe 之前配volantis配得焦头烂额，然后到处找教程，然后看到了Hexo搭建博客 - nexmoe主题 那还用啥自行车啊，换！ 于是去尝试用了hexo-theme-nexmoe 参考这个_config.yml，挑挑拣拣地配好自己的_config.nexmoe.yml文件 (真是给作者mua一个) 配置数学公式渲染功能 这个步骤花费了我很多时间，真的是受够了 先后试了hexo-renderer-mathjax hexo-math，效果不能说是不太理想吧，只能说是啥都渲染不出来 期间还找到了许多草台教程，又是要换渲染引擎，又是教我去修改node_modules\\kramed\\lib\\里面的文件，我看着要改的文件开头那行 1234/** * DO NOT EDIT THIS FILE * The code in this file is generated from files in ./src/ */ 就犯嘀咕，这东西真的能改吗？？？ 也可能是我比较蠢配不好设置吧，反正是不太会用这些玩意，那就让它爪巴吧 12npm uninstall hexo-mathnpm uninstall hexo-renderer-mathjax 还有那个数学公式都渲染不明白的蠢蛋hexo-renderer-marked也给我爬 1npm uninstall hexo-renderer-marked 不换功能就换工具 最后找来找去，还是找到好东西了 Hexo Filter MathJax 全后端渲染，不需要任何前端支持， 好东西！真是好东西！ README里面写得清清楚楚，明明白白，一步一步照着来就可以了，灰常完美！ 照着下面的推荐，还顺便装上了hexo-renderer-pandoc，只不过这个库需要在本地计算机上安装一个pandoc，还好ubuntu apt的默认源里面有，直接安装就可以了。 把服务器在本地跑起来，页面倒还不错，那个矩阵渲染得漂亮啊，和我在vsc预览界面看到的几乎一模一样啊！ 代码高亮 不得不承认，这环境肯定是哪里配错了，总之代码高亮并没有实现，至少实现得不是很漂亮 (对照着Hexo和nexmoe文档折腾了半天，甚至切换到了hexo-theme-next又切换回来之后) 那就没有实现吧，我不管啦！ 然后下来就是一个markdown接着一个markdown地痛苦地修改文章格式了 正在做这件事，一袋米要抗几楼！ 一袋呦！ Knightana 2023/04/19","categories":[{"name":"Blog Maintenance","slug":"Blog-Maintenance","permalink":"https://knighthana.github.io/categories/Blog-Maintenance/"}],"tags":[{"name":"LinuxMint","slug":"LinuxMint","permalink":"https://knighthana.github.io/tags/LinuxMint/"},{"name":"2023","slug":"2023","permalink":"https://knighthana.github.io/tags/2023/"},{"name":"Hexo","slug":"Hexo","permalink":"https://knighthana.github.io/tags/Hexo/"},{"name":"Node.js","slug":"Node-js","permalink":"https://knighthana.github.io/tags/Node-js/"},{"name":"nexmoe theme","slug":"nexmoe-theme","permalink":"https://knighthana.github.io/tags/nexmoe-theme/"}]},{"title":"2023年4月在LinuxMint上安装CUDA","slug":"2023年4月在LinuxMint上安装CUDA","date":"2023-04-17T16:00:00.000Z","updated":"2023-04-20T11:50:50.701Z","comments":true,"path":"Dev-Env/2023年4月在LinuxMint上安装CUDA.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/2023%E5%B9%B44%E6%9C%88%E5%9C%A8LinuxMint%E4%B8%8A%E5%AE%89%E8%A3%85CUDA.html","excerpt":"","text":"2023年4月在LinuxMint上安装CUDA 安装软件务必遵守官方说明，这是血的教训啊 通过网络安装 预下载方式安装 遵照网页下方的说明一步一步进行，在某些关键步骤记得重定向日志 在安装完毕后会提示需要重启以便检查驱动是否正常工作，先检查一下输出的日志里面有没有提示什么重要的事情，然后按照自己掌握的知识重启 找不到nvcc命令 我遇到了重启后nvidia-smi提示CUDA已经安装，但是nvcc却没有正确响应的情况 查了一下资料，这可能是因为环境变量没有正确地包含cuda的路径导致的：解决nvcc --version显示command not found问题 就很奇怪，因为我检查了一下.bashrc，里面也没有提到有关nvidia或者cuda的PATH信息 按说有关环境变量的这种事情不该发生，但是它就是发生了，那没有办法，只能自己解决了 手动在zsh的配置文件(.zshrc或者.zprofile)里面往环境变量中添加cuda的路径 这里我在重启几次之后发现我的.zprofile并没有正常起作用 查了一下资料，怀疑是[Solved] .zprofile not sourced里面提到的 Display Managers \"helpfully\" ignore some of the shell initialisation files. That is why your .zprofile isn't being read... 正巧我用的就是lightdm 那只能继续往.zshrc里面塞东西了，但是这样的下去话.......我的zsh启动速度会变得越来越慢的吧 然后我又找了一番，发现.profile这个文件里面是有东西的，而且我发现了torch的语句，也就是说，之前发现的$PATH里有两个torch的未解之谜也破解了 那就使用.profile文件吧，虽然zsh不读取它，但看起来lightdm读取它了 为PATH添加/usr/local/cuda/bin/ 为LD_LIBRARY_PATH添加/usr/local/cuda/lib64 卸载本地版本更换为网络版 我首次安装的时候使用了本地版安装，这样源被设定为了始终从本地读取，感觉不太好，不能保持最新，且每次读一遍本地目录浪费时间，于是在安装完成CUDA之后，我打算卸载掉本地的源，重新设定为网络源 安装时一共增添了两个文件一个包，那么倒序进行 首先查看/etc/apt/preferences.d/里面的cuda-repository-pin-600文件，发现里面没有提到“本地”，那就先不管 再查看/usr/share/keyrings/，删除里面的密钥文件 然后执行apt remove cuda-repo-ubuntu2204-12-1-local_12.1.0-530.30.02-1_amd64.deb apt报告的依赖关系中并未提到会卸载其它的包，那就卸载 最后查看一下/etc/apt/sources.list.d/，里面有一个关于file:///var/的源，把这个源删掉 按经验判断，应该没有问题了 此时再次apt update，提示需要更新nvidia的驱动，那必然是不敢执行的 打开 Download Installer for Linux Ubuntu 22.04 x86_64 重新安装一遍网络版的CUDA安装程序 再次apt update，发现不再提示需要更新nvidia驱动了，那么就算搞完了。 Knighthana 2023/04/18","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"LinuxMint","slug":"LinuxMint","permalink":"https://knighthana.github.io/tags/LinuxMint/"},{"name":"CUDA","slug":"CUDA","permalink":"https://knighthana.github.io/tags/CUDA/"},{"name":"2023","slug":"2023","permalink":"https://knighthana.github.io/tags/2023/"},{"name":"NVIDIA","slug":"NVIDIA","permalink":"https://knighthana.github.io/tags/NVIDIA/"}]},{"title":"Linux版本的Chrome无法使用鼠标中键滚动页面","slug":"Linux版Chrome中无法用鼠标中键滚动页面","date":"2023-04-17T16:00:00.000Z","updated":"2023-04-20T10:30:14.906Z","comments":true,"path":"Dev-Env/Linux版Chrome中无法用鼠标中键滚动页面.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/Linux%E7%89%88Chrome%E4%B8%AD%E6%97%A0%E6%B3%95%E7%94%A8%E9%BC%A0%E6%A0%87%E4%B8%AD%E9%94%AE%E6%BB%9A%E5%8A%A8%E9%A1%B5%E9%9D%A2.html","excerpt":"","text":"Linux版本的Chrome无法使用鼠标中键滚动页面 至少在Ubuntu某些版本和基于Ubuntu的某些发行版中，在Chrome中用鼠标中键尝试滚动页面，会发现不弹出拖动以滚动页面的图标。 12年前有人提过 Chrome/Chromium middle mouse button for scroll Linux, Mac 这个问题 解决方案就是安装这个AutoScroll插件 改xinput什么的方法就算了，目前看来实现同样的功能花费了更多的时间，而且在更大范围造成了对我而言未知的后果，所以暂时不采用这个方法。 2023/04/18 Knighthana","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"Chrome","slug":"Chrome","permalink":"https://knighthana.github.io/tags/Chrome/"}]},{"title":"(KM)Manual page of cURL","slug":"(KM)Man_cURL","date":"2023-04-15T16:00:00.000Z","updated":"2023-05-22T14:06:51.119Z","comments":true,"path":"KnowledgeMark/(KM)Man_cURL.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)Man_cURL.html","excerpt":"","text":"Manual page of cURL 1curl -fsSL 含义是静默地下载文件 1curl -fsSL -O $URL 则是从URL处下载一个原名的文件 那么常用的无外乎两种情况 从国内下载文件时，使用 1curl -fsSL -O $URL 可以快速且静默地下载完文件 下载国外的文件时，应该使用 1curl -fSL -O $URL 以便监视是不是下着下着就断线了 -f, --fail (HTTP) Fail silently (no output at all) on server errors. This is mostly done to enable scripts etc to better deal with failed attempts. In normal cases when an HTTP server fails to deliver a document, it returns an HTML document stating so (which often also describes why and more). This flag will prevent curl from outputting that and return error 22. -s, --silent Silent or quiet mode. Do not show progress meter or error messages. Makes Curl mute. It will still output the data you ask for, potentially even to the terminal/stdout unless you redirect it. -S, --show-error When used with -s, --silent, it makes curl show an error message if it fails. -L, --location (HTTP) If the server reports that the requested page has moved to a different location (indicated with a Location: header and a 3XX response code), this option will make curl redo the request on the new place. If used together with -i, --include or -I, --head, headers from all requested pages will be shown. When authentication is used, curl only sends its credentials to the ini‐ tial host. If a redirect takes curl to a different host, it will not be able to intercept the user+password. See also --location-trusted on how to change this. You can limit the amount of redirects to follow by using the --max-redirs option. When curl follows a redirect and if the request is a POST, it will send the following request with a GET if the HTTP response was 301, 302, or 303. If the response code was any other 3xx code, curl will re-send the following request using the same unmodified method. You can tell curl to not change POST requests to GET after a 30x response by using the dedicated options for that: --post301, --post302 and --post303. The method set with -X, --request overrides the method curl would otherwise select to use. -O, --remote-name Write output to a local file named like the remote file we get. (Only the file part of the remote file is used, the path is cut off.) The file will be saved in the current working directory. If you want the file saved in a different directory, make sure you change the current working directory before invoking curl with this option. The remote file name to use for saving is extracted from the given URL, nothing else, and if it already exists it will be overwritten. If you want the server to be able to choose the file name refer to -J, --remote-header-name which can be used in addition to this option. If the server chooses a file name and that name already exists it will not be overwritten. There is no URL decoding done on the file name. If it has %20 or other URL encoded parts of the name, they will end up as-is as file name. You may use this option as many times as the number of URLs you have.","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"man","slug":"man","permalink":"https://knighthana.github.io/tags/man/"},{"name":"cURL","slug":"cURL","permalink":"https://knighthana.github.io/tags/cURL/"}]},{"title":"(KM)向trusted.gpg.d中加入密钥是不安全的","slug":"(KM)向trusted.gpg.d中加入密钥是不安全的","date":"2023-04-10T16:00:00.000Z","updated":"2023-04-20T10:41:18.057Z","comments":true,"path":"KnowledgeMark/(KM)向trusted.gpg.d中加入密钥是不安全的.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)%E5%90%91trusted.gpg.d%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%AF%86%E9%92%A5%E6%98%AF%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84.html","excerpt":"","text":"向/etc/apt/trusted.gpg.d中加入密钥是不安全的 Adding a key to /etc/apt/trusted.gpg.d is insecure Adding a key to /etc/apt/trusted.gpg.d is insecure because it adds the key for all repositories. This is exactly why apt-key had to be deprecated. The proper solution is explained in that Linux Uprising article and on the Debian Wiki: Store the key in /etc/apt/keyrings/ (or /usr/share/keyrings/ if you're the package maintainer), and then reference the key in the apt source list. Warning: apt-key is deprecated. Manage keyring files in trusted.gpg.d instead 上次因为安装slack的deb包，而在apt时报过类似错误，当时也没怎么当回事（我觉得主要是被apt之前的依赖爆炸搞出心理阴影了） 这两天准备安装docker，官方的教程里面提到要添加一个docker组织的gpg-key，需要在/etc/apt/新建一个keyrings/目录，查看了/etc/apt/目录，看到其中包含trusted.gpg.d/这个目录，从字面意思理解，这是“信任的gpg-key文件目录”，疑惑为什么docker的教程要求另建一个keyrings目录，于是查找了一下trusted.gpg.d到底是做什么用的，然后看到了上面来自stackoverflow的回答 看来随便往trsuted.gpg.d里面放东西是有安全风险的，还是按照标准来比较好 2023/04/11","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"GPG","slug":"GPG","permalink":"https://knighthana.github.io/tags/GPG/"},{"name":"APT","slug":"APT","permalink":"https://knighthana.github.io/tags/APT/"}]},{"title":"2023年4月在LinuxMint上安装Docker","slug":"2023年4月在LinuxMint上安装Docker","date":"2023-04-10T16:00:00.000Z","updated":"2023-05-17T16:00:00.000Z","comments":true,"path":"Dev-Env/2023年4月在LinuxMint上安装Docker.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/2023%E5%B9%B44%E6%9C%88%E5%9C%A8LinuxMint%E4%B8%8A%E5%AE%89%E8%A3%85Docker.html","excerpt":"","text":"2023年4月在LinuxMint上安装Docker 为了以后少浪费一些时间在配环境上（上次的惨痛经历真是历历在目），另外也是学习一下先进的虚拟化技术，我打算在自己的开发用软件系统里面安装一个Docker。 安装软件一般要遵循官方给出的说明，Docker的说明文档 （少看那些上来就让人从源码编译Docker的教程，搞坏环境从无视包管理器开始） 但是这里有个很坑爹的地方，Docker.com默认诱导读者去安装\"Docker Desktop\"，我粗略看了一遍说明，这东西是一个VM，当然Docker组织也给出了一些解释——为何Docker Desktop要使用VM的形式：为了平台移植性、为了使用最新的内核（以便享受新特性）、为了提升保全性，为了最小化变更带来的不良效应； 以及，这个所谓的Docker Desktop支持的桌面环境仅仅包含KDE、Gnome、MATE，虽然他估计到了Mint用户这让人挺开心，但是这并没有照顾到我这个xfce用户啊！（摔） 越读这个说明越觉得不对劲。花了大概有二十分钟，我搞明白了，虽然这东西虽然看起来很美好，但他不是我需要的那个容器管理器Docker，仔细在页面里找了一下，传统意义上的非VM的Docker现在应该是叫Docker-Engine了 Docker Engine 这个应该就是我要找的东西了 首先这个页面特地强调了一下，适用于Debian的安装与适用于Ubuntu的安装不一样，虽然不太明白为什么， 不过既然LinuxMint是从Ubuntu那边衍生出来，而非直接从Debian衍生的，那么应该是按照Ubuntu的做法来的， （顺便了解了一下，原来还有一个LMDE项目，这个项目让Mint摆脱了Ubuntu，直接使用Debian构造Mint。但是“目前”而言应该和我没什么关系，但是假如某公司继续做让用户不高兴的事情以至于影响到这边，可能很快就和我有关系了） 通过官方指导安装 先研究一下官方文档怎么说的，之后再通过镜像站安装 第一步，卸载旧版本的Docker 1sudo apt-get remove docker docker-engine docker.io containerd runc 由于没有安装过Docker，所以这一步对我没有意义。 此外 Images, containers, volumes, and networks stored in /var/lib/docker/ aren’t automatically removed when you uninstall Docker. If you want to start with a clean installation, and prefer to clean up any existing data, read the uninstall Docker Engine section. 懒得翻译，反正就是关于/var/lib/docker/里面的文件，自己决定要不要保留 第二步，准备GPG的安装环境 GPG是一套密钥方案，Ubuntu下的APT使用它来管理软件包的密钥，Mint也不例外。 123456sudo apt-get updatesudo apt-get install \\ ca-certificates \\ curl \\ gnupg 第三步，安装Docker组织的密钥 下载 123sudo mkdir -m 0755 -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg 安装 1234echo \\ \"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ \"$(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\")\" stable\" | \\ sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null FAQ：GPG权限错误 如果GPG密钥文件的权限错误，可能会有问题，这通常是由于umask设置错误导致的 通过下列命令解决文件没有读取权限的问题 123sudo chmod a+r /etc/apt/keyrings/docker.gpgsudo apt-get update 第四步，安装Docker 1sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 最后，检查安装情况 1sudo docker run hello-world 输出部分应当首先开始下载一个容器 之后应当展示一个欢迎页面 按照官方给出的指导，到这一步安装就算完成了 通过国内的镜像站安装 事实上这一部分才是国内用户需要看的。 参阅tuna协会关于docker-ce镜像的说明，整理如下 卸载旧版本的docker 1sudo apt remove docker docker-engine docker.io containerd runc 安装必要的工具 1sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common gnupg和gnupg2应该是有一个就足够的 创建钥匙环保存目录(如果已有keyrings/就不用创建) 1sudo mkdir -m 0755 -p /etc/apt/keyrings 下载并安装docker.com的gpg密钥 1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg 前一个指令下载了来自\"docker.com\"的密钥 后一个指令生成了二进制密钥，并将二进制密钥以名称docker.gpg存放在了之前建立的钥匙环保存目录中。 (名字只是一个代号，不过，如果这里不用docker.gpg这个名字，待会sourcelist里面也要对signed-by的参数做对应的修改) 在sources.list.d目录中创建一个镜像源配置文件 用tuna协会提供的一条命令搞定 123echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 手动创建方式 目前阶段我不是很喜欢上一种方式，作为一个希望尽可能多了解这个系统的人，我需要尽可能搞清楚这条命令中每个部分的含义，然后手动完成 在熟练之后，我会使用尽可能节省时间的方式完成这样的任务 但是tuan提供的这条命令给了很多参考，可以直接拿来使用 手动创建源列表的步骤如下： 在/etc/apt/sources.list.d/中创建一个文件，命名为docker.list(名字只是一个代号，但是建议命名为docker.list方便之后查找和修改) 然后查询： 正在使用的计算机系统CPU架构 1dpkg --print-architecture 正在使用的操作系统代号 1lsb_release -cs 前一个一般为amd64，当然，如果对于当年惨兮兮没有趁手计算机用的我来说也有可能是i386或者i686； 对于Ubuntu用户，后一个可能是trusty xenial bionic focal jammy kinetic 但是对于我这样的LinuxMint 21.1用户，这个选项的输出是vera，稍稍回忆一下，LinuxMint版本vera对应的Ubuntu版本是jammy 然后在docker.list中输入以下内容，注意替换其中的带引号的中文字符为对应的内容(连左右两侧的引号一起替换，替换后的内容不再带引号)，然后保存 1deb [arch=\"CPU架构\" signed-by=/etc/apt/keyrings/docker.gpg] https://\"你所使用的镜像源网站docker-ce的目录/linux/你所使用的发行版\" \"操作系统代号\" stable 特别地，对于Mint用户，请使用ubuntu的仓库，并且\"操作系统代号\"使用对应的ubuntu代号 比如一个来自XDU的学子，恰巧也是Mint21.1、或者Mint21用户，那么这里就应该写 1deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://linux.xidian.edu.cn/mirrors/docker-ce/linux/ubuntu jammy stable 来自Mint参考文件的版本对应表格 VERSION CODENAME PACKAGE BASE 21.1 Vera Ubuntu Jammy 21 Vanessa Ubuntu Jammy 20.3 Una Ubuntu Focal 20.2 Uma Ubuntu Focal 20.1 Ulyssa Ubuntu Focal 20 Ulyana Ubuntu Focal 19.3 Tricia Ubuntu Bionic 19.2 Tina Ubuntu Bionic 19.1 Tessa Ubuntu Bionic 19 Tara Ubuntu Bionic 5 Elsie Debian Bullseye 软件源文件中的代号一律使用小写字母 对于LMDE用户，则需要使用Debian仓库以及对应的Debian代号， 比如一个XDU的LMDE5用户在文件里就应该写 1deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://linux.xidian.edu.cn/mirrors/docker-ce/linux/debian bullseye stable 更新源数据库并安装docker 12sudo apt updatesudo apt install docker-ce 检查安装是否成功 1sudo docker run hello-world 这将会打印一条很长的提示信息 至此，docker(非VM)安装就完成了。 注意，每运行一次上面这个命令，都会创建一个新的容器 如果想要清理这些运行docker run后创建的容器文件，可以先 1docker container ls -a 检查目前所有容器的列表 然后运行 1docker container rm $容器名称 来删掉它们 Docker的可用性配置 参考1 | 菜鸟教程 参考2 | 菜鸟教程 参考3 | digitalocean Docker镜像设置 由于我使用的是基于Debian的Ubuntu的LinuxMint，使用systemd 那么对应需要修改的镜像配置文件是 1/etc/docker/daemon.json 这是一个json文件(若无需要新建)，加入以下内容 123456{ \"registry-mirrors\":[ \"https://$mirrorsiteA\", \"https://$mirrorsiteB\" ]} 重启docker守护进程 12sudo systemctl daemon-reloadsudo systemctl restart docker 注意，对于systemd操作系统而言，并不是修改/etc/default/docker 反正我改了没效果 修改Docker组成员 由于我们是通过系统的包管理器安装的Docker 默认存储目录的所有者都是root，需要将我们自己加入用户组docker之后，才可以不借超级用户身份就执行操作 1sudo usermod -aG docker $USER 之后需要登出登入一遍，让针对用户组文件的修改生效 然后，以本用户的身份使用docker应该就畅行无阻了 Knighthana 2023/04/11 动笔 2023/04/13 完稿 2023/05/15 第一次更新 2023/05/18 第二次更新","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"LinuxMint","slug":"LinuxMint","permalink":"https://knighthana.github.io/tags/LinuxMint/"},{"name":"2023","slug":"2023","permalink":"https://knighthana.github.io/tags/2023/"},{"name":"Docker","slug":"Docker","permalink":"https://knighthana.github.io/tags/Docker/"}]},{"title":"解决apt update时出现key is stored in legacy trusted.gpg keyring问题","slug":"key_is_stored_in_legacy_trusted.gpg_keyring问题","date":"2023-04-10T16:00:00.000Z","updated":"2023-04-20T10:29:39.167Z","comments":true,"path":"Dev-Env/key_is_stored_in_legacy_trusted.gpg_keyring问题.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/key_is_stored_in_legacy_trusted.gpg_keyring%E9%97%AE%E9%A2%98.html","excerpt":"","text":"解决apt update时出现Key is stored in legacy trusted.gpg keyring的问题 这个问题是因为/etc/apt/trusted.gpg中包含了过时的密钥导致的 典型如Slack，2023年4月份仍然在使用一个2019年就过期的密钥 找到了一篇文章，通过向trusted.gpg.d/中添加了一个密钥文件，解决了这个问题。 虽然麻烦（感觉……不如手动编译软件包），但是我不想在自己使用的开发环境里面埋雷。 奇怪的是，这些步骤里面没有移除过时密钥的操作，但是好像它确实不报错了，也不知道到底是解决了还是怎么回事。 此外，放在trusted.gpg.d/,感觉还是不安全，但是slack的更新规则又不是我写的，所以对此暂时没有办法。 也许可以参照docker的方案，新建keyrings\\目录保存密钥，在list文件里面写清楚信赖关系什么的，但是既然Slack官方没这么做，也许有什么原因（也许只是因为懒）。 参考： 中译本： 修复 Ubuntu 中的 “Key is stored in legacy trusted.gpg keyring” 问题 原版： Fixing \"Key is stored in legacy trusted.gpg keyring\" Issue in Ubuntu Knighthana 2023/04/11","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"GPG","slug":"GPG","permalink":"https://knighthana.github.io/tags/GPG/"},{"name":"APT","slug":"APT","permalink":"https://knighthana.github.io/tags/APT/"},{"name":"LinuxMint","slug":"LinuxMint","permalink":"https://knighthana.github.io/tags/LinuxMint/"},{"name":"Slack","slug":"Slack","permalink":"https://knighthana.github.io/tags/Slack/"}]},{"title":"遗传算法是一种搜索算法","slug":"遗传算法是一种搜索算法","date":"2023-04-10T16:00:00.000Z","updated":"2023-04-19T14:07:58.862Z","comments":true,"path":"subject-note/遗传算法是一种搜索算法.html","link":"","permalink":"https://knighthana.github.io/subject-note/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%98%AF%E4%B8%80%E7%A7%8D%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html","excerpt":"","text":"遗传算法的本质是一种搜索算法 之前的文章《计算智能课上遗留遗传算法问题的课后思考》中较为详细地解释了何为遗传算法，如何用遗传算法解决一个简单的最大值问题。 当时以为自己已经掌握了一些遗传算法的入门知识，然而，经过接下来一节课对思想的冲击，我现在发现对这些东西的理解还是太肤浅了。 正如题目所说，“遗传算法的本质是一种搜索算法”，虽然这样的结论对于刚刚接触遗传算法的人来说看起来很奇怪，但是稍微深入地学习思考一下，就会发现，解决遗传算法问题的时候，在基因编码、交叉、突变方面绕了一大圈，其实我们一直在做的工作是搜索！ （因为大鸽子的时间不够了所以下面的部分之后再写） Knighthana 2023/04/11 Script","categories":[{"name":"subject-note","slug":"subject-note","permalink":"https://knighthana.github.io/categories/subject-note/"}],"tags":[{"name":"遗传算法","slug":"遗传算法","permalink":"https://knighthana.github.io/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"},{"name":"计算智能","slug":"计算智能","permalink":"https://knighthana.github.io/tags/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD/"}]},{"title":"(KM)解决Git中中文显示为8进制编码的问题","slug":"(KM)MakeGitChineseNameNormal","date":"2023-04-08T16:00:00.000Z","updated":"2023-04-20T10:54:04.923Z","comments":true,"path":"KnowledgeMark/(KM)MakeGitChineseNameNormal.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)MakeGitChineseNameNormal.html","excerpt":"","text":"解决Git中中文显示为8进制编码的问题 Git会将编码大于0x80的字符进行转码显示 通过 git config --global core.quotepath false 改变git的全局设定 这样就可以令Git显示中文了 git环境下中文显示转义乱码 设置GIT显示中文名 2023/04/09","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://knighthana.github.io/tags/Git/"},{"name":"CJK","slug":"CJK","permalink":"https://knighthana.github.io/tags/CJK/"}]},{"title":"一些程序设计基础与编译原理课程方面的常识","slug":"一些程序设计基础与编译原理课程方面的常识","date":"2023-04-08T16:00:00.000Z","updated":"2023-04-20T06:07:06.404Z","comments":true,"path":"subject-note/一些程序设计基础与编译原理课程方面的常识.html","link":"","permalink":"https://knighthana.github.io/subject-note/%E4%B8%80%E4%BA%9B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E6%96%B9%E9%9D%A2%E7%9A%84%E5%B8%B8%E8%AF%86.html","excerpt":"","text":"一些程序设计基础与编译原理课程方面的常识 介绍一些来自编译原理的常识 可能这些常识对于只有程序设计基础知识、但是对此好奇的人来说很头痛，因为分不清，搞不明白，查了资料也是一知半解； 但是它们在编译原理中仅仅只是前导内容，因此现在把它整理出来，用明了的方式解释清楚，让更少的人为此头痛； 当然，最准确的解释还是得看书本，我这样用一种直观地方式解释，其实只注重在“明了”方面的程度，肯定会有失准确性；如果有人觉得有更好的、兼备明了与准确性的措辞欢迎与我交流； 编译器 VS 解释器 提到编译器不要立刻想到源代码变成汇编语言，就想到机器语言代码，就想到一串1111111100001001000，然后就迷失得找不到自我了，然后再看解释器，由于人已经处在混沌之中，就会觉得这东西长得和编译器很像什么的； 先别慌，先把这两个词分清，一个叫“编译器”，另一个叫“解释器”； “编译器”其实并不局限于将高级语言的源代码编译成为机器语言代码(或者先编译成汇编语言代码，再交由汇编程序转换成机器码)这一种功能，因为编译器其实可以理解成“翻译器”，它具有更加强大的功能 所谓编译器，要做的就是把源语言的程序代码“翻译成为”目标语言的程序代码，就这么简单；源语言可以是高级语言，但也可以是汇编语言，目标语言可以是机器语言，但是也可以是别的什么，甚至可以是高级语言，编译器只是负责把一种语言翻译成另一种语言，仅此而已； 而解释器是一个程序，它被用户调出来之后就一直在运行着，当接收到用户的输入之后，它就会按照用户的输入去做各种工作，只不过这里的输入恰好是某种可以被解释解释的程序设计语言以及此时用户的现场输入；解释器也不会产生所谓“目标代码”的东西，因为它从一开始就根本不是为了这个用途这么设计的；解释器很像一双手套，“运行”由高级语言设计的逻辑意义上的程序时，还是没有脱离这个解释器，解释器还是在主存里面待着，CPU认的也是解释器而不是什么逻辑意义上的高级语言程序； “有没有目标代码”这一个区别是从用途来很清楚明了地解释这个问题， 形象化一点地理解，假如有一种程序设计语言既可以被编译执行，也可以被解释执行，那么使用编译器把某种语言的源代码翻译成了机器语言的代码文件，和用解释器去解释源代码文件执行各种动作——这也是最常见的用法，这二者会有的一个显著区别就是：所需要执行的这种动作由谁来完成； 如果是编译得到的机器语言代码文件，那么就是编译得到的由机器语言编写的二进制文件自己在执行这些动作，也就是说，什么时候将这个机器语言代码文件装入内存，把它的首地址装入程序计数器，让CPU把它执行起来，它才会在什么时候开始发挥作用，要等它开始跑了，再往里面灌输入等着它给输出； 对应地，解释器那边，需要先把解释器装入主存，把解释器在主存的首地址装入程序计数器，让它开动起来，有了一个解释器的运行时，然后往解释器里面灌代码以及输入，解释器会作为一个“手套”去执行这些动作并给出输出； 这样一看，这两个东西从根源上就如此地不同，仅仅只是“同样都可以用来让高级语言的源代码发挥作用”，就被狠狠地混淆了； AOT VS JIT AOT：Ahead Of Time JIT：Just In Time AOT和JIT都是编译器范畴的，没错，可能会在一些解释型程序设计语言那边看到“JIT”这种概念，但是这俩都是属于编译执行的；理解这个概念需要先清清楚楚明明白白地把什么是“编译”什么是“解释”搞懂； AOT这种方式只有对代码进行编译才能做到； JIT则很具有迷惑性： 一般来说会弄混的情况是Java，这个特立独行的语言支持先将Java高级语言源代码编译成为“字节码”，这一步是纯粹的编译；再交给“Java Runtime”（各个品牌的JRE都算Java Runtime的，现在2023年比较流行的两种是Oracle的JRE和OpenJDK的JRE）这个虚拟机负责解释执行，这一步又变成了解释； 在Java高级语言到字节码这一步，全都毫无疑问地是编译，全都是“AOT”，虽然这个“Time”并不是真正执行它的“Time”，但假如我们说拿到字节码这一步就算跑完了，那就是； 然而，在运行起来服务人类期间如何解释字节码里面的东西的时候，不同的运行时搞出了不同的玩法； 传统解释型的就是作为解释器，把字节码作为一种需要解释的程序设计语言，和输入一起灌进虚拟机扮演的解释器，解释器解释明白了，就会执行各种动作，给出输出； 然而JRE还有一个流派就是JIT，这个流派的运行时会在处理输入的前一刻将字节码编译成为机器语言，然后去执行这个机器语言程序，让这个新鲜出炉的机器语言程序执行各种动作，给出输出，而不是自己去执行动作或者给输出； 那么其它的经常用于解释型的程序设计语言为什么也会有JIT呢？ 用JRE的这个过程去看，JRE是接收字节码和输入，然后用不同的方式，也即“解释执行”和“JIT”两种方式给出执行与输出； 这些解释型程序设计语言的RE也是类似的，只不过它们接收由高级语言编写的人可以看懂的程序代码输入，随后，不同的流派用不同的方式给出了执行与输出，其中解释派是单纯地用解释器进行解释，而JIT派则是在拿到输入，确定类型之后即刻开始编译得到机器语言代码，然后把机器语言代码装入主存，由机器码去做交给它的工作； 静态 VS 动态 静态：Static 动态：Dynamic 静态类型、动态类型、强类型、弱类型，十分混沌邪恶的四个维度； 今天不扯这些，我们只说“静态”和“动态”是什么场景，剩下的自己慢慢想； 这里掉一下书袋，来自CPTT机械工业出版社中译本第2版P15对于“静态”和“动态”的解释，我觉得我来解释一遍也不如原书的明了： 如果一个语言使用的策略支持编译器静态决定某个问题，那么我们就说这个语言使用了一个静态策略(static policy)，或者说这个问题可以在编译时刻(compile time)决定； 一个只允许在运行程序的时候作出决定的策略被称为动态策略(dynamic policy)，或者被认为需要在运行时刻(run time)作出决定。 与原书不同，我把动态策略也完全翻译成了static policy，以与下面的dynamic policy对应相照 所以说，静态策略的语言能够在编译时敲定一些东西，比如变量的类型之类的，这样可以将程序的机器代码在执行之前就完全编译出来，运行的时候效率就会比较高； 反之，动态策略的语言无法在编译时敲定这些东西，比如还是变量的类型这个例子，它必须等到运行的时候，用户给进来一个输入，这时候才能确定，哦原来是这么个类型，很显然，这样的策略给代码编写带来了很大的灵活性，比如某些脚本语言的变量类型就可以一会一变；但是有利就有弊，使用这种策略的语言在处理输入的语句中必须拿到用户的输入才能确定类型，才能进行下一步，于是很明显地，这种语言设计出来的玩意想要在用户调用之前提前编译好是有难度的； 原书下面还提了一下“静态”与“动态”的“作用域”，作用域、命名空间什么的，这几个东西算是同一个范畴，且看原书的解释： x的一个声明的作用域是指程序的一个区域，在其中对x的使用都指向这个声明； 如果仅通过阅读程序就可以确定一个声明的作用域，那么这个语言使用的是静态作用域(static scope)，或者说词法作用域(lexical scope)。 否则，这个语言使用的是动态作用域(dynamic scope)。如果使用动态作用域，当程序运行时，同一个对x的使用会指向x的几个声明中的一个。 大部分语言(比如C和Java)使用静态作用域。 注意，C里面对“同一个”变量名给出不同层次的声明可不是动态作用域，因为C的代码通过阅读便能了解此刻用的是“这个名字”的哪个声明（其实本质上完全是不同的变量），比如局部变量的优先级就比全局变量的优先级要高，这些都不需要等到运行起来了再做判断，编译时就能敲定，给出一个强硬的相关关系； 动态作用域会在声明时带上变量使用时间的信息，这样真的除了在运行的时候确定以外别无他法； 声明 VS 定义 这种问题一般会用来考验可怜的大一新生freshman，当然，对这个问题的了解程度不同，给出的答案也不同，这种东西向来是答错了也不要紧，能体现出了解程度就行，也就是有区分度即可； 比如我当年被问到这个问题的时候扯了半天的“内存”什么的，其实当时的回答也不能算完全对，但是有区分度也就行了； 声明用来确定一个事物的类型； 定义用来确定一个事物的值； 就这么简单； 注意，这里说的是“事物”，并没有说是“变量”，也就是说，变量和过程(C中称作函数的那个，OOPL——面向对象程序设计语言里面唤作方法的那个)都是有自己的“声明”和“定义”的； 奇妙吧？多学习，以后还有更奇妙的 结点 VS 节点 一个普通程序员搞不清结点和节点可能比较正常，但是作为科班出身的计算机领域工作者，必须搞清楚结点和节点，不要在自己写的东西里面闹笑话； 结点是一个存储单元，链表的结点是一个“结点”，树的“结点”是一个结点，这些结点里面可能存了变量名、地址指针之类的东西，但是，结点自身是一个静态的东西，如果外力不去更改它，它不会乱动； 节点与结点完完全全不同，节点带有计算能力，甚至有自己的维护能力，我们可以说一个大型分布式处理器中的一个运算单元是一个节点，也可以说一个由一堆嗡嗡作响的服务器和一群运维人员组成的大型数据中心是一个节点，但唯独不会说一段内存中的静止数据是“节点” Knighthana 2023/04/09","categories":[{"name":"subject-note","slug":"subject-note","permalink":"https://knighthana.github.io/categories/subject-note/"}],"tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://knighthana.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"编译原理","slug":"编译原理","permalink":"https://knighthana.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"计算机程序设计","slug":"计算机程序设计","permalink":"https://knighthana.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"编译原理语法分析一节中的一些疑问与思考","slug":"编译原理语法分析一节中的一些疑问与思考","date":"2023-04-08T16:00:00.000Z","updated":"2023-04-20T06:09:37.811Z","comments":true,"path":"subject-note/编译原理语法分析一节中的一些疑问与思考.html","link":"","permalink":"https://knighthana.github.io/subject-note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%80%E8%8A%82%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E9%97%AE%E4%B8%8E%E6%80%9D%E8%80%83.html","excerpt":"","text":"编译原理语法分析一节中的一些疑问与思考 “向前看”符号是啥 输入中当前被扫描的终结符号通常被称为“向前看”符号； 在开始时，向前看符号是输入串中的第一个(即最左的)终结符号； 向前看符号被用以确定应该使用哪个产生式，如果向前看符号在FIRST(α)中，就使用α，如果向前看符号在FIRST(β)中，就使用β； 个人理解，向前看符号只是被拎出来，备着解释后面的避免回溯时用到的“消除公共左因子法”用的，当然，在这里来看，向前看符号是一种分割，表示现在只处理向前看符号后面的非终结符，不管前面的部分了； 预测分析法相比一般的自顶向下分析法，其无需回溯的优点是如何获取的？ “回溯”本身就是因为备选的产生式集合中各个产生式具有公共左因子导致的，当不确定应该对一个非终结符号使用哪一个产生式的时候，就只能猜测着一个个地试过去，假如试错了，那就只能回溯，最后要么有一个产生式可以与之对应，要么完全找不到，假如没有任何产生式能解释这个字符串，那么就只能认为输入的字符串有语法错误； 预测分析法用了一个“消除公共左因子”的技巧，经过这个处理之后，构建的产生式集合中任意两个不同的产生式不再会含有公共左因子，那么编译的时候遇到这种情况就不再需要试错了，直接用那个对应的产生式就可以了，于是就消除了回溯的问题； 消除公共左因子的方法是，将含有公共左因子的产生式体集合中，所有的产生式体最左侧的那个终结符号单独提出来，让剩下的部分构成另一些产生式的体，这样就将含有公共左因子的产生式集合拆分成了逻辑上的两部分，其中一部分负责让外部原本犹豫的挑选者进入这个集合，另一部分向挑选者给出真正有区分度的选项以供选择； 举个例子说明， 对于 1A→αβ|αγ 这样具有公共左因子α的产生式，将其转化为 12A→αA'A'→β|γ 的产生式形式，就能够让选择者不再犹豫，直接选出正确的结果； 语法分析树 VS 抽象语法树 这又是一个Versus问题； 语法分析树 先说语法分析树，因为这个是最先接触到的； 语法分析树用图形方式展现了从文法开始符号推导出相应语言中的符号串的过程，如果非终结符号A有一个产生式A→XYZ，那么在语法分析树中就可能有一个标号为A的内部结点，该结点有三个子结点，从左到右的标号分别是X、Y、Z； 插图画不出来，自行想象一个有三个叶子的树，根结点是A，叶子结点分别是X，Y，Z 当然，留意原文说的是“内部结点”和“子结点”，并没有说这就是一棵树，因为它可能仅仅是一棵树内部的一部分； 正式地讲，给定一个上下文无关文法，该文法的一棵语法分析树是具有以下性质的树 根结点的标号为文法的开始符号； 每个叶子结点的标号为一个终结符号或ε； 每个内部结点的标号为一个非终结符号； 如果非终结符号A是某个内部结点的标号，... 第四条可以自己去找本CPTT，翻到P28去看，我懒得把原文那么长一段话打上去了，大意就是，树长什么样那么产生式就是啥样，假如说某非终结符号A的产生式仅仅有一个A→ε，那么这个树就有一个内部结点A的叶子是ε； 最后，语法分析树又被称作具体语法树 抽象语法树 抽象语法树是那个经常被简称为“语法树”的树，而且也正是那个大名鼎鼎的“AST” 抽象语法树是一种数据结构，在设计一个翻译器时，抽象语法树是一个很好的起点。 在一个表达式的抽象语法树中，每个内部结点代表一个运算符，该结点的子结点代表这个运算符的运算分量。 一棵语法树中的每个结点代表一个程序构造，这个结点的子结点代表这个构造中有意义的组成部分，表达式E₁+E₂的语法树根结点的标号为+，且两个子结点分别代表子表达式E₁和E₂； 我们将使用具有适当数量的字段的对象来实现一棵语法树的各个结点；每个对象将有一个op字段，也就是这个结点的标号，这些对象将具有如下所述的其他字段： 如果结点是一个叶子，那么对象将有一个附加的域来存放这个叶子结点的词法值，构造函数leaf(op,val)创建一个叶子对象，我们也可以把结点看做记录，那么leaf就会返回一个指向与叶子结点对应的新记录的指针； 如果结点是一个内部结点，那么它的附加字段的个数和该结点在语法树中的子结点个数相同，构造函数Node带有两个或更多参数：Node(op,c₁,c₂,...,ck)，该函数创建一个对象，第一个字段的值为op，其余k各字段的值为c₁,...,ck 简单来说 简单来说： 在抽象语法树中，内部结点代表的是程序构造； 在语法分析树中，内部结点代表的是非终结符号； Knighthana 2023/04/09","categories":[{"name":"subject-note","slug":"subject-note","permalink":"https://knighthana.github.io/categories/subject-note/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://knighthana.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"lookahead","slug":"lookahead","permalink":"https://knighthana.github.io/tags/lookahead/"},{"name":"top-down","slug":"top-down","permalink":"https://knighthana.github.io/tags/top-down/"},{"name":"predictive parsing","slug":"predictive-parsing","permalink":"https://knighthana.github.io/tags/predictive-parsing/"},{"name":"具象语法树","slug":"具象语法树","permalink":"https://knighthana.github.io/tags/%E5%85%B7%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/"},{"name":"抽象语法树","slug":"抽象语法树","permalink":"https://knighthana.github.io/tags/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/"},{"name":"AST","slug":"AST","permalink":"https://knighthana.github.io/tags/AST/"}]},{"title":"安装Torch","slug":"安装Torch","date":"2023-04-04T16:00:00.000Z","updated":"2023-04-20T06:15:17.246Z","comments":true,"path":"Dev-Env/安装Torch.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E5%AE%89%E8%A3%85Torch.html","excerpt":"","text":"安装Torch 需要安装一下Torch，记录一下过程。 首先打开toch的官方网站 然后找到安装指导 根据指导，首先要运行 1git clone https://github.com/torch/distro.git ~/torch --recursive git clone是很熟悉的命令，但是后面说要安装在~目录中，这多少让人感觉有点难顶，我并不是很想在自己的家目录下面弄出一堆文件夹来，但是初来乍到，还不清楚乱改目录会不会造成兼容问题，所以只能先允许它这么干 这里需要注意的是，这一段要求通过 github.com 下载代码，鉴于国内特有的GitHub那个时灵时不灵的连接，对于这种大项目建议备好终端下的正常通信程序再执行clone，不然下到一半连接断了，项目又没有验证程序，基本就得重新下载了 UNIX的习惯是“没有提示就是没有报错”，不过torch安装完毕之后会提示子模块路径'pkg/xxxx':检出'xxxxxxxxxxxxxxxxxxxx'，这种状况我不太熟悉，稍稍找了一下，应该是某个检查模块的正常输出，那么安装已经成功了 接下来照着指示进入~/torch目录，运行 1bash install-deps ，即便这条命令是在安装软件，也不需要sudo，在脚本被bash解释之后会单独要求输入密码的 我之前已经提前准备好了lua5.4和luarocks，这里只需要解决其他的依赖就可以了 (按照文档的说法，torch使用的是LuaJIT而非通常的Lua，如果要改成Lua，还要给install.sh输入一条额外的环境变量，然而我懒得做，而且用LuaJIT什么的不是更好吗) 这里包管理器提示有一个包找不到了，不过这个包可以通过software-properties-common替代，遂手动安装；考虑到torch最后一次更新是2017年，只有一个包找不到还真是不错呢(棒读)； 另外，安装torch还需要cmake，但cmake并不是一个必定安装的软件，然而这点既没有在指导文档里面说明，也没有通过install-deps脚本解决，幸好报错里面提到了，手动安装cmake解决。 然后再按照说明执行 1./install.sh ，等待编译安装完成 另外，安装完毕之后，th命令不会立刻起作用， 要么 1source ~/.zshrc （这条命令具体是什么取决于你所使用的shell种类，详见官方说明）， 要么退出终端重进一次，我选择了后者，然后痛失上面的所有提示信息(重定向一个log文件实在是太有必要了) 在shell识别到带有torch的$PATH之后，运行th就可以看到torch的界面啦 1234567 ______ __ | Torch7 /_ __/__ ________/ / | Scientific computing for Lua. / / / _ \\/ __/ __/ _ \\ | Type ? for help /_/ \\___/_/ \\__/_//_/ | https://github.com/torch | http://torch.ch th&gt; 接下来应该就要面对来自Lua的会心一击了 Knighthana 2023/04/05","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"},{"name":"Torch","slug":"Torch","permalink":"https://knighthana.github.io/tags/Torch/"},{"name":"Lua","slug":"Lua","permalink":"https://knighthana.github.io/tags/Lua/"}]},{"title":"某几个常见分布的“无后效性”","slug":"某几个常见分布的“无后效性”","date":"2023-04-04T16:00:00.000Z","updated":"2023-04-19T13:35:23.591Z","comments":true,"path":"subject-note/某几个常见分布的“无后效性”.html","link":"","permalink":"https://knighthana.github.io/subject-note/%E6%9F%90%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E5%88%86%E5%B8%83%E7%9A%84%E2%80%9C%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7%E2%80%9D.html","excerpt":"","text":"某几个常见分布的“无后效性” 在概率论与数理统计课程的学习中，一般都会了解到指数分布具有“无后效性”，或者说无记忆性这样一个性质，例如一件产品的寿命符合指数分布，那么何时检查它的寿命，得到的结果和它已经工作了多久是无关的； 到了随机过程部分内容的学习，学到了“马尔科夫链”这个重要且强大的分析工具，还有它所提供的诸如“一步状态转移概率矩阵”这样的能够将问题抽象到可以用数学工具方便地解决的程度的模型 那么不妨进行一些数学工作，找出并证明一些常见分布具有“无后效性”的性质，这样对于具有这些分布的随机过程运用起“马尔科夫链”来就不会犯嘀咕了 几何分布的无后效性 几何分布 需要证明 证明： 等式左边 等式右边 于是，等式左边=等式右边，证毕 负指数分布的无后效性 对于 有 需要证明 证明： 等式左边 等式右边 于是，等式左边=等式右边，证毕 泊松过程(搁置) 泊松过程的公式和泊松分布的公式不太一样，暂时搁置 Knighthana 2023/04/05","categories":[{"name":"subject-note","slug":"subject-note","permalink":"https://knighthana.github.io/categories/subject-note/"}],"tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://knighthana.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"随机过程","slug":"随机过程","permalink":"https://knighthana.github.io/tags/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/"},{"name":"马尔可夫链","slug":"马尔可夫链","permalink":"https://knighthana.github.io/tags/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/"}]},{"title":"用牛顿-拉弗森迭代法求解平方根及其他","slug":"牛顿-拉弗森方法","date":"2023-04-01T16:00:01.000Z","updated":"2023-04-20T06:18:11.985Z","comments":true,"path":"subject-note/牛顿-拉弗森方法.html","link":"","permalink":"https://knighthana.github.io/subject-note/%E7%89%9B%E9%A1%BF-%E6%8B%89%E5%BC%97%E6%A3%AE%E6%96%B9%E6%B3%95.html","excerpt":"","text":"用牛顿-拉弗森迭代法求解平方根及其他 牛顿-拉弗森方法是个很有用的方法，在没有计算器需要手算一些式子的时候，其它的运算可能只是需要多花点时间，但对于开平方一类运算必须要有一个数学工具才能开始求解 即便这个方法如此重要，我还是总会忘记，我记得高中的时候受“卡马克魔数”的影响，明明用C写过一个迭代法开平方的程序，还专门和系统自带的sqrt()函数比较过运行速度，但是如今又是全都忘了 今天就找资料，重新学一下这个东西。 核心的公式 手算开平方，核心的公式就一个： 选择一个接近平方根的值作为 代入 开始第一遍计算，获得等式左边 的值，将 代入右侧算式得到 的值，之后每次计算都会更接近 的解 几何过程，试着理解 是函数的图像， 对于 ， 点是表示函数在 处取值的点 是斜率与函数图像在 点处斜率的相等的一条直线 过定点直线的方程 那么， 就是一条过函数图像上(x_0,y_0)处与函数图像相切的直线 求出直线与x轴的交点，也就是直线对应的方程在 时的解，这个值是 然后对 重复一遍上述过程得到 例如，对于 求x的平方根 先将其转换成 的形式 猜想解在1附近，于是假设 画一张图看看 fg1 然后根据直线与x轴的交点，代入 ，再画一张图 fg2 可以看到，随意取了一个1，仅仅经过两次迭代，就快速逼近了真正的解 这个方法既适合手算，也适合编程序去计算 其他 事实上，牛顿-拉弗森方法是用函数 的泰勒级数的前几项来寻找方程 的根 这个方法还可以用于其他方程的求解，式子是这样的 这个式子是有使用条件的 此外，这个方法还可以用于求极值点 Knighthana 2023/04/02 参考资料 [1] 如何通俗易懂地讲解牛顿迭代法？ https://www.matongxue.com/madocs/205/ [2] 牛顿法 https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95 [3] 有趣数学-Bilibili https://www.bilibili.com/video/BV1KT4y1N7Sq/ [3'] Newton-Raphson method | Animated and explained | Algorithm for finding roots of a function Youtube https://www.youtube.com/watch?v=qlNqPE_X4ME Tag Newton-Raphson; sqrt(); Carmack","categories":[{"name":"subject-note","slug":"subject-note","permalink":"https://knighthana.github.io/categories/subject-note/"}],"tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://knighthana.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Math","slug":"Math","permalink":"https://knighthana.github.io/tags/Math/"},{"name":"Newton-Raphson","slug":"Newton-Raphson","permalink":"https://knighthana.github.io/tags/Newton-Raphson/"},{"name":"sqrt()","slug":"sqrt","permalink":"https://knighthana.github.io/tags/sqrt/"},{"name":"Carmack","slug":"Carmack","permalink":"https://knighthana.github.io/tags/Carmack/"}]},{"title":"为什么不合并A和E两个状态","slug":"编译原理第2版99页-为什么不合并A和E状态","date":"2023-04-01T16:00:00.000Z","updated":"2023-04-20T06:19:44.913Z","comments":true,"path":"subject-note/编译原理第2版99页-为什么不合并A和E状态.html","link":"","permalink":"https://knighthana.github.io/subject-note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC2%E7%89%8899%E9%A1%B5-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%88%E5%B9%B6A%E5%92%8CE%E7%8A%B6%E6%80%81.html","excerpt":"","text":"为什么不合并A和E两个状态 / 为什么不合并A,C,E状态 - 编译原理第2版99页 注意到前述DFA D的状态转换表 NFA状态 DFA状态 a b {0,1,2,4,7} A B C {1,2,3,4,6,7,8} B B D {1,2,4,5,6,7} C B C {1,2,4,5,6,7,9} D B E {1,2,4,5,6,7,10} E B C 中，A、C、E都具有相同的转换 1234Dtran[A,a]=BDtran[A,b]=CDtran[C,a]=BDtran[C,b]=C 12Dtran[E,a]=BDtran[E,b]=C 但是，为什么只能说A、C具有相同的状态？ 因为在P115，“最小化一个DFA的状态数量”一节 最小化DFA状态数量的第一步是，将包含有所有DFA状态的集合分为两个组，分别是接收状态组和非接受状态组 之后根据状态转换表不断分割与合并 DFA D的A、C、E三个状态中，E是接收状态组，A、C是非接受状态组， 这意味着如果输入状态机的串最终于E状态停止，那么就可以接受这个串，如果到达不了E，或串结束状态机时不在状态E，那么这个串就会被拒绝 于是E和AC从一开始就根本不能划分到同一个组中，也就无从谈起合并这三个状态 Knighthana 2023/04/02","categories":[{"name":"subject-note","slug":"subject-note","permalink":"https://knighthana.github.io/categories/subject-note/"}],"tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://knighthana.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"编译原理","slug":"编译原理","permalink":"https://knighthana.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"书页相关","slug":"书页相关","permalink":"https://knighthana.github.io/tags/%E4%B9%A6%E9%A1%B5%E7%9B%B8%E5%85%B3/"}]},{"title":"重新配Linux环境痛苦的经历","slug":"重新配Linux环境痛苦的经历","date":"2023-03-31T16:00:00.000Z","updated":"2023-04-12T16:00:00.000Z","comments":true,"path":"Dev-Env/重新配Linux环境痛苦的经历.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E9%87%8D%E6%96%B0%E9%85%8DLinux%E7%8E%AF%E5%A2%83%E7%97%9B%E8%8B%A6%E7%9A%84%E7%BB%8F%E5%8E%86.html","excerpt":"","text":"重新配Linux环境，痛苦的经历 含有情绪输出 Linux&amp;Windows双系统 系统时钟 当Linux操作系统和Windows操作系统在同一个主板上工作时，会出现系统时钟不一致的情况（除非身处格林威治时区）； 为了不要让它们把系统时钟改来改去打架，必须统一它们对系统时间的读写方式； Linux会把主板时间识别且修改为UTC，然后根据时区设置给出一个加减小时之后的软时钟； Windows会把主板时间识别为本地时间，如果身处东八区的话，那么BIOS时间就被认为，且会被修改成UTC+8； 无意评价这两种方法的优劣，根据习惯修改Linux控制时间同步的方式 1sudo timedatectl set-local-rtc 1 这样会让Linux将BIOS时间识别并修改成本地时间 不要使用包管理器安装需要调用gem的Ruby 在Linux下，包管理器一般只能以root级别的权限运行，这导致下载安装的文件的所有者是root，虽然一般来说，这些文件被设置为了 rwx_r-x_r-x，所以即便不是root用户，也可以读取并执行，而那些被程序读写的文件在用户目录，所以作为用户并没有觉得异样。 但是以root权限安装的Ruby附带的gem包管理器的目录也会被写成root权限。 所以最好的方式是安装rbenv，并且设置好在gitee的rbenv镜像访问插件，在安装了rbenv之后，按照说明修改shell的rc文件并重新启动shell，之后以 1rbenv install -l 列出可用版本的表单，最后用 1rbenv install ${version} 安装ruby，设定了 1rbenv global ${version} 之后，这个gem才是要使用的ruby gems。 gem的源设定命令 教程里一般都写的是 1gem sources -r xxx.xxx.xxx/ -a xxx.xxx.xxx/ ，注意，-r参数里的每个字符都必须一致，也就是说移除官方镜像的语句中，末尾的/是必须的，因为gem的source或者sources命令使用严格检查，即便是一个斜杠符号也必须和原记录中的一致，语句才有意义，执行才会有效。 OpenSSL的编译与安装 明确目的“为什么要编译安装这个东西？”，以及明确“为什么我使用的操作系统没有提供” 如果答案是， 需要解决某种依赖问题，操作系统提供最新的ssl版本过于老旧不能解决依赖。 那么问题不能通过编译OpenSSL解决，需要换个操作系统。 OpenSSL的官方网站上提供源码下载，因此可以自己编译。 我的建议是注意阅读说明文件INSTALL.md 首先，编译OpenSSL需要几个前置的包，这些都写在README的前半部分，务必在将前置需求安装完毕之后再开始下一步。 然后需要对系统进行检查，系统中是否已经安装有OpenSSL 如果答案是“是”，那么通过 1openssl version 检查版本，如果发现是1.x.x.?，那么接下来需要对配置文件做一些修改，以便将OpenSSL安装到其他位置。按照README的说明修改源码中对应的文件，在启动配置程序之前添加对应的行。 下面把原文贴出来，懒得翻译了，善用ctrl+F,或者vim的/功能，在INSTALL.md里面查找这一段，顺便看看前后的其他注意事项 To install OpenSSL to a different location (for example into your home directory for testing purposes) run Configure as shown in the following examples. The options --prefix and --openssldir are explained in further detail in Directories below, and the values used here are mere examples. On Unix: $ ./Configure --prefix=/opt/openssl --openssldir=/usr/local/ssl On OpenVMS: $ perl Configure --prefix=PROGRAM:[INSTALLS] --openssldir=SYS$MANAGER:[OPENSSL] Note: if you do add options to the configuration command, please make sure you've read more than just this Quick Start, such as relevant NOTES-* files, the options outline below, as configuration options may change the outcome in otherwise unexpected ways. 如果是没有安装OpenSSL，虽然多少有点奇怪，但是应该可以继续。如果已经安装了OpenSSL3，那么没理由非要去编译源码并安装，各发行版应当已经针对之前的CVE进行过修复，通过包管理系统更新即可。 之后没什么复杂的， 1./Configure 1./make 注意，编译完成之后，需要 1./make test 以便对编译结果进行检查，检查时会输出详细的说明。 其中有一步需要连接example.com，视网络情况，这一步可能会提示出错，如果是连接问题造成的报错，大可以忽略； 最后检查所有提示的错误，核对数目，然后判断这些错误是什么情况，视情况决定下一步采取何种行动。 最后是安装，一般来说是 1make install ruby的编译安装 通过rbenv安装ruby，实际上是使用源码进行了编译安装，即便配置好国内的镜像源，也有可能需要耗费很长的时间等待编译的结果，以及处理报错和重新开始编译。 编译ruby的其他依赖，build-essential提供了大部分，bison需要自己安装，libyaml也需要自己安装，可能还有其他包，这些会有变动，最好去查询官方文档。 新版本(3.x.x)的ruby需要OpenSSL3才可以进行编译，如果系统中的库是OpenSSL1，那么除了大量的warning以外，还会提示在一个头文件处有类型错误。 如果看到一个关于*.h文件的报错，说明安装程序很大概率是调用了OpenSSL1的库。 一般来说这是因为libssl-dev的版本仍然在1导致的，如果已经安装了3，请卸载libssl-dev包，并解决掉已经崩掉的库的问题，之后再进行尝试。 Dummy Deb Package 包equivs一般不会默认安装，我建议你装一个——虽然我不建议你在任何除了它原本的调试用途以外的情况下使用它。 equivs具有的一个功能是根据一个control文本文件生成一个\"dummy deb package\"，它可以欺骗dpkg包管理系统——让后者做除了报告依赖条件不满足以外的事情。 它原本仅仅用来调试，不过在紧急情况下可以用来救场，例如用于修复网络连接，然后把系统中的某些开机才能转移的数据转移出去。 之后我建议重置这台机器的操作系统。 虽然包管理器这个破软件很dummy很stupid，但终究还是离不开它，我们不可能每次都自己处理所有的更新问题，引入一个dummy package令包管理器不正常地工作，就是埋下了一颗不定时炸弹，那么之后不知道哪天就会在哪里爆炸。 Nvidia显卡驱动的安装 自己安装Nvidia驱动的体验一般都不会很好。最好的方式是继续使用noveun——如果对CUDA没有那么强烈的需求的话，或者使用驱动支持做得很好的发行版，或者使用一个一开始不带有图形界面的发行版，这样先装驱动后装桌面体验会好得多。 好的方面是，一般来说，Nvidia提供的Linux驱动基本后续再也不会更新，所以你的折磨只有一次。 一般装驱动都是去Nvidia网站下载一份run文件，注意型号务必对应，选择型号前先看一下选择列表的其他部分有没有可能会出现更符合你想要做的选择。 安装前记得先去/etc/modprobe.d/添加blacklist黑名单文件，禁用noveun驱动——或者也可以不做这步，Nvidia驱动安装程序会帮你建立——那时候你得手动重启一遍。 另外还需要修改grub文件，在/etc/default/grub中的GRUB_CMDLINE_LINUX_DEFAULT=后面添加blacklist=nouveau，并且 1update-grub2 ，接着 1update-initramfs-u 更新内核启动映像。 重启前查看一下run文件的位置，如果放在了一个中文目录里面，记得把它移到方便用命令行找到的位置——我在准备重启的前一秒想到了这件事，然后在~/下载里面找到了run文件 假如恰巧还没来得及安装zsh并装上oh-my-zsh插件的话，那么依靠bash那羸弱的自动补全功能，是不可能在TTY的一堆方块里面进入无论是桌面还是下载的 （这是我很讨厌各大桌面环境的一点，擅作主张用本地化名称命名一些关键目录，关于用户目录下面的固定用途文件夹怎么命名，怎么在图形系统里面做映射，Windows给出的优秀示范已经那么多年了，Linux几大桌面环境到现在抄都不会抄，是他们中没有CJK使用者， 还是他们从来不用终端？） 之后进入TTY模式，以root权限运行Nvidia提供的run文件，一切顺利的话，会出现进度条，之后会询问一些问题，我只遇到两个问题，一个是\"32-bit compatibility libraries\"，32位兼容库，如果不是明确要用这个库就不要装，复杂的系统造就复杂的问题，“update your x configuration so that nvidia x driver will be used when you restart x”这个务必允许选择yes，以便x系统调用安装好的驱动，我没有遇到其他人说的“register the module with DKMS”，这个一般来说不选yes而要选择no，虽然显卡驱动的确是内核的一个module，而且随内核更新自动编译安装驱动听起来很美好，但我们都知道这套系统有多骨感，况且稳定的发行版一般没事很少换内核，如果某天更新之后发现系统换了内核的话，就去下载一个最新的Nvidia驱动，再手动安装一遍 重启，输入 1nvidia-smi ，如果一切正常，那么应当会看到一份详细的驱动和显卡情况说明 Fedora的protected packages Fedora的一些发行类型，针对某些包设有保护，正常情况下它会保护一些至关重要的包应用，例如grub2。 然而我们也会看到，Fedora的Workstation会将gnome-shell也一并保护， 1dnf remove gnome-shell 的时候拒绝卸载这个包，提示\"protected package\"。 对了，看到这里的时候我的建议是先把gnome完整地装回去，因为一会要用到。 这时候急功近利的办法是使用Fedora的包管理器dnf进行操作，swap掉fedora-identity-workstation，换成无论fedora-identity-basic或者server或者别的什么，然后 1groupremove gnome-desktop ，就可以顺利地卸载掉gnome了，我是在TTY模式下运行这条命令的，因此并没有注意到是不是和有些人说的一样，把X卸载掉了。 换桌面环境这种事，Linux做的并不好。虽然Linux在安装新桌面方面非常容易，但是在卸载旧桌面方面，那复杂的 bloody 依赖关系 performs so ugly. 因此最好是换掉整个系统——从一开始就选择心仪图形界面的版本。 顺带提一下，KDE能够做到在登录期间SDDM识别显卡正常输出画面，而KDE本体不识别显卡，对单显示器输出800×600分辨率。八年前我对KDE在性能方面的评价就很糟，一年两年前对其在其他方面的评价也是 just soso，现在我的评论是它就像它登录管理器的名字一样，SD。 /etc/passwd /etc/shadow /etc/group 原本的/etc/passwd如其名是用来存储密码的地方，然而后来它能够管理账户的特点，以及人人皆可读取的特点导致它变成了一个专门用于用户管理的文件，密码管理功能迁移到了/etc/shadow 尽管passwd文件中的x表示密码移动到了其他位置，但即便在/etc/passwd中x所在的位置写入密码，目前的操作系统基本也不会尝试读取passwd这里的密码； /etc/shadow的密码存储方式是散列函数加盐， 用户名称冒号后面，前两个美元符号之间的内容描述散列方式，例如Fedora使用的$y$，这是指yescrpt； Ubuntu系基本采用$6$，这是SHA-512散列函数，接下来一个美元符号前的内容是盐，后面的内容就是密码的单向映射结果； 有可能遇到$5$，这个是SHA-256； 一定不会遇到的是$1$，这是MD5； 如何生成一个密码？有可能很容易想到openssl sha512，但是这是没必要的； 直接 1mkpasswd --method=SHA-512 即可，它会自动为你生成一个加随机盐的符合条件的密码，将结果直接填入/etc/shadow； 于是就绕过了Fedora的密码字典检查（但是这有何意义呢） /etc/group用来进行组管理，不过一般组管理很少需要手动修改； Ubuntu 22.04的Snap 简单介绍一下snap，据官方所称，这是一个能够“将包与运行环境隔离，可独立运行在各大发行版中的分发系统运行环境”。 我对它做一个简单的介绍，snap是一个强行端上你的桌子，用于无视镜像设置，拖慢你apt update速度，让你的apt upgrade偶尔失败，让firefox浏览器变得糟糕透顶、失去文件读写能力，无法支持输入法的 slum，just piece of .... 关于如何安装非snap版本的firefox已经有很多教程了，主要分为 使用Mozilla的firefox小组提供的PPA源安装deb、 自行从源码编译安装、 使用Flatpak版 三个流派。我的建议是，人生苦短，放弃它——放弃snap，还有顺便放弃ubuntu下的firefox，如果他继续执迷不悟的话 我觉得日常使用的交互型软件中提供输入法支持是对CJK地区人民的基本尊重，如果做不到这点，我很难对这样的软件给出什么好话，它所有的宣传都很noisy 此外，snap商店提供了slack的支持，然而它也不支持输入法，这让我对snap唯一一点可能的好印象也没了。 无论是snap，还是Ubuntu Pro推送，都让我对这个曾经的主要使用习惯所在的发行版的最新版本失望透顶。 我当然知道snapd是可以卸载的，但是既然这是Canonical上赶着要推送给你的东西，把它卸载了，就能解决其它的和将来的问题吗？ 这也是我在上面的折腾浪费了一天的时间的前提下，又在晚上一度重新安装了Ubuntu server 22.04、Xubuntu 22.04并且使用了一段时间后，却最终决定不再使用这个发行版的原因。 Ubuntu的“内部问题” “内部问题”是Ubuntu系列经久不衰的保留项目，是Ubuntu的传统艺能； 部分内部问题窗口带有详情按钮，这时可以查看到底是哪些软件包导致的问题，要么解决问题，要么解决造成问题的包（ 对于没有提示的情况，建议手动打开/var/crash/浏览错误日志查明情况，一一予以解决，以及不要忘记删掉这些文件，或者把它们挪到别的地方； Ubuntu Server 在安装Ubuntu Server之前，我认为它和Debian一样，是一个不带图形界面的Ubuntu。 其实并非如此，例如Debian比起Ubuntu来说就要稳健地多，从另一个方面来讲，就是老旧得多。 那么，其实Ubuntu Server必然也和Ubuntu Desktop是不一样的，这些待会再说，先说说Ubuntu Server独有的优点。 首先，Ubuntu Server有一个值得称道的功能，它允许你在安装之前设定镜像源，而且并不是给一个列表让你选择，而是URL的每个字符都可以自己决定，这样可以使用不在它列表上的自定义近距高速镜像源。 我很喜欢这项功能，它允许我在安装期间将系统更新到最新状态，而不是安装完成之后先手动设定apt的sources.list再跑一遍apt update &amp;&amp; apt upgrade等进度条慢慢走完。 安装过程也比较友好——我把它与安装Arch的经历对比了一下，这真的已经很友好了。 Ubuntu server安装设定中的一步会提供选择，是否安装并启用sshd，这是个很好的功能，省掉了安装之后的一堆麻烦； 不过此时的我不需要这功能，所以选择了否。 然后这时我开始第一次思考这个问题，server版和desktop版的操作系统到底有何区别？ 整个安装过程非常快，比这几天所有其他经历的安装过程都要快，我粗略估计进度条一共跑了不到两分钟。 需要留意的是，安装完毕之后不会自动重新启动，显示subiquity/late/run，然后就不动了，需要手动在下方选择reboot并确认； 重启之后，server用起来还是很不错的。 不过当我在桌面环境上的虚拟终端里又跑了几次apt之后，看着更新结束时提示的“no service need to restart” “no device need to...”一类的提示，我又在想那个问题， server版和desktop版的操作系统到底有何区别？ 答案就是，server版是为server环境调校的，desktop是为desktop环境调校的； 这是一句正确的废话，于是我也意识到之前的行为是废行为， 它们可能本质上没有区别，无外乎预装的软件包不一样，预定的设置不一样，但如果这些不一样和预期用途不一致，是需要花费时间调整的，时间并非一文不值， 遂卸载ubuntu server，尽管我对它赞不绝口 如有可能，不要在Linux上折腾桌面 转向Xubuntu，在图形界面上，Xubuntu并不能挑出任何毛病，想要用哪个桌面，最好一开始就使用带有这个桌面的版本，而不是想着之后调整，因为在Linux下面，桌面环境安装方便，卸载很难， 问题不出在Xubuntu上，而是出在Ubuntu上，如上文所说，我不喜欢别人强行让我接受什么东西，说得再好也不行， 在试用了一会Xubuntu后最终弃用这整个发行版 LinuxMint上的新开始，美好，暂时的 正如Ubuntu是源自Debian的一个发行版一样，LinuxMint是源自Ubuntu的一个发行版。 我对这个发行版的接触很少，唯一的印象是八到九年前的试用，我对它的Cinnamon有点印象。但它太平凡，太普通，以至于我一直没有想起来。 我的需求到底是什么 在昨天浪费一天时间之后，晚饭前难得的平静时间内，我思考了一下自己到底在干什么，我的需求是什么？ 一套标准的C编译环境，所有的Linux Desktop都可以提供，顺带一提，基本所有的Linux Desktop也基本都能提供git，这样版本管理问题也解决了； 一套较好的C编辑环境，一般来说有vim算是勉强满足要求，所有的Linux基本都能提供vim；但最好是有vscode一类比较方便的编辑器，这样的话范围就被限制了，也就是说我需要一个Xorg； (其实vscode支持远程使用，比如部署在服务器上并通过ssh工作，但是我目前并是单机工作，所以无法以这种方式使用) 图形化浏览器和较好的网络环境支持，虽然w3m算是“浏览器”，但肯定不会是我在敲代码途中想要用的那个，这增强了对Xorg的需求；我还需要较好的网络环境支持功能，这又把范围进一步缩小了； 输入法，如果要查询东西，这个是必须的，进一步地，不仅要提供输入法，还要足够好用，至少要能在浏览器里面使用； 国内的即时通讯软件？不是很需要的样子； 办公软件？不需要，如果有文档需要处理，那么我就重启计算机去使用Windows10；虽然我很支持LibreOffice套件，它还有QtiPlot曾经和我度过了一段艰难但是快乐的时光； (以及QtiPlot的最新版好像开始收费了？) 绘画？同上，重启换系统解决问题；不过似乎GIMP也能支持的样子，但我还没试过； 听音乐？不得不承认这个很有诱惑力，但我想了一下， 我只是需要让Linux挂载一下Windows的硬盘，读一下NTFS分区里面的文件而已，况且此外的需求还有网易云来填补——虽然曲库不太全，不过还有浏览器来填补剩下的需求；虽然Linux的音频管理做的很糟——调整声音振幅什么的居然有可以感觉得到的延迟； 我需要一套灵活的Python环境，因为接下来可能会用到，不过Linux下的Python支持不错，有venv，还有anaconda，虽然我对这个还从未使用过的商业软件在Linux下面会跑成什么样子没有底；但即便最坏的情况也还有Docker可用； 我需要一套ruby on rail的环境，在我搞出一套编译器出来之前，需要它帮我完成一些不太好办的事情； 一个yacc，估计很快就要用到，虽然Windows下面可以通过msys、cygwin(这也是我很喜欢的一个软件)，还有我比较喜欢的wsl1实现，但在Linux下面使用显然更好； 一套GoLang开发环境，估计可能过段时间就要用到，我查询了一下，Linux下面是可以进行Go开发的； 一套熟悉的包管理系统——可以是apt或者pacman，因为下午用了一会Fedora的yum/dnf，感觉浑身不自在，习惯的力量还是太强大了； 最好提供xfce4支持，也可以是lxde，反正我不喜欢Gnome，因为需要花很多时间卸载它而且卸不干净，尽管它和xfce一样也源自gtk+； 我也不喜欢KDE，它真的从来没有给我留下过任何好印象，很难想象WebKit和KDE曾经有一段过去； (gnome和kde对我来说主要问题还是浪费资源严重，可定制化程度太低，即便gnome和kde目前是为数不多的支持wayland的玩意) 镜像支持，在几个我能访问到的高速镜像站有可用的镜像，最好不要附带一些莫名其妙、东一榔头西一棒槌的用不了镜像且会卡死进度条的怪东西；不过这也意味着不可能选择BSD，FreeBSD在国内的镜像支持是有的，而且我也很佩服那些坚持做镜像源的志愿者们，我曾经和他们有过一些关于镜像问题的邮件交流，他们给我留下了非常深刻的印象，但是终究，Linux的源更多更快，而且我目前还能用到百兆的Linux源，并不是很愿意使用其他操作系统——这并不是这些操作系统本身的原因； 于是在折腾完Ubuntu Server和Xubuntu之后，我又重新考虑了一下我的需求，这些需求虽然很刁钻，但也不是特别难办，我还是有选择的，那就是多年前接触过且没有给我留下印象的LinuxMint； 首先，习惯方面，Debian同一系的包管理——主要是包命名方式，这符合“apt或者pacman”的要求；源自Ubuntu还意味着丰富的软件包支持——当然没有Arch的AUR那么夸张； 高速镜像，这个正好是有的；而且只需要配一个Mint源，其它的几个可以直接用Ubuntu源； 没有snap，好耶！ Xorg和xfce4支持，都具备； 甚至有NVIDIA专有显卡驱动支持； 输入法支持，除了某些没有镜像源而且硬要端给别人的怪东西之外，正常的X桌面环境都有虽然不完善但是基本可以使用的输入法支持； 那还等什么，赶快下载LinuxMint-xfce4，然后录写制作启动U盘，重启准备开始安装过程；在Grub2页面，我留意到这里有四个选项，启动，以兼容模式启动，OEM安装，内存测试——和其他几个发行版相比多出来一个兼容模式 有惊无险的安装过程 小众同时意味着惊喜不断，LiveCD的界面里我的鼠标就卡死了，我不太确定这是输入设备支持的问题，还是系统的问题，看了右下角的时钟过去了一分钟还没有变化，多半是卡死了，这LiveCD真的让人很难相信系统的品质，但我觉得没必要这里就放弃，因为这一天已经经历过够多了，于是重启了一下，选择了(compatibility mode)，这次的LiveCD除了因为显卡驱动没有加载导致图形界面有点难看，以及在某几个页面点击“下一步”更换页面时让人担忧的短暂无响应之外，倒也是顺利地安装完毕了，最后提示拔掉安装介质按下ENTER以重新启动； 让人逐渐喜欢的使用体验 安装完毕之后，随着EFI定制的BIOS页面启动画面转动，一切正常，令人有些担心的是lightdm出现之前有一个短暂的TTY登录提示输入用户名和密码，但是它很快就被跳过了，在进入桌面之后这些担忧就烟消云散了 看起来是经过定制的xfce4，简单改了一下多显示器位置的设定，这套桌面其他的地方都比较精美，我仅仅修改默认面板设置使其自动隐藏腾出桌面地方，在副屏的角落处增加了用来随时看日期时间的半透明小面板，看起来基本没有什么需要改动的地方了； 登入后自动弹出的向导窗口让我选择了喜欢的色彩主题，然后向我介绍了如何使用自带的软件，以及面板里几个图标的功能，这个挺让人喜欢的； 按照向导的介绍，我启用了Timeshift的功能，它会产生snapshot，虽然名字里带有“snap”，不过它要讨人喜欢得多，如Timeshift的名字所示，它是一个系统快照+还原软件，可以在系统被搞得一团糟的情况下恢复系统，对于Linux这种十分依赖集中型包管理的操作系统是很提效的功能；虽然更有效的是使用习惯，但有时候没那么多选择； 以及向导会提供图形化的驱动安装引导界面，由于Ubuntu能够从Nvidia获取匹配的闭源驱动，因此在Mint下也可以非常方便地使用它们，直接在图形界面下安装驱动并做完所有配置；这是很多发行版做不到的事情； 安装了一下常用的软件，夜已经深了，回顾了一下一整天的经历，假如一开始就下定决心而不是在20.04的基础上修修补补，最终捅了个关于OpenSSL的大篓子导致整套网络栈近乎报销，也许会省下许多时间，但问题最终的解决方案也并不是一开始就浮上水面的，事实上直到深夜之前，我都没有想到过Mint其实是正好满足一切需求的发行版；有时候就是需要这样一个灵感，然而灵感的产生也并不是那么随心所欲的； Fcitx5同时需要gtk2和gtk3 要想让Fcitx5正常工作，fcitx5-frontend-gtk2和fcitx5-frontend-gtk3这两个包是同时被需要的，不能只装一个； vscode的颜色设置 上一次配vscode还是很久之前的事情 我也不太想登录账号让它自动同步设置，因为我在三个环境下同时使用vscode，Windows，WSL，LinuxMint，已知Windows和WSL的配置是独立存在的，但后两者之间不太确定 json中的\"workbench.colorCustomizations\"条目就是设置位置了， 1\"statusBar.noFolderBackgroud\" 是非打开文件夹情况下状态栏的颜色，我不是很喜欢那个紫色，我认为紫色太醒目，所以改成了深蓝色 1\"statusBar.backgroud\" 是打开文件夹情况下的颜色，直接设成#1874CD 1\"statusBar.debuggingBackgroud\" 是调试代码期间状态栏的颜色，可以凭喜好随意设定，不要太刺眼就行 一些繁杂的经历和一些不太愉快的经历 Linux的字体支持很糟糕，这不完全是Linux的原因——这个世界上有很多人守着字体这棵摇钱树； 作为一个个人用户，我对那些不感兴趣，我只关心怎么好看好用，首先搞到几家大公司一起弄出来促进互联网发展的思源黑体(sans，无衬线)和思源宋体(serif，有衬线)，这套字体是开源允许任意使用的，然后是微软的Cascadia开源字体，它包含了对等宽的支持，接下来通过其他手段搞到其他字体文件，比如Consolas之类的； (4月2日更新：关于字体配置可以去看Linux字体美化实战(Fontconfig配置)，这篇文章写得更专业，更全面，我参照文章删掉了原本安装的CJK字体中不需要的几个，顺带一提这网站作者真是个非常硬核的人) 一般来说，Linux下有两种字体，一类是OpenType，一般以otf为扩展名，一类是TrueType，一般以TTF和TTC为扩展名，将它们放到/usr/share/fonts对应的字体文件夹里，然后fc-cache -fv更新字体缓存 只有等宽字体才可以被终端一类的程序使用，虽然CJK类文字天生就是等宽的，但是思源黑体和思源宋体没有把自己声明为等宽字体(也许是因为西文部分不等宽)，所以终端方面还是得使用noto，cascadia，consolas一类的等宽字体 此外，字体一定要装完整，不要只装一半，不然本来某些程序读不到字体会用替代品版正常地显示，但假如读到原本要用的字体\"font family\"中的同类(但不是本体)，它有些许可能会选择使用(并非总是，有一个优先级问题)，于是粗细正斜也许会对不上，这会导致显示效果更糟糕； 例如firefox在渲染网页时就有可能会出现这样的问题，另外vscode没有读到合适的等宽字体就会使用系统默认的mono字体设定，说实话自带字体那个显示效果只能说是非常糟糕且糟糕透顶，我的建议是搞到其他字体文件并且根据这些字体去修改vscode的字体集使用设定(Preference-&gt;Fonts)； 以及运行没多久，mint的xfce就带来了两次鼠标卡死而其他操作——比如键盘操作——正常的小BUG，所幸通过切换窗口焦点、通过终端kill掉对应的进程一般都能解决问题； 最后是虚拟终端字形渲染问题，几乎所有虚拟终端都采用了同样的vte库，据称这个库导致了字体行高异常的问题，目前尚不太清楚后续的情况，但是就使用体验而言是还没解决，不知道他们打算什么时候修； 顺带一提，一个不影响使用的小毛病 mint-xfce自带的lightdm无法通过常规方式调整显示器的位置，这也是dm的通病，它们基本都是一个单独的用户，而普通用户对桌面的修改只在自己的文件夹中生效。 Gnome可以通过将Gnome系统的monitors.xml文件拷贝到gdm用户的目录下使之生效 但xfce与lightdm的组合，暂时没找到比较好的办法。 gentoo wiki给出了一个创建与修改/etc/xorg/xorg.conf.d/中文件的方式调整xorg对显示器的识别方式，过程中需要用到xrandr工具检查图形输出，尤其是显示器输出的名称， 我也查找了xorg.conf的manual手册，也许是我看着资料写的40-monitor.conf中 1234567891011121314Section \"Device\" Identifier \"NVIDIA-VIDEO-CARD\" Option \"Monitor-HDMI-0\" \"MonitorA\" Option \"Monitor-DP-0\" \"MonitorB\"EndSectionSection \"Monitor\" Option \"MonitorA\"EndSectionSection \"Monitor\" Identifier \"MonitorB\" Option \"RightOf\" \"MonitorA\"EndSection 哪里出了问题，总之，xorg并没有在lightdm中正确地排布我的显示器位置。 暂时算是平稳地装完了系统，可以开始享受纯Linux的开发了。 thunar挂在硬盘的不可预知权限 (05-15更新) thunar这个东西，挂载磁盘完全靠玄学，有时候是读写模式挂载，有时候是只读模式挂载 说实话我只希望它稳定一点，不要每次都在摸奖 Keep Dissing snap craft 继续炮轰snap craft snap在整个世界都只有一个软件商店，全指望你Canonical一家的网络资源进行软件包下载，你端得起这么大的盘子吗？ 如果说为了所谓的“跨平台移植性”，那为什么不选择同样支持跨平台移植性并且更加开放的flatpak呢？ Knighthana 2023/04/01 Pub 2023/04/13 Edited","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://knighthana.github.io/tags/vscode/"},{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"LinuxMint","slug":"LinuxMint","permalink":"https://knighthana.github.io/tags/LinuxMint/"},{"name":"NVIDIA","slug":"NVIDIA","permalink":"https://knighthana.github.io/tags/NVIDIA/"},{"name":"Windows","slug":"Windows","permalink":"https://knighthana.github.io/tags/Windows/"},{"name":"Blog","slug":"Blog","permalink":"https://knighthana.github.io/tags/Blog/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://knighthana.github.io/tags/Ubuntu/"},{"name":"Fedora","slug":"Fedora","permalink":"https://knighthana.github.io/tags/Fedora/"},{"name":"Ruby","slug":"Ruby","permalink":"https://knighthana.github.io/tags/Ruby/"},{"name":"gems","slug":"gems","permalink":"https://knighthana.github.io/tags/gems/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://knighthana.github.io/tags/OpenSSL/"},{"name":"fcitx5","slug":"fcitx5","permalink":"https://knighthana.github.io/tags/fcitx5/"},{"name":"font","slug":"font","permalink":"https://knighthana.github.io/tags/font/"}]},{"title":"一步状态转移概率矩阵","slug":"一步状态转移概率矩阵","date":"2023-03-29T16:00:00.000Z","updated":"2023-04-20T07:01:12.168Z","comments":true,"path":"subject-note/一步状态转移概率矩阵.html","link":"","permalink":"https://knighthana.github.io/subject-note/%E4%B8%80%E6%AD%A5%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%A6%82%E7%8E%87%E7%9F%A9%E9%98%B5.html","excerpt":"","text":"一步状态转移概率矩阵 定义一步状态转移概率矩阵 马尔科夫性质指的是具有该性质的随机过程在 时刻所处状态为已知时，过程在大于 的时刻所处状态的概率特性只与过程在 时刻所处的状态有关，而与过程在时刻以前的状态无关，又称此性质为无后效性 离散状态空间的马尔科夫过程称为马尔科夫链，由于具有马尔科夫性质的随机过程具有无后效性，所以考虑马尔科夫链上进行状态转移的情况时，只需要考虑此时刻所处的状态，以及将要转移向的状态，而且令人欣喜的是，在任意时刻的这种考虑都是正确的，不必担心时间的影响 那么，不难发现，对于具有马尔科夫性质的随机过程，其在每个状态下向其他任何已知状态转移的概率都是已知的 试图定义马尔科夫链n时刻的k步状态转移概率，n时刻马尔科夫链处于状态i，经过k步，系统处于j状态的概率 这里说“转移了k步”是因为我们在讨论离散时间问题，对于其中每个定义的有意义的时刻，我们说这是“一步” 复习一下概率论中学习过的内容，条件概率等于积事件的概率比上前置事件的概率， 于是定义k步转移概率为 pij(k)(n)=pij(n,n+k)=p{X(n+k)=j|X(n)=i} 重复一遍，这个公式中，k代表“k步”，i代表n时刻所处的状态，j是在k步之后要转移到的状态，一个p用括号把它们括起来，代表这件事情发生的概率 由于整个样本空间中所有事件之和发生的概率为1，所以有 这个式子的含义是，假设整个系统有｛1, 2, …… , N｝共N个状态 对于 ，有 对于 ，有 对于 ，有 …… 对于 ，有 但是，我们平常用不上k步状态转移概率 最重要、实际中最常用的是一步状态转移概率 ，而且一般来说也只研究一步状态转移概率 注意，对于一步状态转移概率矩阵，上面说的公式仍然以 的形式成立 如何画出一步状态转移概率矩阵呢？ 首先明确，一步状态转移概率矩阵是一个 的正方形矩阵 将n时刻的状态（这是一个样本空间）纵向排布， 将n+1时刻的状态（这是另一个样本空间）横向排布， 把i放在铅直方向，排成一竖列，把j放在水平方向，排成一横行 在矩阵中放入每个 即系统从i状态一步转移到j状态的概率，例如 指系统从状态1一步转移到状态3的概率 注意，i和j可以相同，因此 也是有效的，指的是系统此时刻状态为1，一步转移到状态1的概率，也就是状态保持不变的概率，这个状态保持不变，既有可能是系统没有发生变化，也有可能是系统内发生了均衡的变化 的状态 Latex不支持在矩阵纵向的方括号外面注释，纵向应该要写“ 的状态”和“1 2 ... i ...” 注意， 这个性质仍然有效 因此，在矩阵中，每一横行的概率之和应当为1，这是验证所画出矩阵是否正确的一个方法 这里矩阵看懂了怎么回事最好，如果没看懂怎么画也没关系，可以看“举例说明”一节 继续搬教材： 随机过程与排队论课程研究时间齐次马尔科夫过程，简称时齐马尔科夫过程，它满足 其中假定系统的行为不依赖于观测的时间，即马尔科夫过程中的条件分布函数不随观察起始时刻的变化而变化，我们可以任选时间轴的起点 这一坨公式看不懂也没关系，最重要的一句话就是“我们可以任选时间轴的起点” 这句话的影响就是后面我在行文中可能随时混淆“n时刻”和“当下时刻”，还可能混淆“n+1时刻”和“下一时刻” 因为对于一个时间齐次的马尔科夫过程，无论从哪个时刻切入问题，系统的性质都是不变的，所以其实都是一样的 理解这个东西有什么意义 这里引用一下我老师的话，经过二道转述可能不全 状态转移概率矩阵P，是状态转移的桥梁， 运用状态转移概率矩阵P，可令系统从n状态转移到n+1状态，n+2状态，n+3状态，…… 我们可以通过P去研究一个随机的过程，可以用P去预测系统未来的状态 若 则称状态转移后收敛于一个稳定的状态 举例说明 下面用三个例子来说明如何构建一步状态转移概率矩阵 一维随机游走问题 设一质点在如图所示的直线的点集I={1,2,3,4,5}上随机游动，并仅在1秒，2秒等等整秒的时刻发生游动。 例1图 游动的规则是： 如果Q现在位于点i (1&lt; i &lt;5)，则下一时刻各以 的概率向左或向右移动一格，或以 的概率留在原处； 如果Q现在位于1(或5)点上，则下一时刻就以概率1移动到2(对应地，或4)这一点上。 1和5这两点称为反射壁。本例这种游动称为带有两个反射壁的随机游动 我觉得这个条件1的说法不太好，假如写成 如果Q现在位于点i，且满足 的条件，则下一时刻各以 的概率向左或向右移动一格，或以 的概率留在原处 会更明确一些，因为我们研究的是离散的点，不是连续的点，这不是在C语言里面用大小于号往离散值上面标循环条件，标完了还得想一下到底是循环多少次 解： 列出状态的所有可能取值 画出矩阵P 求出每个 的值，填入矩阵中 因为是初学，所以这里一个一个算， 首先 啥意思，我们解读一下，在 中，下标前面的数字是1，也就是说 ，下标后面的数字是1，也就是说 那么 的值就是指，本时刻的状态值为1，下一时刻的状态为1的概率，就是说，“下一时刻状态还为1”的概率 这里也可以说，“系统在n时刻状态为1，n+1时刻状态为1的概率” 理解这个“n时刻”和“本时刻”、“n+1时刻”和“下一时刻”几个两两一组的词语在研究时齐马尔科夫过程的过程中，可以方便地混用的特性 查询题目条件， 如果Q现在位于1(或5)点上，则下一时刻就以概率1移动到2(对应地，或4)这一点上。 那么，“本时刻状态为1，下一时刻状态仍为1”是一个不可能事件，不可能事件的概率为0 于是 ，填入矩阵 然后解读下一个，求概率值，下一个是 用汉语来解释，就是说，系统此时刻状态为1，下一时刻状态为2，查询题目条件， 如果Q现在位于1(或5)点上，则下一时刻就以概率1移动到2(对应地，或4)这一点上。 那么很容易得出这里的概率值为1，于是我们把1填入概率矩阵中 的位置 对于 这三点，从上面多次引用的题目条件中，不难得到，它们都是不可能事件，不可能事件的概率为0，因此把0填入矩阵中这三点的位置 第一次验算，将矩阵第一行求和 ，基本没问题，继续 说的是“本时刻系统处于状态2，下一时刻状态转移至1的概率”，查询题目条件， 如果Q现在位于点i (1&lt; i &lt;5)，则下一时刻各以 的概率向左或向右移动一格，或以 的概率留在原处； 以及我转换过后的说法 如果Q现在位于点i， 则下一时刻各以 的概率向左或向右移动一格，或以 的概率留在原处； 于是不难得出，“本时刻系统处于状态2，下一时刻系统状态转移至1的概率”是 把算出的 的值 填入表——不是，“矩阵”中 于是我们得到了 然后算 假如点位于{2, 3, 4}中的任意一点，那么它要么以 的概率向左移动1格，要么以 的概率留在原地，要么以 的概率向右移动一格 的意思是“留在原地的概率”，那就是 于是我们得到了更新后的矩阵 类似地， 更新之后 然后是 ，题目中是否允许由2→4这样的一步状态转移呢？没有，那么系统状态在一步进行2→4的状态转移是一个不可能事件，不可能事件的概率为0，于是 填入矩阵中 同理，一步进行2→5状态转移也是不允许的，这是不可能事件，不可能事件的概率为0， 这样我们完成了矩阵的第二行，不要忘记验算 可以认为第二行是正确的 继续进行下一步，算矩阵的第三行 我相信阅读到这里的读者应该很容易看出，矩阵第三行的数值应该是 把它填入矩阵中，替换 这一行，于是得到了 同样进行验算，矩阵第三行之和为1，没有出错， 再算出第四行和第五行并进行验算，核对无误之后，于是我们得到了本题的一步状态转移概率矩阵为 完事！ 扩展思考 本题中给出的是反射壁，也可以更改为吸收壁的形式 字面理解吸收壁的含义，就是一旦点移动到这里，就会被牢牢吸住，无法再移动，那么不难得出，对于一个位置i的吸收壁， 的概率为1 假如我们将本题的点1改为吸收壁，那么原本的第一行 就会变成 假如我们将点1替换为吸收壁，那么原本的一步状态转移就变成了如下的形式 如果点1保持为最初的反射壁不变，而将点5单独更换为吸收壁，矩阵应该是什么样子的？ 不难想象，矩阵会变成如下形式 如果我们将点1和点5都由原本的样子更换成为吸收壁，读者不妨思考一下矩阵的样子 这应该也不难想象 0-1传输系统问题 只传输数字0和1的串联系统，如图所示，每一级的传真率为 ，误码率为 ，设一个单位时间传输一级， 是第一级的输入， 是第n级的输出。 例2图 这个系统和前面所说的“系统”有点不太一样，上一个例题中，研究的是同一系统（同一空间）不同时刻的状态，非常自然地获得了在时间上状态转移的关系，而本题中，我们仍然有一整个系统，但这一次时间和空间都在变化，难道要画出整个传输系统的一步状态转移概率矩阵吗？ 如果我们仍然仅仅把研究的目光放在 和 两个被传输的数据，在经过同一节点前后的状态转移关系上，而不去考虑其他问题，不难发现，这仍然是一个时齐马尔科夫过程 解 列出状态的所有可能取值 画出矩阵P 求出每个 的值，填入矩阵中 指经过节点之前，被传输的数据是0，在经过节点之后，被传输的数据仍然是0，也即“保真”传输，那么这个概率就是题目中所说的“传真率” 指经过节点之前，被传输的数据是0，在经过节点之后，数据变成了1，这说明节点上的传输发生了错误，这个概率就是题目中所说的“误码率” ，根据题目，有 进行验算， ，认为列出本行无误 同理， ， ，于是我们获得了本例的一步状态转移概率矩阵 这样写比较简洁，如果写成 的形式，显露出了它被掩盖的本质，更加明了一些 简单排队模型 设服务系统有一个服务员和只可以容纳两个人的等候室组成，如图 例3图 服务规则是：先到先服务，后来者需在等候室依次排队，假定一个需要服务的顾客到达系统时发现系统内已有3个顾客（一个正在接受服务，两个在等候室排队），则该顾客离去。 设时间间隔 内将有一个顾客进入系统的概率为 ，有一原来被服务的顾客离开系统（即服务完毕）的概率为 。 又设当 充分小时，在这一时间间隔内多于一个顾客进入或离开系统实际上是不可能的。 再设有无顾客来到与服务是否完毕是相互独立的。 解 这道题是个完全的排队论问题 一、首先，按照坎达尔排队理论的A/B/C排队表示法描述问题 输入过程（到达的规则）：这个分布我们实际上是不知道的，我们完全可以假设是以泊松分布进行的，当然任何情况都有可能并不局限于此，不过本题提供了单位时间 内有一位顾客到达的概率就是 所以无论是什么分布，这个概率 是非常确凿的 处理过程（服务的规则）：我们仍然不知道此随机变量的分布，但是我们知道 单位时间 内有一位顾客被服务完毕并且离开的概率是 ，没有规定，我们就可以随意假设，比如说假设它是一个负指数分布，只要令它在 的概率等于 即可 服务窗口个数：1 系统容量（包括处理窗口容量和缓存Buffer容量的总和）：3 仍然在等待的输入（待服务的顾客）： 二、系统是否具有马尔科夫性质？系统是马尔科夫链 三、画矩阵： 系统的状态集合 系统共有4个状态，因此需要画出一个 矩阵 算出每个一步状态转移概率 填入矩阵 指“系统内没有顾客，经 后仍然没有顾客的概率” 那么，0→0有没有可能标识的是在 内，来了一个顾客，且服务完毕让他走了呢？ 不行， 当 充分小时在这一时间间隔内多于一个顾客进入或离开系统实际上是不可能的。 可以“之前的都没走、一个都没来”，也可以“之前的都没走，来了一个新的”，也可以“之前的走了一个，但没有来新的”，也可以“之前的走了一个，来了一个新的”（也可以是采样期间先来了一个新的顾客，在采样结束之前原来被服务的顾客中有一人结束离开了，这都不影响我们采样结束时的状态），唯独不能“单位时间内来了一个然后给这人服务完毕让其离开了”，因为 “充分小”，想想这是啥场面，这是什么柜台，人刚坐下就可以走了，虽然这样的设想中的服务系统很高效，但不实际 那么，0→0说的就是，本来系统里一个人都没有，结果也没有新人进入系统，那只要保证没有人进来就是0→0了 于是我们列出计算 的式子，得到 的值为 然后是 ，0→1说的是，系统中本来一个人都没有，但是在我们进行测量的极短时间段 内进来了一个人，从题目中得知，进来一个新人的概率是 那么，可以列出 由于 &gt; 这一时间间隔内多于一个顾客进入或离开系统实际上是不可能的。 所以，0→2，0→3都是不可能事件，不可能事件的概率为0，于是我们得到 那么计算出来的第一行是 我们验算一下， ，无误 将它填入矩阵，于是得到了 第二行， 的1→0指的是“系统中本来有一个人，这个人在我们采样期间恰好被服务完毕离开了，并且我们采样的时候，没有新的顾客进来” 一个顾客在 时间内 被服务离开的概率是 ，无人进入的概率是 ，有一个“并且”，我们要算交事件，由于 &gt; 有无顾客来到与服务是否完毕是相互独立的 互相独立事件的非事件也是互相独立的，故二者独立，对于独立事件A、B我们有 ，于是， 描述的事件是什么呢？1→1代表什么含义？首先，1→1可以是“系统中有一个顾客正在被服务，且采样期间服务仍然继续没有结束，顾客没有离开，并且采样期间外面没有新的顾客进入系统。”，仅仅只有这一种情况吗？不是的，还可以是“采样期间，被服务的顾客的服务结束，于是此名顾客离开了，并且在采样期间，又有一位新的顾客进入了系统” 两种情况，分开计算 第一种，两个独立事件相乘， 第二种也是两个独立事件相乘， 然后我们需要将这两件事合起来 通常来说 不过我们注意到 与 代表的事件二者互相不独立，并且互不相容，进一步地，它们甚至互斥（注意到 与 同时出现，而且 与 也同时出现了 ） 那么对于互不相容事件，有 于是式子可以写成两个概率相加的形式，而不用考虑减掉的部分，因为需要减去的部分是0 那么 代表的1→2是什么意思呢？只有一种情况，那就是“系统中原本正在被服务的顾客无一人离开，且有一位新顾客进入等候” 于是对于两个独立事件列出算式 的情况与 类似，都是代表了不可能事件的概率，不可能事件的概率为0，故 由此得到了第二行， 验算一下，对它们求和， ，计算无误，填入矩阵，得到 继续计算第三行 ，因为2→0是不可能事件 求和，与上一行是同样的结果，1，那么就可以填入矩阵 最后算第四行 对于不可能事件， 然后是 当系统内有3个人时，实际上系统已经没有足够的缓冲区容纳新顾客了，按照题目的说法，新顾客看到系统中有3个人的话就会直接离开，不会进入系统，那么只要保证没有顾客离开系统，就可以发生事件3→3，另一种情况是离开了一位顾客，但是有新的顾客填补了等候区的空位 于是直接写出 到这里已经可以结束了 我认为这个说法不够直观，下面这一部分是我的个人展开的理解 对于3→3，我们分情况进行讨论 - 第一种情况是，事件A，观察期间，系统中没有顾客离开，也没有新顾客“需要”进入系统 - 第二种情况是，事件B，观察期间，系统中没有顾客离开，但是有新的顾客“需要”进入系统，然而他们到了门口一看，已经没地方了，于是转身离开 - 第三种情况是，事件C，观察期间，系统中有一位顾客离开了，不过也有一位新的顾客进来填补了等候区的位置，于是在我们结束观察，停止采样时，系统中仍然是3位顾客 注意到，A、B、C都互为不相容事件，交事件AB、AC、BC、ABC都为空集 于是， 总之，我们得到了最后一行 验算一下， 无误，填入矩阵进行替换 于是我们就得到了这个例子中的一步状态转移概率矩阵 通过一步状态转移概率矩阵P求系统未来时刻的状态(借助计算工具) 假设一个系统用向量 描述，系统的初始状态 ，已知它的状态转移概率矩阵 求n步后，系统的状态 解 这个例子只是为了让我们 充分熟悉一个概念，那就是 然后顺便熟悉一下计算辅助工具的使用方法，毕竟对于有的实际问题中的超大型矩阵不可能用手去算 说实话我本来对某工具不太感冒，也不愿意学习如何使用这个东西，但是老师的一句话让我对此工具转变了态度，“我们可以认为这是一个草稿纸；并且我们本来就在研究一些复杂的问题，如果还要使用复杂的工具，未免舍本逐末”，我想了想，确实，我之前为什么要对一个计算工具抱那么大的敌意呢 总结一下演示的内容，我在自己的计算机上也进行了实验，和当时看到的结果都符合 先把题目条件输入 123Z_0=[1,0]P=[0.1,0.9;0.9,0.1]Z_1=Z_0*P 于是我们得到了 继续 1Z_2=Z_1*P 得到 继续 1Z_3=Z_2*P 得到 注意到 不难得出 的结论 于是 1Z_30=Z_0*P^30 由此 继续输入代码 1Z_40=Z_0*P^40 输入代码 123Z_50=Z_0*P^50Z_60=Z_0*P^60Z_70=Z_0*P^70 于是分别得到了 总结 本节文章到此结束 回顾一下，本文简单介绍了一下什么是一步状态转移概率矩阵，它有什么意义，如何构建一个一步状态转移概率矩阵，并且给出了三个例子用来介绍如何一步一步根据问题获得一个一步状态转移概率矩阵 最后，用一个例子介绍了如何通过计算机辅助计算软件，根据系统初始状态和一步状态转移概率矩阵，不断预测系统未来的情况 这里挖个坑，马尔科夫性质不是天上掉下来的，如何证明一些常见的概率分布具有马尔科夫性质，从而将它们转化为可用于构造马尔科夫链的数学工具？ 个人理解，欢迎勘误 Knighthana 2023/03/30 参考资料 [1]曾勇，董丽华，马建峰.排队现象的建模、解析与模拟[M].西安：西安电子科技大学出版社,2011.9:9-14.","categories":[{"name":"subject-note","slug":"subject-note","permalink":"https://knighthana.github.io/categories/subject-note/"}],"tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://knighthana.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"随机过程","slug":"随机过程","permalink":"https://knighthana.github.io/tags/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/"},{"name":"排队论","slug":"排队论","permalink":"https://knighthana.github.io/tags/%E6%8E%92%E9%98%9F%E8%AE%BA/"},{"name":"马尔可夫链","slug":"马尔可夫链","permalink":"https://knighthana.github.io/tags/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/"},{"name":"离散时间马尔可夫链","slug":"离散时间马尔可夫链","permalink":"https://knighthana.github.io/tags/%E7%A6%BB%E6%95%A3%E6%97%B6%E9%97%B4%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/"}]},{"title":"文法定义中的“终结符号”和“非终结符号”","slug":"文法定义中的终结符号和非终结符号","date":"2023-03-28T16:00:00.000Z","updated":"2023-04-20T07:02:30.396Z","comments":true,"path":"subject-note/文法定义中的终结符号和非终结符号.html","link":"","permalink":"https://knighthana.github.io/subject-note/%E6%96%87%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%BB%88%E7%BB%93%E7%AC%A6%E5%8F%B7%E5%92%8C%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6%E5%8F%B7.html","excerpt":"","text":"文法定义中的“终结符号”和“非终结符号” 这篇文章是个人理解 可能有人看相关书籍时对此有疑惑，什么叫“终结符号”，什么叫“非终结符号”，怎么就终结了，终结了什么，怎么就非终结了，不终结什么 这也是我写这篇文章的目的 上下文无关文法(CFG) 先看一段来自“Compilers Principes, Techniques, &amp; Tools”中译本《编译原理》中对“文法”的定义 文法定义： 一个上下文无关文法(context-free grammar, CFG)由四个元素组成 一个终结符号集合，它们有时也称为“词法单元”。终结符号是该文法所定义的语言的基本符号的集合 一个非终结符号集合，它们有时也称为“语法变量”。每个非终结符号表示一个终结符号串的集合。我们将在后面介绍这种表示方法。 一个产生式集合，其中每个产生式包括一个称为产生式头部或左部的非终结符号，一个箭头，和一个称为产生式体或右部的由非终结符号及非终结符号组成的序列。产生式主要用来表示某个构造的某种书写形式。如果产生式头部非终结符号代表一个构造，那么该产生式体就代表了该构造的一种书写方式。 指定一个非终结符号为开始符号 以上是所有的书面描述，这四条定义都怎么理解呢？ 先画个表，文法的所有元素的集合 元素1 元素2 元素3 非终结符号 产生式 终结符号 所谓“开始”符号，只是非终结符号中的一员，因此我们将其归入非终结符号的集合就可以了 其实这里CFG文法的定义中，最重要的概念是“产生式”，它就像（而且作用也类似）外语学习时句子里的谓语，有了谓语，才好理解整个句子的意思 产生式是做什么用的？就是不断把自己左边的东西变成右边的东西 考虑到文章读者基本都是汉语汉字使用者，基本都有英语英文字母基础，所以这里避开使用汉字或者英文字母举例，以避免和现实的状况产生联系 假如定义一个产生式的作用是将日语平假名“产生”成为俄语俄文（这样字形差异比较大），那么我们说如下的形式是一个符合这个定义中的产生式 1にほんご→японский 那么它的作用就是在文段中不断地替换，将左边的内容替换成右边的内容 左边的这种平假名组成的串都得替换，而右边的这样的西里尔字母串属于转换的目的，就不必再替换了 然而，实际上下面的式子也是一个产生式（当然这里就不太符合这两种语言文字的词法了） 12にほんご→японごご→ский 为什么第一个产生式中一个平假名跑到右边去成为了“产生”的结果了呢？“产生”不是将俄语俄文翻译为日语平假名吗 因为只有西里尔字母只能出现在右边，可从来没说过假名不能出现在右边——假名既可以出现在左边，也可以出现在右边 但是为什么呢？ 带着这个疑惑，现在聊一聊终结符号和非终结符号 所谓“终结符号”，就是不可再“产生”的符号，就是产生的“目的”，而“非终结符号”，可能是“产生”的开始，也可能是“产生”的中间产物，由于非终结符号到终结符号的关系，或者说翻译规则可能过于复杂，不能直接写出所有非终结符号到终结符号的产生式，只能第一步，先将非终结符号“产生”成为非终结符号和终结符号混在一起的形式，然后在后续的步骤中逐渐将所有的非终结符号替换成为或者说“产生”成为终结符号 最后，定义中所谓的“开始符号”，其实就是一个特殊的非终结符号，因为总得有一个起点，而且也只能从“开始符号变成第一个非终结符号(和/或)终结符号”开始，从这里继续下去去书写其它的产生式 因此，总的来说，要理解什么是“终结符号”和“非终结符号”，首先需要理解什么是“产生式” 先理解了“产生式”这个“谓语”，那么“非终结符号”和“终结符号”这两个“宾语”就好理解了 以上均为个人理解，欢迎勘误 上下文有关文法(CSG) 这一部分是扩展，在2023年4月4日新增。 在词法分析中，只需要使用正规式就足够应对各种工作，对应的自动机模型是有限自动机(有限自动机包括NFA和DFA，需要先设计NFA，再将NFA转化为DFA，并将DFA最小化才可以使用)。 而在语法分析中，仅仅用正规式这样的模型是不足以描述语言的，这时候需要引入文法，进行语法分析时一般使用上下文无关文法(Content Free Grammar)，对应的自动机模型是下推自动机。 这些都与本文的主题无关，与本文主题有关的是，既然定义了“上下文无关文法”，那么一定有与之对应的“上下文有关文法”。 确实如此，虽然不会用它，但是我们得知道那是什么东西。 上文中说，“终结符号”是转换的目的，其实留了一点东西没有提，那就是“有没有情况允许终结符号位于产生式的左边”？ 对于上下文无关文法来说，产生式头部，也即左边不允许出现终结符号。 但是对于上下文有关文法，产生式头部是会出现终结符号的，这些终结符号并不会被产生式推导展开，但是，出现在左边的终结符号会影响这个产生式的适用范围，这也是上下文有关文法何以与上下文“有关”。 这里用外语找例子不太好找，只能用字母来进行表示了 引用一下维基百科的例子 正规的非上下文无关语言{ }可由以下上下文有关文法生成: 123456789S → aSBCS → aBCCB → HBHB → HCHC → BCaB → abbB → bbbC → bccC → cc 这个文法中的a,b,c作为终结符号却出现在了左侧，因此它们就限制了与之组合的、作为产生式头部的非终结符号能够表示含义的场景； 非终结符号B的含义受到了同侧的终结符号a,b的限制；非终结符号C的含义受到了同侧终结符号b,c的限制； 不过这个例子也不是特别地好，待我再找找(搁置中) 总而言之，在文法中，终结符号有时可以出现在左侧，例如短语文法、上下文有关文法中都是可以这么做的 但是，属于文法范畴的上下文无关文法这个种类的文法中，任何情况下都不允许终结符号出现在产生式左侧 Knighthana 2023/03/29","categories":[{"name":"subject-note","slug":"subject-note","permalink":"https://knighthana.github.io/categories/subject-note/"}],"tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://knighthana.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"编译原理","slug":"编译原理","permalink":"https://knighthana.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"Visual Studio Code 的多行同时编辑","slug":"(KM)MultiArrayEditinVSC","date":"2023-03-27T16:00:00.000Z","updated":"2023-04-20T11:02:14.530Z","comments":true,"path":"KnowledgeMark/(KM)MultiArrayEditinVSC.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)MultiArrayEditinVSC.html","excerpt":"","text":"Visual Studio Code 的多行同时编辑 Visual Studio Code 提供了垂直方向同时使用多个光标以同时编辑多行的功能 按住Alt键，鼠标点击相应的行，以在该行上进行增加或删除一个光标的操作 虽然不知道有什么用，但是觉得这很酷","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://knighthana.github.io/tags/vscode/"},{"name":"code edit","slug":"code-edit","permalink":"https://knighthana.github.io/tags/code-edit/"}]},{"title":"从C主役开始学习Python","slug":"从C主役开始学习Python","date":"2023-03-27T16:00:00.000Z","updated":"2023-04-20T10:25:47.111Z","comments":true,"path":"Dev-Code/从C主役开始学习Python.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/%E4%BB%8EC%E4%B8%BB%E5%BD%B9%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0Python.html","excerpt":"","text":"从C主役开始学习Python I despised Python before 这篇博客无关程序设计基础，主要用于记录如何从C主役开始，学习如何使用Python 起因于深度学习，总结自课程PPT 但我决定用Python搞懂深度学习的基本概念之后还是回去继续拿起C用Torch吧 为什么要使用Python Python的问题有很多，诸如是一个解释器语言，运行效率底下，至今仍然在Python2和Python3双轨制并行运用，并且不知会在何时终结这种荒谬的状态，Python下的包及其多——“多”也包括它们的版本，几条pip install命令就会炸掉本地的Python环境，用缩进控制代码块，没有游标卡尺写什么代码，所谓二进制打包就是把脚本和解释器打包...... 这一切在一个C主役看来，完全就是不可理解的滑稽、荒唐、搞笑，这笑话能讲一年 但作为一个实用主义者，不得不承认，这东西是很方便——时间是一种很宝贵的资源，在学习阶段进行原理验证的时候不应该迷失在各种类型、地址和错误诊断与处理中 所以学习一下Python，铺平后续的学习之路 基本的变量、语法等信息 Python的变量、语法与C大同小异，如果有程序设计基础知识，阅读Python的代码应该不会感到太多困难 不过为了写出Python代码，还是需要理解一下Python的一些逻辑 首先Python的变量类型名很少，只有三个，int，float，bool Python也提供了“列表”、“元组”、“集合”、“字典”这样的“序列数据”数据结构，有的类似C中的“数组”，但各有各的特点 Python和C一样以某种列表的方式提供了字符串支持，不同之处在于，Python允许用单引号或者双引号表示字符串，而C的单引号用于表示字符，字符串只用双引号表示 运算符也和C代码类似，不同的地方是，C一般用位运算符进行逻辑运算，例如与&amp;，或|，非^，而Python直接使用逻辑运算符，and，or，not 定义函数方面，Python与C对比着看有不一样的地方，但是并不难以理解 1234def func(para1, para2, ...): foo bar return output Python中的数据结构 有了C语言中对“数组”的理解，对Python的数据结构理解就不会有什么困难 当然，需要一点面向对象思想才能更好地理解，但所谓“没吃过猪肉也见过猪跑”；如果把C的结构体、函数指针、指针、变量合在一起，有过以“结构体”——“结构体”，而非始终以“变量”——“函数”的思路进行程序设计的经历，也应该不会对“面向对象”感到陌生 列表 列表是一种用于存储序列数据的数据结构 用中括号[]创建 列表的元素支持修改、删除、新增等操作 list.append(*): 将一个项目添加到列表的末尾 list.sort(reverse=False,key=None): 排序 reverse: 升序或是降序 key: 关键词（与字典有关） list.count(*): 返回*在列表中出现的次数 list.index(*,start[,end[ ]]): 在'list'对象的列表中查找第一次出现*的位置索引，可选参数start与end限制搜索范围 list.reverse() 反转列表中的元素 list.pop() 将列表中的最后一个元素弹出来 （也就是说将列表当作堆栈使用） 元组 用小括号()创建 元组由一系列按特定顺序排列的元素组成 元组是不可变序列，一旦被创建，它的元素不可更改 集合 用set()方法或大括号{}创建 由无序的元素构成 没有重复的元素 支持集合的数学运算，例如并集、交集、差集等 字典 字典可以存储任意数据类型 每一个元素是一个键值对，键表示元素的关键词，值表示元素的取值 键和值用冒号分割，键值对之间用逗号分割 123456&gt;&gt;&gt;tel = {'jack':4098, 'sape':4139}&gt;&gt;&gt;tel['guido']=4127&gt;&gt;&gt;tel{'jack':4098,'sape':4139,'guido':4127}&gt;&gt;&gt;tel['jack']4098 类(面向对象特性) 一种捆绑数据和方法的数据结构，创建一个新类将创建一种新的实例数据类型 每个类的实例拥有相应的属性以维护其状态，同时也有用于修改和访问其属性的方法 具有面向对象编程的所有标准功能，可以继承多个基类，派生类可以覆盖其一个或多个基类的任何方法 动态特性：可以在创建之后进行修改 __init__(): 内置方法，创建并初始化实例属性 1234567891011121314class ClassName: &lt;statement-1&gt; … &lt;statement-N&gt;class MyClass i=12345 def f(self): return \"hello world\"class Complex: def __init__(self, realpart, imagepart): self.r = realpartself.i = imagepart 方法可以先存储，再进行调用 条件语句 可以有零个或多个elif(else if)分支；（这样的用法有些类似C中的switch语句） 这种情况下，else写在最后 for循环语句 for循环语句 与序列（如列表）配合使用，按序列所包含元素的排列顺序进行迭代 基本形式：for element in list 在仅指定迭代次数的情况下，可以使用内置的函数range()生成数字序列 range(start,stop[,step]): start, stop, step分别指定起点，终点和步长 输入参数只有一个时，指定终点，默认起点为0，步长为1 输入参数为两个时，指定起点和终点，步长为1 输入参数为三个时，起点、终点、步长分别是start, stop, step 如果需要根据索引来遍历一个列表，可以结合使用range(), len() 从Runoob摘抄的组合用法示例代码如下 12345678910&gt;&gt;&gt;x = 'runoob'&gt;&gt;&gt; for i in range(len(x)) :... print(x[i])... runoob with语句 通常用于访问或者占用计算机资源的场合，语句结束后会执行必要的“清理操作”，释放资源 numpy包 通常用于访问或者占用计算机资源的场合，语句结束后会执行必要的“清理操作”，释放资源 Numpy全称为Numerical Python，用于多维数据处理，包含大量的数学函数库 强大的多维数组表示能力 具备C/C++/Fortran等其他语言接口，可用于整合代码 能够解决科学计算，信号处理等领域的问题 可以对数组进行基本运算 并且结果仍然满足数组的性质 所想即所得 numpy中的方法举例 arange(): numpy中的方法，功能类似range() numpy中提供的对象举例 shape 数组变量的属性 ndim 数组的维度 dtype.name 数组的数据类型 itemsize 数组类型大小 size 数组元素的数量 OpenCV 视觉库 图像的几何变换 图像缩放 1resize(src, dsize[, dst[, fx[, fy[, interpolation]]]])-&gt;dst src：输入图像 dst：输出图像 dsize：目标图像大小 fx, fy：水平方向和垂直方向的缩放因子 interpolation：插值方法：最临近插值(INTER_NEAREST)，双线性插值(INTER_LINEAR)，双三次插值(INTER_CUBIC) 最临近插值：将最近的已知点像素的值直接赋给新产生的像素 双线性插值：最近的四个点的距离，算权重，进行加权平均获得新的像素点 双三次插值：拟合，得到二次方程，求解 图像的仿射变换 1warpAffine(src,M,dsize[,dst[,flags[,borderMode[,borderValue]]]])-&gt;dst src dst M：2×3的仿射变换矩阵 dsize flags：插值方法 borderMode：外扩模式 borderValue：当外扩模式为补充恒定值时的具体数值 图像滤波 高斯模糊 1GaussianBlur(src,ksize,sigmaX[,dst[,sigmaY[,borderType]]])-&gt;dst src dst ksize：高斯核大小 sigmaX：高斯核水平方向标准差 sigmaY：高斯核垂直方向标准差 borderType：像素外扩方式 Anaconda a python IDE and runtime 可以方便地管理多个Python版本和Python包的版本 Jupyter Notebook 是一个Python解释器 Jupyter Notebook占用的空间非常小，模块化，可以在网页上运行 TensorFlow Google Brain, 2015 用于搭建和训练深度神经网络 拥有健全的生态系统 \"Tensor\"的含义是“张量”，张量是一个很深的话题，在tensorflow中，tensor是一个多维数组，可以认为是一个矩阵 Tensorflow学习参考 Knighthana 2023/03/28","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://knighthana.github.io/tags/Python/"}]},{"title":"(KM)计算机系统中常见行为的耗时","slug":"(KM)ComputerSystemTimeConsuming","date":"2023-03-26T16:00:00.000Z","updated":"2023-04-20T11:08:08.177Z","comments":true,"path":"KnowledgeMark/(KM)ComputerSystemTimeConsuming.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)ComputerSystemTimeConsuming.html","excerpt":"","text":"计算机系统中常见行为的耗时 （具体时间数据已经过时） 行为 耗时 L1 cache reference 读取CPU的一级缓存 0.5ns Branch mispredict 转移、分支预测 5ns L2 cache reference 读取CPU的二级缓存 7ns Mutex lock/unlock 互斥锁上锁/解锁 100ns Main memory reference 读取内存数据 100ns Compress 1Ki Bytes with Zippy 1Ki字节压缩 10,000ns Send 2Ki Bytes over 1Gbps network 在1Gbps的网络上发送2Ki字节 20,000ns Read 1MiB sequentially from memory 从内存顺序读取1MiB 250,000ns Round trip within same datacentre 在同一数据中心内往返一次 500,000ns Disk seek 磁盘搜索 10,000,000ns Read 1MiB sequentially from network 从网络上顺序读取1Mi字节的数据 10,000,000ns Read 1MiB sequentially from disk 从磁盘里读取1Mi字节的数据 30,000,000ns Send packet CA-&gt;Netherlands-&gt;CA 将一个数据包在加利福尼亚与荷兰之间往返一次 150,000,000ns","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"Computer System","slug":"Computer-System","permalink":"https://knighthana.github.io/tags/Computer-System/"}]},{"title":"(KM)XML的DOM和SAX的区别","slug":"(KM)XML的DOM和SAX的区别","date":"2023-03-26T16:00:00.000Z","updated":"2023-04-20T10:41:03.665Z","comments":true,"path":"KnowledgeMark/(KM)XML的DOM和SAX的区别.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)XML%E7%9A%84DOM%E5%92%8CSAX%E7%9A%84%E5%8C%BA%E5%88%AB.html","excerpt":"","text":"XML的DOM和SAX的区别 (注意：这篇速记是在没有深入了解过这两个概念的前提下写出来的，因此只能提供粗略的刻板印象) 类型 SAX DOM 在XML体积大小方面 快速扫描大型文档，在感兴趣的地方停下来 需要读入整个文档建立树，应对大型XML文档比较无力 读取顺序 只能对文件按照顺序从前到后解析一遍，不支持随意访问 可以随意访问文件树的任何部分，也没有次数限制 读写访问 只读 可以读写文件树，以此修改XML文档 开发工作 复杂，需要自行制作事件处理器 易于理解和开发 模型 灵活，可以建立自己的XML对象模型 默认提供了树形模型 参考来源： XML中DOM和SAX的区别 明文指向了下方的原始引用 DOM和SAX的区别","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"XML","slug":"XML","permalink":"https://knighthana.github.io/tags/XML/"},{"name":"DOM","slug":"DOM","permalink":"https://knighthana.github.io/tags/DOM/"},{"name":"SAX","slug":"SAX","permalink":"https://knighthana.github.io/tags/SAX/"}]},{"title":"遗传算法的描述","slug":"遗传算法的描述","date":"2023-03-22T16:00:00.000Z","updated":"2023-04-20T07:10:05.087Z","comments":true,"path":"subject-note/遗传算法的描述.html","link":"","permalink":"https://knighthana.github.io/subject-note/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E6%8F%8F%E8%BF%B0.html","excerpt":"","text":"计算智能课上遗留遗传算法问题的课后思考 计算智能课上讲到遗传算法，在“遗传算法用于求解数值优化问题”部分有点跟不上老师的速度，课间和回来之后翻书重新看这一部分，希望能有所理解。 这些都是我的个人理解，请自行辨别正误。 课上PPT举出的例子的具体数值和我课后用的教材上的数值不太一样，但不影响理解。 要用遗传算法解决问题，第一步需要映射，将所求的目标映射到二进制空间；因为遗传过程中需要的交叉变异需要通过位运算进行，二进制数字才能比较好地进行位运算。 题目 例题，无约束单目标优化问题： s.t. 是指 subject to （such that），“受约束” 翻译一下，这道题说的是，求使得 能够达到最大值时，与值，其中和的取值范围受以上约束 我怀疑这教材是想顺便锻炼一下读者的英文文献阅读能力 要求精度达到小数点后五位 根据题目条件求二进制数字串的长度 第一步，将区间按照精度要求进行映射，粗俗一点地解释就是将运算区间映射到题目指定“分辨率”的二进制数字串，为什么是二进制数字串？因为我们需要通过后面对二进制数串（所谓“遗传信息”）进行位操作，体现“遗传”的思想。 这个二进制数串的长度应该充分反映题目中要运算的各个数值，本题中我们需要对两个数值使用遗传算法，因此需要求出这两个数值各自占用的比特长度，然后将它们相加，获得本题需要的比特长度。 为变量 的最大值， 为 的最小值，用 的最大值减去 的最小值，就求出了原始数值浮动的区间，然后再乘以题目要求的精度带来的倍数—— ，于是得到了本题所用的区间长度，此时的区间长度是用十进制数字表示的 第二步，将十进制数字区间映射到二进制数字区间，十进制到二进制肯定不会那么“恰巧”是一个整进制数，于是我们只能求出最近的二进制边界整进制数值，也即 代入本题数值，即求 和 中的 和 求得 为21bit， 为18bit 需要的总比特位 ，代入数值，于是得到总比特长度 种群初始化 接下来是随机生成符合长度要求（也仅仅只是符合长度要求）的二进制数串。数串的内容完全随机。书上的例子是给了十个个体，那么我们认为容纳这个种群的环境给了10个个体数目的供给， 第一个是0000 0101 0100 1010 0100 1101 1110 1111 1110 001 第二个是0101 1001 0110 1011 1011 1010 1110 1100 1110 110 第三个是1011 1000 1100 1101 1101 0101 1101 1110 0010 011 …… 第九个是1110 0010 1111 0111 1101 1111 1011 1110 0111 111 第十个是1111 1001 0111 0011 1100 1010 0011 1011 1011 110 这些都是随机生成的满足长度要求的二进制数字串，鉴于需要的篇幅太长，我懒得写了，有兴趣的读者请翻阅《计算智能导论》尚荣华等编著.西安电子科技大学出版社.ISBN 978-7-5606-5344-0.第59页查看剩下的几个随机数例子 个体评价（遗传表达） 如果要对这些二进制数串代表的内容进行评估，就需要一个将其映射回原来十进制数字的“还原算法”，姑且认为是开动了蛋白质工厂照着基因生产蛋白质。 二进制遗传信息到十进制数字表征的算法如下： 位二进制数串对应的十进制数字 例如，假设在计算的某一步我们获得了以下遗传信息，需要将其转化为十进制数字 注意，这个二进制数串只是举例时随机拿出的，并不具有特别的含义，而且我们仅仅将二进制数串看做一个零一序列，在进行转换之前不在意其数字意义 21bit 18bit 0000 0101 0100 1010 0100 1 1011 1101 1111 1100 01 &lt;---------------------39bit-----------------------&gt; 接下来开始转换 以下Bin指Binary——二进制，Dec指Decimal——十进制，不再赘述 于是前21bit的 对应的转换(000001010100101001001)Bin=(43337)Dec 后18bit的 对应的转换(101111011111110001)Bin=(194545)Dec 于是我们从没有数学含义的二进制零一数串转化，得到了两个具有数学含义的十进制数字 接下来是评估，评估方法和题目有关，所谓的用于衡量是否满足评估标准的值，在遗传算法中称为“适应度”，例如本题对每个“遗传信息”求对应的“适应度”函数eval（evaluate，评估，vt.）就是： 这里的 教材上没有说明是什么含义，但是不难猜测，v可能是指vector，向量，即一组有顺序的数字 于是以上面的遗传信息000001010100101001001101111011111110001作为例子，其对应的十进制有意义数字我们上一步已经求得，分别是 和 ，代入 于是以此类推，可以求得 …… 题目要求是令函数取得最大值，简单地比较一下大小，发现 最大， 最小 选择（物竞天择） 教材上管这个叫“轮盘赌”，这个过程画成转盘的方式确实比较直观一些，但是我用另一个思路来理解这个问题 如果觉得轮盘赌很难理解的话，可以把它理解为一个一维随机变量： 先画出一个有长度的线段， |---------------------------------------------| 令每个个体按照其适应度（ 的值）在线段上按比例占领一定的长度， |--1--|--2---|--------3--------|---4---|--5---| 最后在一维横轴给定区间上以定模长的方式取区间内的随机数 第一次取随机数：|------^--------------------------------------| 第二次取随机数：|--------------------^------------------------| …… 第种群数目次取随机数：|-------------------------------------------^-| 随机数落到哪里就认为哪个个体被进化接受了 具体的计算，根据教材上的案例一步一步来说的话是这样的（注意，我的写法和教材并不完全一致） 计算群体的总适应度 ， 代入之前给的例子 ，计算得到 计算随机取点落到每个个体所在区间内（认为该个体适应了选择）的概率 …… 根据上述概率，求出每个区间的下限 和上限； 例如对于 ， 它的区间下限就是0，上限 |------|----------------------------------------------| 0-----------------------------------------------------1 对于 ，它的区间下限是 ，上限是 ，其中 上一步计算出结果是0.1161，而 |------|----|------------------------------------| 0------------------------------------------------1 对于 ，区间下限是 ，上限是 |------|----|--|---------------------------| 0------------------------------------------1 以此类推，如上面第一行所说， 的区间下限是 ，区间上限是 ， 通过累加 得到 ；为 加上 就可以得到 随机生成 区间内的数字共k个，然后让每个随机数落在这个总长度为1的区间上，选出这k个被落到的个体 （这里吐槽一下，我发现上面做了那么多除法运算就是为了把整个总适应度映射到区间上，方便把生成的随机数撒上去，但实际上对随机数取模的时候完全可以以整个总适应度为长度取模，从而避免大量的除法运算；不知道为什么不这样做，难道是不好控制精度？） 12345repeat:10 srand(time(0)) int ir=rand()%10000 float fr=r/10000end 假设生成的数字是0.7060, 0.0318, 0.2769, 0.0462, 0.0971, 0.8235, 0.6948, 0.3171, 0.9502, 0.0344 于是对应地，被落到的个体依次是 于是我们称这些个体 被选择了，它们适应了外部条件，至于其他的个体就被淘汰掉了，不过不要着急，实验还没结束，我们仍然需要记录新的种群中的每个个体，这时候需要按照上面随机数落下的顺序记录每个个体，无论是否重复，并且按照随机数落下的顺序赋予它们新的个体编号 于是，新一轮的个体分别是： （原 ，篇幅所限上面没有给出过 的遗传信息） （原 ，照抄即可） （原 ，篇幅所限同样之前没有给出过个体的遗传信息） （原 ，注意出现了重复遗传信息的个体，这是自然选择，不要管，照抄即可） …… （原 ，照抄） （原 ，照抄） 这样，我们就得到了新一轮种群中的个体，并记录了它们的遗传信息 交叉（染色体互换） 染色体交叉互换是自然界生物有性生殖中的重要部分，遗传算法刻意模仿了这个过程 但不完全 任取两个幸运个体，例如 和 ，令 和 进行生命大和谐，假设产生了两个子代 和 每次生命大和谐时，我们都随机地取一个遗传信息上的位置作为断点，从这里将亲代的遗传信息裂开，然后交叉互换，将互换之后的结果称为子代 （阅读表格前请注意：断点是随机选择的，从断点处将遗传信息人为地分为了前半部分和后半部分） 我们随意地取17作为断点位置 亲代 遗传信息前半部分 遗传信息后半部分 亲代甲 1001 1011 0100 1011 0100 1000 0000 1011 1001 001 亲代乙 0011 1010 1110 0110 0000 1000 0101 0100 1000 001 进行交叉互换，注意遗传信息后半部分 子代 遗传信息前半部分 遗传信息后半部分 子代甲 1001 1011 0100 1011 0000 1000 0101 0100 1000 001 子代乙 0011 1010 1110 0110 0100 1000 0000 1011 1001 001 变异（基因突变） 基因突变比较简单，随机选一个“幸运”(考虑到一般来说基因突变都是有害的，说幸运不如说倒霉)个体，在它的遗传信息上随机选一个“幸运”基因，1变0，0变1 例如我们选择了“幸运”个体 ，用高能射线照射，令其基因突变，于是遗传信息上随机位置处的基因说变就变 假设是16位基因遭到了突变(mutation) 个体 遗传信息其他部分 受影响基因 遗传信息其他部分 原个体 1001 1011 0100 101 1 0100 1000 0000 1011 1001 001 突变个体 1001 1011 0100 101 0 0100 1000 0000 1011 1001 001 流程 至此，我们已经将整个流程中的每个环节介绍完毕，现在将它们组合起来 12345678910产生初始种群P&lt;t&gt;[]do{ 子代种群C&lt;t&gt;[] ← 染色体互换(一部分P&lt;t&gt;[]); 突变种群M&lt;t&gt;[] ← 基因突变(一部分P&lt;t&gt;[]); /*没有进行染色体互换或者基因突变的个体P&lt;t&gt;[]姑且称为P'&lt;t&gt;[]*/ P&lt;t+1&gt;[] ← 物竞天择( eval(P&lt;t&gt;'[],C&lt;t&gt;[],M&lt;t&gt;[]) ); P&lt;t&gt;[] ← P&lt;t+1&gt;[];}while(继续循环的条件)output(P&lt;t&gt;[]) 注意到亲代生出子代之后，亲代就消失了，可以，这很三体星人 实验结果 实验结果和评估啥的翻教材第64页吧，我这里就不写了。况且图片用Markdown它也画不出来 “悬崖”问题 用二进制数字串编码反映十进制数字世界存在“悬崖问题”，如果我们需要对十进制数字的一位进行变动，可能牵扯到许多位二进制数串 所谓表征空间个体之间的距离和其遗传信息的Hamming距离二者之间的差距 例如，不断运作的筛选算法需要个体的某段表征为8Dec才能符合条件，但是目前这个个体的表征为7Dec，也就是说其遗传信息目前是(0111)Bin，使其变动为8Dec对应的(1000)Bin,需要四位二进制数串全部发生变化，这很困难 很显然这是进制之间互相映射，以及我们忽略了二进制数串的数学含义（所有的数学运算都是在映射到十进制之后进行的，在二进制域我们实际上只进行过位变换）两方面因素共同导致的 这类问题可以通过选用合适的编码方法缓解 Knighthana @ XDU 2023/03/23","categories":[{"name":"subject-note","slug":"subject-note","permalink":"https://knighthana.github.io/categories/subject-note/"}],"tags":[{"name":"遗传算法","slug":"遗传算法","permalink":"https://knighthana.github.io/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"},{"name":"计算智能","slug":"计算智能","permalink":"https://knighthana.github.io/tags/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD/"}]},{"title":"家目录下的rc和profile文件","slug":"家目录下的rc和profile文件","date":"2023-01-13T16:00:01.000Z","updated":"2023-04-18T16:00:00.000Z","comments":true,"path":"Dev-Env/家目录下的rc和profile文件.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E5%AE%B6%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84rc%E5%92%8Cprofile%E6%96%87%E4%BB%B6.html","excerpt":"","text":"Tag 2023-04-19_21-52-09.png linux-shell; config-file 在Linux下诸如 .profile .*shrc 这样的问题 首先作为一名zsh用户应当懂得一个基本的道理，选择走人少的路总是有代价的。不过，如何处理因为解决这些代价而投入的成本，也影响着后面的得失，如果能因此彻底搞清一些问题，也是有一些收益的。 例如，为了搞好一个方便一点的博客系统，需要用到gem，需要优雅使用gem，则需要优雅地设置有关.gem/的环境变量，为了优雅地设置环境变量，需要调整开机时默认执行的脚本。 传统的草台教程中提到的修改.bashrc、.bash_profile的方法肯定是不行的，使用zsh的情况下，即便是修改.profile的方法也变得不可行起来，为了弄明白这些问题，还得对这套自动系统有一些进一步的深入了解才行。 如果有较好的英文基础，先阅读Zsh not hitting ~/.profile，然后应该就不用看下面的东西了。 简单来说， 出于语法兼容性方面的原因，zsh不会加载系统原来的.profile文件。 在登入时，zsh加载~/.zprofile文件 在打开一个新的终端会话时，zsh加载~/.zshrc文件 目前来看，安装过并且正在按照oh-my-zsh的方式运行zsh，并不会影响.zprofile文件正常发挥作用 Knighthana 2023/01/14 更新1 卸载了oh-my-zsh之后，会留下一个.zshrc.omz-uninstalled-$DATETIME文件 这个文件是留着给人读的 重新安装omz之后，需要阅读一下这个文件，记得把以前自动化工具写进去的那些自己没留意过的配置文件迁移到新安装的.zshrc或是其他起作用的rc或profile里面 更新2 对于ZSH+LightDM用户来说，可能会遇到.zprofile未能加载的问题，这好像和大多数DM的一些不够智能有关系 总之，如果不是纯CLI方式(比如用TTY不开X11，或者SSH)的方式以zsh作为登录Shell，那么.zprofile就是废纸一张 ZSH not sourcing zprofile Solved .zprofile not sourced Correctly setting environment 不过即便安装了zsh，lightdm仍然会去加载.profile(想想也很合理，你安的是zsh，那zsh parse不了标准的profle关我lightdm屁事) 那就把需要在登陆时设置的环境变量一类的东西弄到.profile里面就可以了 我迁移了一些.zshrc中的语句到.profile，重启，使用lightdm登录 试了一遍rbenv nvcc th npm 都能正常工作，暂时认为没有问题 此外，通过观察可以发现，.zshrc和.profile的生命周期是不一样的 在rc中的内容，只要关闭了虚拟终端就会立刻失效，下一次打开终端时会重新读取载入然后生效 而profile中的内容，会在登录期间持续生效，与何时打开多少终端没有关系 所以环境变量什么的需要长生命周期且需要花费很长时间来加载的东西，就写在profile里面即可，不然浪费启动终端时的响应速度就很不美好了。 Knighthana 2023/04/19","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://knighthana.github.io/tags/shell/"},{"name":"home path","slug":"home-path","permalink":"https://knighthana.github.io/tags/home-path/"},{"name":"config","slug":"config","permalink":"https://knighthana.github.io/tags/config/"}]},{"title":"网络连接问题及网络连接工具的问题集","slug":"网络连接问题及网络连接工具的问题集","date":"2023-01-13T16:00:00.000Z","updated":"2023-05-02T08:18:00.000Z","comments":true,"path":"Dev-Env/网络连接问题及网络连接工具的问题集.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%E5%8F%8A%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E9%97%AE%E9%A2%98%E9%9B%86.html","excerpt":"","text":"网络连接问题及网络连接工具的问题集 熟练解决网络问题是程序员们的必修课 安装proxychains4 直接通过包管理器安装proxychains会安装proxychains3，这是一个很旧的版本（其实能用； 不过我为了排除各种问题，例如解决软件过旧之类的疑虑，最后安装了proxychains4，也被称为proxychains-ng，这是一个最新的实现； 假如不慎和我一样，并非通过包管理器，而是通过下载源码并且以sudo make install的方式安装的话，那么在/usr/local/bin中可以找到它的程序，不过这种方式不受包管理器记录和控制，对于日后的维护工作来说不太方便； 另外，proxyresolv功能默认没有安装，需要自己从源码的src/中拷贝出来放到PATH中，我的话是和proxychains4的二进制文件放在一起了； proxychains4的四种dns_proxy设置 可以从 官方带有说明的配置文件 中获取到关于各种配置的详细说明 不设置任何dns proxy项目，也即不进行dns的代理，这种情况下，被proxychains4代理的程序会擅自（可能程序自己不这么觉得）调用系统的DNS请求相关功能，查询自己要访问的目的主机的IP地址，交给proxychains4的是一个IPv4地址；(然后proxychains4将这个IPv4原样传给端口监听程序，那边没有识别出来，完美地走了通常的通道，仍然慢速甚至断流，鼓掌！啪啪啪啪啪啪啪) 为什么不效仿浏览器，直接从socks5里面传domain-name过去，非要自己去搞那个什么IP-address？很好玩吗？ proxy_dns_old模式，这种模式下，被代理的程序还是会发出DNS请求，只不过请求被proxychains4截获，并且用一个proxychains4程序自己的proxyresolv脚本代为办理了，但是可能我技术水平有限，目前发现这个脚本只能设置DNS_SERVER=，但是基于众所周知的原因，这种形式并不稳定； dns_proxy模式，这种模式会发送domain-name给对应的port，但是，某些老旧的程序和脚本，例如我发现的(也是最常用的场合)，oh-my-zsh的upgrade.sh并不支持这种模式，于是会卡在[proxychains] DLL init: proxychains-ng 4.16这条提示，天长地久，直到海枯石烂；(23/04/20：和ssh有关的话，可以怀疑是BUG导致的) proxydns_daemon模式，这目前是一个实验模式 method 3. use proxychains4-daemon process to serve remote DNS requests. this is similar to the threaded proxy_dns method, however it requires that proxychains4-daemon is already running on the specified address. on the plus side it doesn't do malloc/threads so it should be quite compatible with complex, async-unsafe software. note that if you don't start proxychains4-daemon before using this, the process will simply hang. 对于Linux内核版本大于等于5.9且proxychains4版本小于4.16-2(不等于)的使用者来说，如果要通过proxychains4使用ssh以及工作在ssh模式的git，就必须使用这个模式， 因为新版本glibc中增加的new close_range syscall导致的此软件中close()钩子发生问题，而这个问题被修复的版本是4.16-2 被自己挖过的坑hosts文件坑 之前一直纳闷为什么某些请求始终是IPv4，起初以为是工具或者网站的问题，仔细一看地址再一回忆，原来我改过hosts文件。改回来就正常了。 总结 我还是需要找一些终端下更靠谱的工具，解决各种不稳定和断流的问题。 实在不行的话恐怕还得自己动手？ Knighthana 2023/01/14 更新： 修改了 proxychains4的四种dns_proxy设置 一节的内容 原因是： ssh (and thus git) doesn't work anymore with proxydns and latest glibc #439 proxychains-ng doesn't work with ssh on Ubuntu 22.04 Knighthana 2023/04/20 修改了 我只知道它存在，但是没有找到任何有关这个东西的说明文档， 部分 原因是，其实是有说明文档的，位于GitHub: proxychains-ng/src/proxychains.conf Knighthana 2023/05/02","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"Network","slug":"Network","permalink":"https://knighthana.github.io/tags/Network/"},{"name":"DNS","slug":"DNS","permalink":"https://knighthana.github.io/tags/DNS/"}]},{"title":"鸡胸肉咖喱饭","slug":"鸡胸肉咖喱饭","date":"2023-01-04T16:00:00.000Z","updated":"2023-04-20T12:02:33.123Z","comments":true,"path":"Cooking/鸡胸肉咖喱饭.html","link":"","permalink":"https://knighthana.github.io/Cooking/%E9%B8%A1%E8%83%B8%E8%82%89%E5%92%96%E5%96%B1%E9%A5%AD.html","excerpt":"","text":"鸡胸肉咖喱饭 咖喱饭是一种非常简单，但足够美味的碳水油脂炸弹型餐食，肉咖喱饭能够很好地提供人体所需的营养。 我没有什么减肥的需求，所以就可以多搞点咖喱饭吃。 咖喱块包装盒的说明如下： 咖喱1盒100g，水600ml，油2调羹30g，鸡肉或其他肉300g，洋葱半个200g，土豆1个300g，胡萝卜1根100g。倒油烧热，再将切好的洋葱肉类胡萝卜土豆依次下锅翻炒。加水至刚好没过食材，炖煮至食材柔软，煮熟后关火。将咖喱块掰开全部放入，搅拌至完全融化，开火炖煮至浓稠状，浇在米饭上就可以享用。 我实际做的时候基本是照这个流程一步一步来的，比如买了一个刚好一斤的洋葱，一剖两半约250g，胡萝卜也是一根，鸡胸肉挑了一块大的，但也仅约0.228kg，不到300g；不过有一些大不一样的地方，一是我比较喜欢土豆，因此削了两个，但没减少其他食材的量，这导致食材多出来了煮了很久，最后吃了两顿才吃完，二是我看错了说明，以为这些食材是一盘的量，因此对这一大锅菜一开始只放了一块25g的咖喱，后来觉得颜色不对又放了一块，共50g，但吃完总结的时候才发现包装上面写的是四盘放四块咖喱的量。 煮的时候水倒得有点多，结果发现菜里的水分也出来了，锅里的汤越炖越多，不过好在最后大火烹煮了半天汁终于收掉了，只是有点费天然气，下次可以试试少放些水，不过还得留够让食材内部煮熟而且外表不焦的水，不然的话为了省点气浪费了食材就本末倒置了。 由于只放了一半的咖喱，因此这次的咖喱饭没有那种典型的酱状质感和颜色。奇怪的是我放了两块咖喱就已经觉得油盐足够了，放四块的话会不会油盐过重？对于碳水和油脂的摄入我是没什么畏惧的，但是钠这东西还是应该按照营养推荐的来。 米饭煮了很多次，已经很拿手了，一个是水米比约一比一，水可以多但不能少，否则会糊；水稍稍多放一些可以煮出软一些的米饭，这样的米饭可以立刻趁软吃，也能放一会等它变硬再吃，留出一些选择的空间；小火煮的时间控制在三到四分钟之内，之后必须换成火苗，总时间控制在五分钟之内，关火后米饭需要在锅里焖一会。其它的倒也没什么了。 Curry!Rice! Knighthana 2023/01/05","categories":[{"name":"Cooking","slug":"Cooking","permalink":"https://knighthana.github.io/categories/Cooking/"}],"tags":[{"name":"CurryRice","slug":"CurryRice","permalink":"https://knighthana.github.io/tags/CurryRice/"}]},{"title":"(KM)常见的红和蓝及其渊源","slug":"(KM)RedandBlueDictConfuse","date":"2022-12-20T16:00:00.000Z","updated":"2023-04-20T11:09:03.833Z","comments":true,"path":"KnowledgeMark/(KM)RedandBlueDictConfuse.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)RedandBlueDictConfuse.html","excerpt":"","text":"红宝石与蓝宝石 红宝石，即红色的刚玉宝石，包括了红色、橙红色、紫红色、褐红色的刚玉宝石 蓝宝石，即除去红宝石以外的所有刚玉宝石 红宝石只有一个颜色，蓝宝石则有蓝色蓝宝石和彩色蓝宝石之分 红藻与蓝藻 红藻门属于泛植物界，是真核生物 蓝藻不是植物，蓝藻是原核生物，又名蓝细菌，属于细菌，陆生细菌 海带即非红藻亦非蓝藻，海带属于褐藻纲，内共生绿藻或红藻，褐藻在假菌界","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"生物学","slug":"生物学","permalink":"https://knighthana.github.io/tags/%E7%94%9F%E7%89%A9%E5%AD%A6/"},{"name":"宝石","slug":"宝石","permalink":"https://knighthana.github.io/tags/%E5%AE%9D%E7%9F%B3/"}]},{"title":"停电，然后失去git文件","slug":"停电，然后失去git文件","date":"2022-12-05T16:00:00.000Z","updated":"2023-04-20T11:38:56.174Z","comments":true,"path":"Blog-Maintenance/停电，然后失去git文件.html","link":"","permalink":"https://knighthana.github.io/Blog-Maintenance/%E5%81%9C%E7%94%B5%EF%BC%8C%E7%84%B6%E5%90%8E%E5%A4%B1%E5%8E%BBgit%E6%96%87%E4%BB%B6.html","excerpt":"","text":"停电，然后失去git文件 半夜敲代码没看时间，然后遇到熄灯停电； 本来以为积极保存代码能躲过一劫，事实上代码确实没问题，而且commit的时候也没有遇到问题； 然而最终发现，基于WSL内文件系统的git文件损坏了；例如进行远程push的时候，抛出了一大堆问题，例如inflate: data stream error (unknown compression method) unable to unpack 4f51a0a09060036272c441837705d2bd64156f61 header； 有人提到过这样的问题，Git error: inflate: data stream error (unknown compression method) 抱歉，我只是个学生，还得完成我的主要代码，修复这些git文件不是目前要考虑的问题； 所以只能先把文件复制出来，然后重新执行pull-copy-add-commit-push的操作； 这样的话会丢掉中间好几次的commit注释信息，所幸注释里面只写了一些编译器报错内容，方便下次定位问题。 今天本来也只是被舍友一大早赶车吵醒所以早起的，这会困意又席卷而来，无力与这样的git文件系统破碎问题纠缠，先这样吧。 Knighthana 2022/12/06","categories":[{"name":"Blog Maintenance","slug":"Blog-Maintenance","permalink":"https://knighthana.github.io/categories/Blog-Maintenance/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://knighthana.github.io/tags/Git/"},{"name":"WSL","slug":"WSL","permalink":"https://knighthana.github.io/tags/WSL/"},{"name":"Blog","slug":"Blog","permalink":"https://knighthana.github.io/tags/Blog/"}]},{"title":"(KM)用英语描述次数","slug":"(KM)用英语描述次数","date":"2022-11-26T16:00:00.000Z","updated":"2023-04-20T09:55:00.000Z","comments":true,"path":"KnowledgeMark/(KM)用英语描述次数.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)%E7%94%A8%E8%8B%B1%E8%AF%AD%E6%8F%8F%E8%BF%B0%E6%AC%A1%E6%95%B0.html","excerpt":"","text":"Discribe Times in English times description description 1 single 2 double 3 triple 4 quarduple 5 pentuple quintuple 6 sextuple hextuple 7 septuple 8 octuple 9 nonuple 10 decuple 11 hendecuple undecuple 12 duodecuple 100 centuple personal wiki de Knighthana 2022/11/27 commits: 2023/03/27 edited: added markdown-type sheet commit: 2023/04/20 edited: make it more like a sheet","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"英语","slug":"英语","permalink":"https://knighthana.github.io/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"关于VirtualBox在虚拟机操作系统中共享文件夹的一个猜想","slug":"关于VirtualBox在虚拟机操作系统中共享文件夹的一个猜想","date":"2022-07-06T16:00:00.000Z","updated":"2023-04-20T10:27:43.143Z","comments":true,"path":"Dev-Env/关于VirtualBox在虚拟机操作系统中共享文件夹的一个猜想.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E5%85%B3%E4%BA%8EVirtualBox%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%B8%80%E4%B8%AA%E7%8C%9C%E6%83%B3.html","excerpt":"","text":"关于VirtualBox在虚拟机操作系统中共享文件夹的一个猜想 我注意到VirtualBox的虚拟机中，共享文件夹功能在更换内核之后就无法使用了 所以我的猜想是，VirtualBox的GuestAdditions通过向内核安装了一个内核模块，来实现扩展的额外功能 而这其中就包括了共享文件夹功能 所以在更换内核之后，由于原先安装的内核模块不在新启动的内核上面，因此共享文件夹功能就不可用了 当然目前仅仅只是一个猜想 这个猜想主要是为了解决一个问题，就是“为什么已经安装了VirtualBox GuestAdditons工具，仍然无法创建和访问共享文件夹” 解决方案是更换到安装了该功能的版本的内核 Knighthana 2022/07/07","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"VirtualBox","slug":"VirtualBox","permalink":"https://knighthana.github.io/tags/VirtualBox/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://knighthana.github.io/tags/Ubuntu/"},{"name":"Kernel","slug":"Kernel","permalink":"https://knighthana.github.io/tags/Kernel/"}]},{"title":"(KM)一些图片查看器","slug":"(KM)SomeImgViewer","date":"2022-06-23T16:00:00.000Z","updated":"2023-04-20T11:05:02.565Z","comments":true,"path":"KnowledgeMark/(KM)SomeImgViewer.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)SomeImgViewer.html","excerpt":"","text":"一些图片查看器 当仅仅安装了用于启动桌面环境的一部分包，而没有完整且冗余的图形环境支持时，可能需要一些仅仅有X就可以运行的图片查看器 一个是(feh)[https://feh.finalrewind.org/]， 另一个是(GPicView)[http://lxde.sourceforge.net/gpicview/]，on github 检索页面 还有就是很早以前，曾经用过的imagemagick","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://knighthana.github.io/tags/Software/"},{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"}]},{"title":"自己搞一个Linux系统调用的一点记录","slug":"自己搞一个Linux系统调用的一点记录","date":"2022-06-09T16:00:00.000Z","updated":"2023-04-20T07:25:00.000Z","comments":true,"path":"Dev-Code/自己搞一个Linux系统调用的一点记录.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/%E8%87%AA%E5%B7%B1%E6%90%9E%E4%B8%80%E4%B8%AALinux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95.html","excerpt":"","text":"自己搞一个Linux系统调用的一点记录 项目的缘起是同院不同专业后辈的大作业。我看了一下作业的内容，发现涉及到的深度比我专业之前该课程涉及的深度还要深，甚奇之。 开始着笔写文章的时候已经折腾了24个小时，而我中间仅仅睡了不到五个小时，所以急需记录一下涉及到的问题，以免突然倒地之后忘记（ 作业的题目是“在Linux内核中添加一条自己的系统调用，按照某规则显示个人学号的后X位”，有意思的是题目中示例是16年的学号，而且据说提供的示例代码基于Ubuntu 10.04，至少是2010年之前的事情，所以如果现在还做不到吃透这道题多少有些失败。这也是我和它杠上的原因。 我寻思着与其看那上古的 Ubuntu 10.04 代码，然后不知所云地搞出一个知其然而不知其所以然的玩意，不如用近几年的 Ubuntu 和新一点的内核开刀。 值得一提的是Robert Love在他的著作Linux Kernel Development提到not implement a system call，并且给出了非常详实的理由，所以最好不要通过乱改系统的系统调用表实现自己要实现的功能，否则在kernel.org更新内核之后，自定义的内核和用户空间程序都会变成不兼容的废物，不过这是课程实验无需上纲上线（ 于是，在开写这篇文章之后又折腾了两三天。最后估计花了得有四五天时间，算作96个小时，终于搞出了一个比较满意的结果（但不能算完全满意）。 customsyscall-output 记录一下踩过的坑。 排坑指南 没遇到坑之前可以跳过这部分直接看后面的“步骤”一节 点击目录图标，待目录弹出后点击“步骤”即可 使用无图形的系统还是有图形化界面的系统 我的建议是用有图形化的，因为这涉及到是否有方便的面向项目目录编辑工具，是否有多国语言支持，是否能开出数个模拟终端用于不同的工作，是否有一个能随时用于查找问题的浏览器等和开发速度有关的问题。 尽管图形界面会带来额外的开销，额外的不稳定性，额外的库需求。 但是如果懒得搞ssh的话，一个良好的人机界面值得这些。 内核版本问题 首先是版本的问题。我日常开发用的是Ubuntu 20.04.4 LTS on WSL，uname -r或者neofetch一下可以得知内核版本为\"4.4.0-18362-Microsoft\"，于是我理所当然地以为Ubuntu的官方发行版内核版本也在4.x左右，甚至特意挑选了18.04 LTS这个较老的版本（其实本来想用16.04 LTS，但是镜像站的16.04已经404了）。 这造成了第一个悲剧：我下载了一份4.15.3的源码埋头开始了工作。 Ubuntu 18.04.6 LTS 最新的内核版本为 5.4.0-113，众所周知，旧系统可以兼容新内核，但新系统基本不能兼容老内核，这是第一个雷。 这个雷导致的后果是，4.15.3的内核无法启动 Ubuntu 18.04LTS 的图形界面，这使得原来指向虚拟终端的文件指针无法使用，在这种情况下必须改成指向实际终端的文件指针。 最后完成的版本使用的内核版本是5.18.2，高于Ubuntu 18.04.6 LTS所使用的5.4.x，这样就能成功运行Ubuntu 18.04.6LTS的大多数功能了。 磁盘空间问题 然后是第二个问题，在创建虚拟机磁盘文件时，需要选择一个合理的磁盘空间，我错误估计了这个过程所需要的磁盘空间。按自己以往的经验，单个Ubuntu虚拟机分个20GiB足矣，考虑到也许、可能不够，我又加了10GiB，“添加的数量已经是原本预计数量的1/2了，总数30GiB，对于一个没有其他任务的系统来说已经很多了吧”。 这就是想当然了。 第二个悲剧：为虚拟机分配的30GiB磁盘空间不足以容纳Ubuntu 18.04.6 LTS系统自身和编译内核过程中产生的文件。编到一半，Low Disk Space了，编到最后，No enough space on disk。 按照目前的统计，64GiB硬盘空余30GiB，因此至少得预留35GiB才能保证不出问题，稳妥起见，40-60GiB是比较合适的，当然这仅仅适用于在18.04LTS上编译5.18.2的情况。 然而现在发现，磁盘空间不足的问题也是在.config中没有要求不编译大多数用不上的模块导致的，编译前使用make localconfig可以有效地减少磁盘空间占用 性能问题 为虚拟机分配多少CPU和内存合适？我按照默认选择了1核心和1024MiB内存。对于日常使用而言当然是绰绰有余的，但是这不是日常情况。 在经历了在我自己的计算机（4C8T16G）上为虚拟机分配2核心8GiB内存进行编译之后，目前我已经将工作迁移到了另一台实验室公用的计算机上，向虚拟机分配了12核心16GiB内存，make -j12，但是速度依然慢到令人烦躁。 “这就是对生产力工具的性能要求” 依赖工具 编译内核需要，但是可能没有自动安装的工具（或者说软件包和库）包括 列表 flex lex产生词法分析器的开放源代码版本 Lex读进一个代表词法分析器规则的输入字符串流，然后输出以C语言实做的词法分析器源代码。(https://zh.wikipedia.org/zh-cn/Lex) flex（快速词法分析产生器，英语：fast lexical analyzer generator）是一种词法分析程序。它是lex的开放源代码版本，以BSD许可证发布。通常与GNU bison一同运作，但是它本身不是GNU计划的一部分。(https://zh.wikipedia.org/zh-cn/Flex%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8) bison Bison is a general-purpose parser generator that converts an annotated context-free grammar into a deterministic LR or generalized LR (GLR) parser employing LALR(1) parser tables.(https://www.gnu.org/software/bison/) 噔!噔!咚! “上下文无关语法” “LR分析法” 这一下给我轰回了编译原理的课堂，让我想起了被文法支配的恐惧 build-essential 这个在linux下做开发都要用到，不必多说 libncurses5-dev The ncurses (new curses) library is a free software emulation of curses in System V Release 4.0 (SVr4), and more. It uses terminfo format, supports pads and color and multiple highlights and forms characters and function-key mapping, and has all the other SVr4-curses enhancements over BSD curses. SVr4 curses became the basis of X/Open Curses. (https://invisible-island.net/ncurses/announce.html) 一个终端下的图形库，至少在make menuconfig过程中和那个图形化配置菜单有关 openssl和libssl-dev 与加密过程有关，至少安装的时候会涉及到签名问题 zlibc和minizip 与压缩有关的库，内核映像需要压缩 libidn11和libind11-dev GNU Libidn 库，IETF(互联网工程任务组)IDN(国际化域名)规范的扩展和用于其开发的文件 (https://packages.debian.org/search?keywords=libidn11) libelf-dev 用于ELF(Executable and Linking Format)开发的库 dwarves BPF is a technology that allows unprecedented ability to execute custom external code safely inside the Linux kernel in response to various events/hooks. (https://facebookmicrosites.github.io/bpf/blog/2018/11/14/btf-enhancement.html) 如果不装，会在make modules过程中产生有关tmp_vmlinux.btf的错误（如果在linux-x.x.x/config里面设置CONFIG_DEBUG_INFO_BTF=n那就不用装） 一条命令解决(一部分)问题 1sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt install flex bison build-essential libncurses5-dev openssl libssl-dev zlibc minizip libidn11 libind11-dev libelf-dev dwarves 签名问题 非常坑爹的问题 我再重申一遍，这个问题 非常非常 坑爹！ 我打赌这96个小时里至少有60小时浪费在签名导致的无法install从而重新编译一遍上面 坑爹啊！我只是做个实验，为甚么要考虑内核模块加密和签名啊，这是操作系统课程又不是系统恶意攻击防范安全课程。 其实后来发现更多的时间被浪费在了编译一些用不上的内核模块方面( 请仔细阅读： Bug#823107: marked as done (linux: make deb-pkg fails: No rule to make target 'debian/certs/benh@debian.org.cert.pem') 标红： &gt; Should I remove CONFIG_SYSTEM_TRUSTED_KEYS from .config before building &gt; the kernel? I hope not. Yes, you must do that. Your custom kernel configuration should be based on the appropriate file provided in linux-source-4.5. These have the CONFIG_MODULE_SIG_ALL, CONFIG_MODULE_SIG_KEY and CONFIG_SYSTEM_TRUSTED_KEYS settings removed so that custom kernels will get modules signed by a one-time key. 在 开 始 编 译 之 前 ， 需 要 在.config中置n或置空所有有关CONFIG_MODULE_SIG_ALL CONFIG_MODULE_SIG_KEY CONFIG_SYSTEM_TRUSTED_KEYS的选项 另外根据我的判断和实践，与KEY有关的涉及到BLACKLIST和REVOCATION的选项也全部置n或置空 前提系统仅仅作为实验用途。 但是，CONFIG_MODULE_SIG_KEY=\"certs/signing_key.pem\"这一行需要原样保留，不能置空，这指定了自动签名需要用到的文件，如果置空，则会报错。 权限问题 当我尝试在Windows的目录系统中用7-zip解压Linux-5.18.2.tar.xz的时候，提示错误“没有建立链接xxxxx的权限”，我还以为这个打包的内核文件里面有什么特别的权限问题需要处理，以至于我在网上找教程的时候，看到教程中从第一个make clean就开始sudo竟没有半点怀疑。 事实上，编译内核的前几步不需要sudo也不应该sudo————平常随便编译个什么程序需要sudo吗？ 只有在涉及到install的时候，因为需要将编译好的文件放到系统目录里面，才需要sudo。 不然呢，在自己家目录下面的工作目录里面创建一大堆只有root才能访问的文件很好玩吗？ 步骤 需要修改以实现功能逻辑的文件一共有三个 linux-x.x.x/arch/x86/entry/syscalls/syscall_64.tbl 系统调用表 linux-x.x.x/include/linux/syscalls.h 系统调用服务例程声明 linux-x.x.x/kernel/sys.c 系统调用服务例程定义 修改syscall_64.tbl 在系统调用表中添加系统调用 在\"64-bit system call numbers and entry vectors\"引导的注释结束之后向下寻找，在\"Due to historical design error, certain syscalls are numbered differently\"...这一部分开始之前的上面找到最后一个系统调用 5.18.2的最后一个系统调用是450号，sys_set_mempolicy_home_node调用 在其下，按照 的规则添加一条系统调用 number是系统调用号，和入口地址有关，必须是数字，顺着上面往下写即可 abi是通用二进制接口，对于5.18.2的syscall_64.tbl文件，abi的值可以是\"common\"、\"64\" 或\"x32\"之一，我选择\"64\" name是该系统调用的名称，稍后在\"sys.c\"中进行定义的时候需要用到 entry point是系统调用的入口点，稍后在\"syscalls.h\"中进行声明的时候需要用到 因此最后写入 451 64 customcall sys_customcall 修改syscalls.h 在系统调用服务例程原型声明头文件中声明服务例程的形式。 开头的注释里面写了规则 These syscall function prototypes are kept in the same order as include/uapi/asm-generic/unistd.h. Architecture specific entries go below, followed by deprecated or obsolete system calls. Please note that these prototypes here are only provided for information purposes, for static analysis, and for linking from the syscall table. These functions should not be called elsewhere from kernel code. As the syscall calling convention may be different from the default for architectures overriding the syscall calling convention, do not include the prototypes if CONFIG_ARCH_HAS_SYSCALL_WRAPPER is enabled. 于是在这里的最后一行，用于判断其他情况的ifdef之前写入自己的函数声明 1asmlinkage long sys_customcall(int tty, int mode, long stuid); 修改sys.c 这是服务例程的定义实现部分 SYSCALL_DEFINE是一个用于定义系统调用的宏函数，有几个写法，SYSCALL_DEFINE1，SYSCALL_DEFINE2，SYSCALL_DEFINE3，后面的数字代表之前声明中参数的个数，可以是0 1 2 3，而这个宏函数自身的参数则是以下几项 1st. 系统调用名 2nd. 参数1的类型 3rt. 参数1的名称 4th. 参数2的类型 5th. 参数2的名称 ... ... ... ... 上面自定义的函数的第一行写作 1SYSCALL_DEFINE3(customcall, int, tty, int, mode, long, stuid) 而函数体则按照通常的写法，这里注意到上面浏览一下include列表，有包含的头文件就有，没有包含的头文件就没有(废话)，而且(重点是)不要自己乱添加，linux的内核态中的程序并非完全兼容C标准库。 这个程序的逻辑部分其实非常简单，在别处稍稍写写，甚至没有怎么调试就可以由输入得到输出了。然而这个实验的重点不在这里。 主要的问题在于我对于内核中的函数并不熟悉，所以不知道用那些函数进行输出，（其实也不知道用哪些函数输入，但是函数需要的数据可以用参数传入所以暂不考虑输入的问题） 首先可以用脚趾排除掉printf的可能性，printf的参数列表没有包括输出的目的地，默认为stdout，对于一个正在某个tty上登入的用户，其stdout是确认的，但是对内核来说并不知道stdout在哪 进一步来说，printf是一个定义在\"stdio.h\"中的标准输出函数，而\"sys.c\"的include文件列表中并没有\"stdio.h\" 能够指定输出目标的是fprintf和sprintf然而查找了一下，fprintf和sprintf也是\"stdio.h\"中的函数 其中，fprintf用文件描述符定义输出的目标，很可惜文件描述符也是一个用户空间的东西，在内核层面是无法理解的内容 我又试着顺着printf向里找它的实现过程，printf能够一直追溯到vsprintf，然而在往上是宏定义，对于我来说线索到此中断 在第二还是第三天偶然发现了一个叫做printk的函数，这个函数可以以与printf类似的方式向内核输出字符串，它和printf不同之处在于第一个参数，printf的首个参数是一个指向char的指针，而printk的首个参数则是一种很奇特的形式，它由一个整数和一个指向char的指针绑定而成。 比如说 1printk(KERN_NOTICE \"Hello, world.\\n\"); 其中KERN_NOTIC是一个宏定义的整数 参阅 printk man page on Mageia 这个形式看起来很不美观，虽然能完成任务，但是把同一个输出贴满所有tty......对我来说还是接受不能，用来输出调试信息还行，拿来完成这个实验什么的就算了。 换个思路来考虑，Linux下一切皆文件，所谓的输出到标准输出，也可以理解为写入到标准输出这个文件里，使用文件操作函数也能实现想要的功能。 然而fopen、fwrite也是在\"stdio.h\"中定义的。 继续向里追溯，write是一个定义在“unistd.h”中的函数，“sys.c”中包含了#include &lt;asm/unistd.h&gt;这一语句，因此似乎是可以使用的。 write(STDOUT_FILENO, msg_str, sizeof(msg_str) *n); 然后编译过程就报错了“implicit declaration ‘write’” “use of undeclared identifier 'STDOUT_FILENO'”二连(和两次编译花掉的时间)。 其实吧，这里还是图样，即便拿到了STDOUT_FILENO的定义，其实也就是个1(大多数情况)，如果真的能用write把一个“1”传进内核，内核又怎么知道往哪输出呢，所以说其实一开始就根本不用考虑这个写法。 接着找到了sys_write这个函数，这次编译成功了(4.15.3)， 然而用该版本内核根本无法引导出图形界面，只能看到TTY，还得换输出目标，我折腾了一下，把输出换到/dev/tty1，然后什么都没有拿到 在茫然了很久之后。 我发现我似乎是在忘记了操作系统课程的内容之后进行了一番盲目的尝试浪费了不少时间。 什么是file descriptor？什么是file entry？什么是struct file？哪个在用户空间，哪个在内核空间？当我在内核中编写一条系统调用的时候，拿到的到底是file descriptor还是file entry？int fd是什么？FILE *fp是什么？ 把这些全忘了的虫豸，怎么能写好内核呢? (掏出PPK) 所以我得复习一下这些内容，除了翻书之外，网上的一些博客也可以参考一下，有关这个问题例如： Linux 的 file descriptor 筆記 - Kakashi's Blog （网内有人转载了这篇文章，如果上面的链接打不开的话：(转载)Linux的file descriptor笔记） 重点是这张图片： From the book the Linux Programming Interface — page 95 Figure 5-2:Relationship between file descriptors, open file descriptions, and i-nodes 文章里面也提到了lusp_fileio_slides 所以在内核里的时候，对着“file discriptor”磕下去就是死路一条 参考Read/write files within a Linux kernel module中的答案Read/write files within a Linux kernel module#53917617 得知，内核层面的读写文件应当使用filp_open kernel_read kernel_write 之后我参考了博客Access File in Kernel中的写法，主要是这几行 1234fp = filp_open(path, O_RDWR | O_CREAT, 0644);loff_t pos = 0;ret = kernel_write(fp, buf, size, &amp;pos);filp_close(fp, NULL); 之后形成了我在这个实验中的代码 123456789101112struct file* fp;loff_t pos = 0;...... /* 中间是其它部分的代码 */if(){ fp = filp_open(\"/dev/tty1\", O_RDWR, 0);}else{ fp = filp_open(\"/dev/pts/0\", O_RDWR, 0);}...... /* 中间是其它部分的代码 */kernel_write(fp, stuidstr, j+1, &amp;pos);fp_close(fp, NULL); 这样，最终完成了实验的目标。 P.S. 此外文件指针导致的失败暴露了另一些方面考虑不周的问题，最后我加了一个传入的参数，在服务例程里做了一个分支处理解决了。当然假如程序能得到进一步的改进，在用户空间程序获取当前tty名称封装进参数，在内核空间程序获取从用户空间程序传来的信息，那么就不用考虑“到底是哪个tty”的问题了。 编译和安装 这一步要用到的命令大概有这几种 make mrproper 彻底清理整个目录，在需要将所有结果推倒重来的时候使用，清除掉里面所有可能的不需要的东西，包括.config文件在内，所有文件恢复如初(自己更改的代码文件除外)，以准备一次完全重新开始的make make clean 保留.config，清理中间结果，比如目标文件之类的东西，至少在执行完make mrproper之后是没必要执行一遍make clean的 make config或者make menuconfig 都是用于创建设定编译选项的.config这个文件的命令，后者需要额外的库，并且需要终端至少有一定的宽度否则会报错，但我仍然建议使用后者，就当是为了键盘的Enter键的健康着想吧，或者会用yes也行，if you like 不过对于.config文件，我目前的建议是make localconfig，按照目前加载的内核配置进行编译，这样可以减少需要编译的模块，大大节省耗时。 2023.04.03更新：在最近的一次针对6.2.9内核的编译过程中发现make localconfig不可用，找到了一个方法说可以使用make localmodconfig代替，但是有人警告说这两个命令不太一样，反正我试了是可以生成正常的.config文件的 make 这个就不解释了 2023.04.03更新：写文章的时候忘了提，make的时候可以设定架构，务必记得查询本机的CPU线程数以加快编译速度，此外还有对输出日志重定向，以免打印到屏幕浪费算力，如果目标是amd64，本机CPU有8个线程，日志重定向到上一级的文件中，那么就输入make ARCH=x86_64 -j8 &gt; ../makekernel.log，这样会加快速度，而且只在屏幕上打印警告和错误，日志可以稍后自行通过其他方式查看 编译模块 1make modules 安装模块 1sudo make modules_install 安装内核 1sudo make install 注意 配置.config的时候会询问是否打开-Werror选项，虽然我平常自己编译程序的时候会常开这个选项，但是这里可以明确说，编译5.18.2内核的时候不要开这个选项折磨自己，因为该版本内核中jffs2_build_xattr_subsystem od_set_powersave_bias stmmac_request_irq_multi_msi vhost_scsi_flush这几个函数在某处调用的时候存在warning 一条命令完成编译和安装 customsyscall-shellcommand 善后 自己编译安装的自定义版本内核不能通过预装的自动化包管理工具进行管理。 管理这些内核 可能 需要手动方法。 目前卸载内核的方法参考了： linux下删除内核 - amanlikethis - 博客园 编译Linux内核 - wang_yb - 博客园 但是我注意到，在/下执行sudo find -name \"linux-4.15.3\"之后，在/var/lib/initramfs-tools/+下也发现了和该版本内核有关的文件，既然不用这个版本的内核了，那么删掉应该也没有什么影响。 而同一新版本的内核，只在/boot下发现了冗余的*.old文件，如果新内核可以正常使用，那么也就不留着*.old了 最后sudo update-grub 目前除了手动管理之外，暂时没有发现什么更好的管理工具 后续改进计划 使用ttyname函数从用户空间获取输出目标 (STATUS: FINISHED) 用户空间函数 1char *ttyname(int fd); 定义于 &lt;unistd.h&gt; 提供了获得当前tty名称的功能 假如在用户空间调用该函数，并将获得的字符串压入传参结构体，通过系统调用函数传给内核空间的服务例程，就可以在任意tty下获取输出。 这是一个更加优雅的方案，但是涉及到定义新结构体，在内核空间重新对字符串处理并传给filp函数，以及改变代码之后漫长的编译过程，因此是 to be done 任务。 先保存一个能成功运行的版本。 首先把原本的传参方式改掉，现在使用一个结构体来传参，定义结构体如下： 123456typedef struct customcallparamentstructure{ int ttystrlen; char ttystr[16]; int mode; long stuid;}custompara_t; 在用户空间做出以下更改 1234567891011121314custompara_t paraS;/* 中间是其它代码 */if((ch_p = ttyname(STDOUT_FILENO)) == NULL){ /* if don't get the tty-name then quit */ fprintf(stderr, \"E: Invalid ttyname.\\n\"); return 1;}else{ /* if get the tty-name, set its length and itself into the parament Structure */ len = strlen(ch_p); paraS.ttystrlen = len; /* paraS.ttystr[len] = '\\0'; */ /* might not needed anymore? */ strncpy(paraS.ttystr, ch_p, len);} 在内核空间做出以下更改 12345fp = filp_open(paraSp-&gt;ttystr, O_RDWR, 0);/* 中间是其它代码 */kernel_write(fp, stunstr, j+1, &amp;pos); 这样就做到了无论正在使用哪种终端,都可以自动选择终端输出字符串 改变内核的版本号码 (STATUS: FINISHED) compiling - Linux kernel version suffix + CONFIG_LOCALVERSION - Unix &amp; Linux Stack Exchange 在.config的CONFIG_LOCALVERSION处加上自定义字符串，使编译后产生的内核有独特的版本号码字符串，以与其他内核区分。 效果如图 custom-kernel-name Knighthana 2022/06/10","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://knighthana.github.io/tags/Ubuntu/"},{"name":"Kernel","slug":"Kernel","permalink":"https://knighthana.github.io/tags/Kernel/"},{"name":"syscall","slug":"syscall","permalink":"https://knighthana.github.io/tags/syscall/"}]},{"title":"(KM)基础理解KD树","slug":"(KM)KdtreeJuniorKnowledge","date":"2022-05-28T16:00:00.000Z","updated":"2023-04-20T10:52:51.543Z","comments":true,"path":"KnowledgeMark/(KM)KdtreeJuniorKnowledge.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)KdtreeJuniorKnowledge.html","excerpt":"","text":"基础-12：15分钟理解KD树 最后编辑于 2017.05.07 22:47:55 1. 概述 KD树是一种查询索引结构，广泛应用于数据库索引中。从概念的角度讲，它是一种高纬数据的快速查询结构，本文首先介绍1维数据的索引查询，然后介绍2维KD树的创建和查询，相关定理和推论也简单列出，本文争取用15分钟的时间，让大家快速理解KD树。 author: Coding Tech rest: 基础-12：15分钟理解KD树","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"KD树","slug":"KD树","permalink":"https://knighthana.github.io/tags/KD%E6%A0%91/"}]},{"title":"git clone 时提示证书不存在或过期的问题","slug":"Git克隆时提示证书不存在或过期的问题","date":"2022-04-17T16:00:00.000Z","updated":"2023-04-20T08:00:22.038Z","comments":true,"path":"Dev-Env/Git克隆时提示证书不存在或过期的问题.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/Git%E5%85%8B%E9%9A%86%E6%97%B6%E6%8F%90%E7%A4%BA%E8%AF%81%E4%B9%A6%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%88%96%E8%BF%87%E6%9C%9F%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"","text":"git clone 时提示证书不存在或过期的问题 从目标服务器上向本地clone项目时，提示 fatal: unable to access '...' : server certificate verification failed. CAfile: none CRLfile: none 一个证书问题，简洁明了。 首先可以得到结论，这里连到的远程目标上的确配置了https，但是证书不存在。 是不是DNS环节出了问题？用nslookup在aliyunDNS，也就是本地目前正在使用的DNS，上查到了远程目标的IP，在某外国网站上验证了IP对应主机的地理位置，是Google的云服务器机房没错。 打开远程目标的网页版，查找了一下，远程目标使用的是R3签发证书，至少根据Chrome的判断，这个证书是有效的。 在网页上搜索了一下关键词 server certificate verification failed. CAfile: none CRLfile: none 找到的结果，不是要关掉git的证书验证功能，就是要手动修改证书。要么是只管驼背的灵活医治法，要么看起来过于奇技淫巧。 听起来不太靠谱。如果一个项目按照规范的方法部署，一切正常，那么就不会存在只能用奇技淫巧才能解决的问题，如果用了奇技淫巧，那就像是在稳固的承重墙上打洞，迟早有一天会在这个环节崩掉。 最终，在适用于 Windows 的 Git：SSL 证书问题：证书已过期(Git for Windows: SSL certificate problem: certificate has expired)上找到了一个思路：这个话题中的本地证书过期了，那么我这边的本地证书上面是不是缺少了一些签发机构。 回忆一下，本地机的确有很久没有更新过了。 回到home，sudo apt update，得到结果，需要更新273个包。 apt list --upgradable | grep git，git赫然在列。 于是sudo apt upgrade git。 更新完毕之后，顺利git clone。 (以及发现更新了git和git依赖的包之后，本机所有的包全都被更新了一遍) 记录一下，为将来解决某些问题留作启示。 Knightana 2022/04/18","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://knighthana.github.io/tags/Git/"}]},{"title":"四个人三种卷子的概率问题","slug":"四个人三种卷子的概率问题","date":"2021-11-25T16:00:01.000Z","updated":"2023-04-20T08:01:07.382Z","comments":true,"path":"subject-note/四个人三种卷子的概率问题.html","link":"","permalink":"https://knighthana.github.io/subject-note/%E5%9B%9B%E4%B8%AA%E4%BA%BA%E4%B8%89%E7%A7%8D%E5%8D%B7%E5%AD%90%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98.html","excerpt":"","text":"四个人三种卷子的概率问题 有甲乙丙丁四人，ABC三种卷子 每人可以选一种卷子， 求四人选到所有三种卷子的概率 解：将四人分成三组，然后为三组分配三种不同的卷子，并求出这样分配得到的方法数量 因为已知四个人对三种选择进行不放回抽样，一共可以得到3⁴，也即3x3x3x3共81种取法 现在设法求出其中能够将三种全部分配的取法，就可以得到所求的概率 考虑将4人分作互相独立的三组，然后对三组分配不同的卷子，来获得所有分配方法的数量 将4人分作互相独立的三组一共有多少分法： (C(41)×C(31)×C(22))/A(22) = 6 种分法 解释： C(41)从4人中任取一人划为第一组， C(31)从剩下的3人中任取一人划为第二组， C(22)再将剩下的两人分为第三组， 由于上述过程最终求出的结果中，C(41)×C(31)计算过程产生了重复的情况 因此除以一个A(22)，除以该A(22)的含义为，在从4人中确定了2人一定为一组的情况下，将另外2人所有的排列情况归为同一种情况 引申：5人分为4组，6人分为5组的情况： 当5人分为4组时，会产生六种重复情况，这六种情况实际上是将2个分为一组的成员除去后，剩下的3个成员之间排列构成的六种情况，很容易得到规律，此时重复了A(33)种情况； 推广为6人分为5组时，也很容易验证到，将2名成员固定为一组后，剩下的4个成员之间产生了A(44)种排列构成的重复情况； 也即，X人分为X-1组时，将其中2人恒为一组，剩下的成员之间会产生X-2种排列，由此产生A(X-2,X-2)种重复的分组结果，需要对应地将其除去； 于是将4人分为3组的过程一共获得了6种互相无关的分法 考虑到一共有3种卷子，3种卷子分给3个组一共有A(33)种分法，也即3×2×1一共6种分法 将这两部分的各个分法情况数量相乘，则一共能够获得6×6=36种符合要求的分法 再将这么多数量的分法与总共的81种分法相比，获得36/81这个概率，化简得4/9； Knighthana 2021/11/26","categories":[{"name":"subject-note","slug":"subject-note","permalink":"https://knighthana.github.io/categories/subject-note/"}],"tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://knighthana.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Math","slug":"Math","permalink":"https://knighthana.github.io/tags/Math/"},{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://knighthana.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}]},{"title":"(KM)Windows中的临时字体管理","slug":"(KM)TemporaryFontManagement","date":"2021-11-06T16:00:00.000Z","updated":"2023-04-20T11:06:37.905Z","comments":true,"path":"KnowledgeMark/(KM)TemporaryFontManagement.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)TemporaryFontManagement.html","excerpt":"","text":"Windows中的临时字体管理 Remarks Any application that adds or removes fonts from the system font table should notify other windows of the change by sending a WM_FONTCHANGE message to all top-level windows in the operating system. The application should send this message by calling the SendMessage function and setting the hwnd parameter to HWND_BROADCAST. When an application no longer needs a font resource that it loaded by calling the AddFontResource function, it must remove that resource by calling the RemoveFontResource function. This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry. A font listed in the registry and installed to a location other than the %windir% folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling RemoveFontResource, removed from the font registry (HKEY_LOCAL_MACHINENT), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed. Source:AddFontResourceA function (wingdi.h) A font listed in the registry and installed to a location other than the %windir% folder cannot be modified, deleted, or replaced as long as it is loaded in any session. other than the %windir% folder heavy, and ROBUST bond to cannot be modified, deleted, or replaced GOOD JOB, M--I--C--R--O--S--O--F--T--","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"Font","slug":"Font","permalink":"https://knighthana.github.io/tags/Font/"}]},{"title":"(KM)离散对数","slug":"(KM)离散对数","date":"2021-11-05T16:00:00.000Z","updated":"2023-04-20T10:44:23.072Z","comments":true,"path":"KnowledgeMark/(KM)离散对数.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.html","excerpt":"","text":"离散对数 在整数中，离散对数（英语：Discrete logarithm）是一种基于同余运算和原根的一种对数运算。而在实数中对数的定义 logb a 是指对于给定的 a 和 b，有一个数 x，使得bx = a。相同地在任何群 G中可为所有整数 k定义一个幂数为 bk，而离散对数 logb a是指使得 bk = a的整数 k。 离散对数在一些特殊情况下可以快速计算。然而，通常没有具非常效率的方法来计算它们。公钥密码学中几个重要算法的基础，是假设寻找离散对数的问题解，在仔细选择过的群中，并不存在有效率的求解算法。 未解决的计算机科学问题：是否存在离散对数问题的多项式时间经典算法？ 未解决的计算机科学问题 计算复杂性理论 P = NP问题。这是七个千禧年大奖难题之一 NC (复杂度) NP = co-NP问题 P = BPP问题 P = PSPACE问题 BQP和NP之间的关系是什么？ 独特游戏猜想 指数时间假说是真的吗？ 单向函数存在吗？ 算法 两个n位数乘法算法速度最快的是什么？ 速度最快的矩阵乘法算法是什么？ 可以在多项式时间内做整数分解吗？ 可以在多项式时间内计算离散对数吗？ 可以在多项式时间内解决图同构问题吗？ 可以在多项式时间内解决奇偶校验游戏吗？ 线性规划问题是否存在强多项式时间的解法？这是Smale问题列表中的第9个问题。 快速傅里叶变换算法的复杂性上下限是什么？他们能比Θ（N log N）快吗？ 可以在次二次时间内解决3SUM问题吗？ 伸展树动态最优性猜想 K-服务器问题 编程语言理论 POPLmark Barendregt–Geuvers–Klop猜想 广义星高问题 其他问题 Aanderaa–Karp–Rosenberg猜想 离散对数 未解决的计算机科学问题","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"离散对数","slug":"离散对数","permalink":"https://knighthana.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"},{"name":"NP难问题","slug":"NP难问题","permalink":"https://knighthana.github.io/tags/NP%E9%9A%BE%E9%97%AE%E9%A2%98/"},{"name":"计算机科学","slug":"计算机科学","permalink":"https://knighthana.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"(KM)植食性动物如何获取蛋白质","slug":"(KM)HowHerbivoreGetProtein","date":"2021-11-02T16:00:00.000Z","updated":"2023-04-20T11:08:24.389Z","comments":true,"path":"KnowledgeMark/(KM)HowHerbivoreGetProtein.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)HowHerbivoreGetProtein.html","excerpt":"","text":"植食性动物如何获取蛋白质 牛为毛吃草也长得壮？ 因为丫吃草主要目的是为了在胃里养微生物，然后再把微生物“吃”掉= = https://www.zhihu.com/question/21081801/answer/17121343","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"生物学","slug":"生物学","permalink":"https://knighthana.github.io/tags/%E7%94%9F%E7%89%A9%E5%AD%A6/"}]},{"title":"使用远程机器的一些问题","slug":"使用远程机器的一些问题","date":"2021-10-30T16:00:00.000Z","updated":"2023-04-20T11:39:30.254Z","comments":true,"path":"Dev-Env/使用远程机器的一些问题.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E4%BD%BF%E7%94%A8%E8%BF%9C%E7%A8%8B%E6%9C%BA%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.html","excerpt":"","text":"使用远程机器的一些问题 SSH的配置问题 当一台远程机器启用SSHD服务器并且允许通过某个端口（默认22）访问之后，就可以在另一台机器（下称终端机）上通过SSH客户端进行基于SSH协议的远程访问了。 假如配置好的远程机器的IP地址是192.168.50.34，其上有一个已经存在的本地用户ubuntu，则通过输入指令 ssh ubuntu@192.168.50.34 即可进行SSH访问请求； 通常情况下，需要输入该远程机器上的本地用户的密码来进行认证，但如果配置了RSA公私钥对，则可以略过输入密码的步骤； 在远程机器上的sshd配置文件位于/etc/ssh/sshd_config，这个文件中可以找到对于认证方式的设置，其中： 以下项目规定了有关公私钥认证的设置 PubkeyAuthentication 默认为yes AuthorizedKeysFile 默认为.ssh/authorized_keys .ssh/authorized_keys2 以下项目规定了密码登入认证的设置 PasswordAuthentication 默认为yes 该项目作用不确定 ChallengeResponseAuthentication 默认为no 经过查询，该条目会进行一个“键盘交互式”认证，并指出“默认询问密码”，但没有得到进一步的有关这个过程如何进行详细配置，考虑到平常使用中不使用这个功能，因此按照默认的no进行设置。 值得注意的是，ssh方式是远程用户通过将自己登入为一个本地已经存在的用户来进行使用的，因此在远程机器上的配置是针对已经存在的本地用户进行的； SSH的公钥是分配给某个用户的吗 因此对于一个已经启用且采用默认配置的SSHd，只要在经常远程登录的用户的.ssh目录下配置authorized_keys文件，就可以直接通过publickey的方式登录。 配置的方式就是复制自己的公钥并直接粘贴到authorized_keys文件中 而且可以贴好几个进去 authorized_keys文件里面最多能放几个公钥 注意，假如在登入时公私钥验证的方式不通过，则会要求输入密码， 之前认为是设置中启用了PasswordAuthentication的缘故，于是将它设置为no，然后可喜可贺地彻底登不上去了。 之后发现是由于我直接采用终端的复制粘贴功能进行公钥的跨窗口复制粘贴，导致它把vim的换行符也复制进去了，结果就是密钥认证不通过需要手动输入密码 值得注意的是搜索时发现了这个问题，虽然最终证明和我遇到的情况没有关系，但是还是值得留意一下，例如文件的权限问题等 为什么配置密钥之后还是需要输入密码 并且幸运地发现了针对这个操作过程更为标准的工具ssh-copy-id，理论上讲，使用这个工具和手动操作是一样的效果，但是正确使用该工具还是有助于避免乱七八糟的问题。 手动复制ssh公钥和使用ssh-copy-id有何区别 ssh-copy-id到底做了什么 （以此祭我在这个问题上浪费掉的四到六个小时时间，苏卡！） 另外出于安全考虑，在私有的树莓派上对默认用户\"ubuntu\"进行公私钥配置，在公共服务器上还是另建一个新用户，然后针对该用户进行公钥配置比较好。 安全网络连接 在终端下可以通过使用proxychains工具进行安全且私密的连接，proxychains会尝试接管单条命令的网络连接； 直接apt得到的proxychains是proxychains3，更加新的则是proxychains4，手动查看其版本实际为proxychains4-NG 同时也是出于安全原因，不应当在默认的\"/etc/proxychains.conf\"中留下任何信息 在个人目录下建立~/.proxychains/proxychains.conf文件，参考默认的/etc/proxychains.conf文件，可以发现其中有用的只有几行，复制粘贴然后修改一下： 1234strict_chainproxy_dns[ProxyList]socks5 192.168.50.xx ???? 然后执行 1proxychains xxxxxxxx.sh 然后并没有立刻获取到私密安全的资源。 ping请求接收者\"192.168.50.xx\"，显示延迟只有零点几毫秒。 查看请求接收者端口上负责监听的服务器已经启动了局域网服务功能，检查网络类型，为“专用”，检查防火墙，针对监听服务器的设置为任意远程端口到任意本地端口的入站请求均为允许，因此理论上讲监听服务器正在监听的????端口应当被允许。 因此看起来防火墙在这件事情上扮演的角色是人畜无害的。 然而稍后运行wf.msc，设置在防火墙日志中记录所有请求，包括允许的和拒绝的，并且利用远程机器在局域网上发起数次请求，发现本地机器的日志文件体积在增大。 阅读之后，发现所有ICMP-ping请求都回复了，所有到本地7890的请求都被拒绝了。 不愧是你啊Windows 所以需要手动配置一条允许该端口的规则。 之后尝试，就正常了。 2021/10/31 Knighthana 纪念一周前在这两件破事上浪费的半个早晨","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"RaspberryPi","slug":"RaspberryPi","permalink":"https://knighthana.github.io/tags/RaspberryPi/"},{"name":"Network","slug":"Network","permalink":"https://knighthana.github.io/tags/Network/"},{"name":"SSH","slug":"SSH","permalink":"https://knighthana.github.io/tags/SSH/"}]},{"title":"进行Minecraft Fabric MOD开发的经验记录","slug":"minecraft_fabric_dev_log","date":"2021-09-22T16:00:00.000Z","updated":"2023-04-20T10:30:25.502Z","comments":true,"path":"Dev-Code/minecraft_fabric_dev_log.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/minecraft_fabric_dev_log.html","excerpt":"","text":"进行Minecraft Fabric MOD开发的经验记录 在没有任何Java基础的前提下进行Minecraft Fabric MOD开发，一边学MOD开发，一边学Java Fabric项目的教程主页 09/23 开发前的环境配置也即Java开发环境的配置+对Minecraft开发的特化配置 JRE和JDK早已经安装，因此只需要考虑编辑器和项目管理一类装置的问题。 起初计划在Visual Studio Code上直接进行Java的开发，但个人认为VSC不是一个IDE，也没必要安装一堆插件降低VSC的启动速度，所以直接安装了专门用于Java开发的IDE。 使用过Eclipse，但谈不上对Eclipse有很大的使用依赖，因此按照教程的推荐，也是本着尝试新工具的目的安装了IntelliJ IDEA并且安装了中文插件和Minecraft插件。 插一嘴，将本地化工作交给社区是一个很值得参考并且效仿的思路，VSC如是，IDEA如是。虽然这几个项目都是开源项目，但是个人觉得即使是闭源项目也应当考虑将i18n工作作为项目以外的部分开放给社区。 Fabric在Github上有一个Fabric MOD模板项目，(尤其是对于我这种没有任何Java开发经验的人来说)可以用来参考。 项目使用了Gradle进行管理，在我认知范围内这是一个用于管理项目的工具，也许类似于make，IDEA对于Gradle的支持非常好，完全在无感知的情况下读取并应用了Gradle。 在国内，想要正常的通过Gradle进行Fabric for Minecraft开发，需要更换其中的源。 这需要打开settings.gradle，并更改其中的源为由hanbings.io提供的镜像源。 然后打开build.gradle，在repositories中添加aliyun maven和hanbings maven 在安装了Minecraft Dev插件的IDEA中，新建一个minecraft项目，使用Yarn映射，也会得到一个类似example-mod的环境，同时也需要进行类似的换源。 src/main/java/name.modID/modID.java是主要的项目文件。 public class modID implements ModInitializer是主要的类，由于不太清楚Java的设计，根据名称判断这是一个有关MOD初始化的类，根据教程，将MOD想要实现功能的代码放入这个类中就可以进行实现了。 类中有一个函数，onInitialize()，属性为public，根据名称，这是在初始化时调用的函数。 一个物品组ItemGroup可藉由FabricItemGroupBuilder提供的build方法或者create方法创建，在这些方法中都有一个Identifier函数，这个函数需要传入两个string，例如一个分别传入modID和general两个string，稍后将会在游戏中看到这个物品组被命名为itemGroup.modID.general。 需要注意的是，这里的string只能传入由小写字母a_z以及数字下划线和横杠组成的字符串，所以直接写\"modID\"肯定是会引发游戏无法启动的问题的。 后来发现wiki上的原文中有小字部分对此限制做了如下描述: 请记住，传递给Identifier构造函数的参数只能包含某些字符。 两个参数（命名空间namespace和路径path）都可以包含小写字母、数字、下划线、点和横杠。[a-z0-9_.-] 第二个参数（path）还可以包含斜杠。[a-z0-9/_.-] 避免使用其他符号，否则将引发InvalidIdentifierException！ 经过我个人的尝试，这里也无法new一个TranslatableText()来提供字符串，IDEA将会提示“这里需要一个string但是传入了一个text”。 但经过尝试，在lang文件中直接对itemGroup.modID.general进行翻译，游戏中在标签页提示处是可以读取到并进行翻译的，但目前尚不清楚如何为下面的灰色字体提供翻译。 可以通过在主类中用类似创建物品组的方法创建新的物品，例如我通过public static final Item M1911_ITEM = new Item(new Item.Settings().group(ctmMOD.GUNS_GROUP));在属于ctmMOD的GUNS_GROUP中创建了一个叫做M1911_ITEM的类。 对于自定义的物品而言，需要一个额外的注册过程，在主类的onInitialize方法中，为每个自定义建立的物品类进行注册，例如对刚刚建立的M1911_ITEM类，通过Registry.register(Registry.ITEM, new Identifier(\"ctmmod\", \"m1911_pistol\"), M1911_ITEM);将之注册成标识符为item.ctmmod.m1911_pistol的物品。 每个物品在src\\main\\resources\\assets\\ctmmod\\textures\\item中设置材质，材质名设置为标识符的最后一个string，例如m1911_pistol.png。 同时还需要在src\\main\\resources\\assets\\ctmmod\\models\\item中设置模型，minecraft的原生方式似乎是使用json文件，在其中进行一些描述。 最简单的描述方式是 123456{ \"parent\": \"builtin/generated\", \"textures\": { \"layer0\": \"ctmmod:item/m1911_pistol\" }} 通过这个描述方式只能将模型平铺，更加复杂的方式需要额外的描述。 另外我在某些MODD地textures文件夹发现了另外一个models文件夹，这个文件似乎是定义了某些复杂的模型材质，但这已经超出目前的理解范围了。 本日的练习就到这里。","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"Minecraft","slug":"Minecraft","permalink":"https://knighthana.github.io/tags/Minecraft/"},{"name":"Fabric","slug":"Fabric","permalink":"https://knighthana.github.io/tags/Fabric/"},{"name":"Java","slug":"Java","permalink":"https://knighthana.github.io/tags/Java/"}]},{"title":"(KM)微软的“3E”战略","slug":"(KM)Microsoft's_3E_strategy","date":"2021-09-03T16:00:00.000Z","updated":"2023-04-20T10:59:59.866Z","comments":true,"path":"KnowledgeMark/(KM)Microsoft's_3E_strategy.html","link":"","permalink":"https://knighthana.github.io/KnowledgeMark/(KM)Microsoft's_3E_strategy.html","excerpt":"","text":"微软的“3E”战略 作为参考内容的一部分进行收藏 摘要 策略 3E战略分成三个阶段进行：11 拥抱 开发某个基本兼容竞争者产品或开放标准的软件。 扩展 增加不属于竞争者产品或开放标准的额外功能，为原版软件的顾客制造互换性问题。 消灭 等到市场占有率提升推动之前的扩展成为事实标准，竞争者就会因为不支持或不能支持新扩展被挤出市场。 微软声称，其原本战略并非要打压竞争，而只是行使了自由裁量权来实现认为客户需要的功能12。 参考资料 拥抱、扩展再消灭-维基百科，自由的百科全书 Knighthana 2021/09/04","categories":[{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"}],"tags":[{"name":"Microsoft","slug":"Microsoft","permalink":"https://knighthana.github.io/tags/Microsoft/"},{"name":"3E","slug":"3E","permalink":"https://knighthana.github.io/tags/3E/"},{"name":"be aware","slug":"be-aware","permalink":"https://knighthana.github.io/tags/be-aware/"}]},{"title":"关于WSL1中libgc的某些故障导致Wrong __data_start_end_pair问题的描述和后续解决方案","slug":"关于WSL1中libgc的某些故障","date":"2021-08-28T16:00:00.000Z","updated":"2023-04-20T11:41:10.802Z","comments":true,"path":"Dev-Env/关于WSL1中libgc的某些故障.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E5%85%B3%E4%BA%8EWSL1%E4%B8%ADlibgc%E7%9A%84%E6%9F%90%E4%BA%9B%E6%95%85%E9%9A%9C.html","excerpt":"","text":"关于WSL1中libgc的某些故障导致Wrong __data_start/_end pair问题的描述和后续解决方案 启动w3m时遇到问题w3m Wrong __data_start/_end pair问题 大多数（包括中文社区和英文社区）给出的分析是“这个问题是WSL1导致的，升级到WSL2就解决啦” 我信你个鬼，WSL2的坑爹是远近闻名的 查询之后，一个网页给出了解决方案:WSL Ubuntu guile命令报错Wrong __data_start/_end pair及guile-gi等相关编译错误的解决方法 溯源其中提到的libsndfile fails to build on Ubuntu 20.04 with WSL网页，其中给出的解决方案是 1234567891011sudo dpkg -r --force-depends \"libgc1c2\" # remove old libgcgit clone git://github.com/ivmai/bdwgc.gitcd bdwgc./autogen.sh./configure --prefix=/usr &amp;&amp; make -j # its default is the wrong directory? huh?`sudo make install （个人认为此顺序不妥，鉴于网络的实际情况，以及开发环境不一定配置完毕，应该先执行git clone等命令，直到确认./autogen.sh执行无误之后，再行sudo dpkg -r --force--depends等卸载命令，最后再执行./configure和sudo make install） 在按照这个办法执行完毕之后，虽然w3m可以正常运行（表示libgc可以被正常调用），但是dpkg表示出现了依赖未解决问题。 显然依赖未解决，因为之前已经强制dpkg remove了依赖关系。 此时如果按照推荐方式，执行sudo apt --fix-broken install，将会解决依赖的问题，但是同时也会重新安装旧版本的libgc，也即什么问题都没解决。 这时候有两种解决方案，第一种是手动修改/var/lib/dpkg/status文件，这种方法多少令人有些抗拒。 另一个办法是伪装系统内的库，这需要考虑linux的这套库调用系统是如何运作的 在/usr/lib/x86_64-linux-gnu/内有目前不适应实际情况的过时libgc.so.1和libgc.so.1.3.2两个库 而根据上述解决方案，使用--prefix=/usr进行configure并进行make install之后，会在/usr/lib下安装libgc.so.1.5.0库 经过检查，/usr/lib/x86_64-linux-gnu/内的libgc.so.1实际上是一个软链接，因此将其链接的目标进行更改也许是一个可行的办法 因此最终的解决方案是，在/usr/lib/x86_64-linux-gnu/进行了如下操作： 1234567sudo mv libgc.so.1 libgc.so.1.baksudo mv libgc.so.1.3.2 libgc.so.1.3.2.baksudo ln -sf /usr/lib/libgc.so.1.5.0 libgc.so.1sudo ln -sf /usr/lib/libgc.so.1.5.0 libgc.so.1.3.2 如此，一番指鹿为马的操作就完成了 （也许这么生草的办法哪天突然就炸了也说不定 （所以才要记下来防止翻车 Knighthana 2021/8/29 4:05 (UTC+8) 更新： 刚刚在网上冲浪，发现了一篇文章，提供了修改包管理器数据库的几个方案： 史上最硬核的 Linux 依赖问题解决方案 | 技术 Knighthana 2021/8/29 4:15 (UTC+8) 这篇被标记为草台教程，请谨慎参考食用","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"},{"name":"WSL","slug":"WSL","permalink":"https://knighthana.github.io/tags/WSL/"},{"name":"libc","slug":"libc","permalink":"https://knighthana.github.io/tags/libc/"},{"name":"w3m","slug":"w3m","permalink":"https://knighthana.github.io/tags/w3m/"},{"name":"草台教程","slug":"草台教程","permalink":"https://knighthana.github.io/tags/%E8%8D%89%E5%8F%B0%E6%95%99%E7%A8%8B/"}]},{"title":"关于VirtualBox在虚拟机操作系统中共享文件夹的一个猜想","slug":"VirtualBox扩容磁盘之后在虚拟机中未发现磁盘空间扩大的情况","date":"2021-08-10T16:00:00.000Z","updated":"2023-04-20T08:13:00.423Z","comments":true,"path":"Dev-Env/VirtualBox扩容磁盘之后在虚拟机中未发现磁盘空间扩大的情况.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/VirtualBox%E6%89%A9%E5%AE%B9%E7%A3%81%E7%9B%98%E4%B9%8B%E5%90%8E%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E6%9C%AA%E5%8F%91%E7%8E%B0%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E6%89%A9%E5%A4%A7%E7%9A%84%E6%83%85%E5%86%B5.html","excerpt":"","text":"VirtualBox扩容磁盘之后在虚拟机中未发现磁盘空间扩大的情况 在VirtualBox的虚拟机“存储”标签上直接右键磁盘是没有容量管理选项的，所以操作前先去搜索了一下。 有意思的是扩容前去搜如何操作，在启用了GG建议的搜索栏中输入“Virtualbox 磁盘”几个字之后，第一个联想结果是“VirtualBox 磁盘扩容”，不得不说这可真是个常见问题。 批判一下，目前网上的资料把扩容操作说得非常复杂，什么使用命令行，什么找到磁盘文件目录，什么输入XXX个数字。 看着要敲命令好像非常高端，但是照抄别人的命令待会虚拟机炸了怎么办？所以我最后又回到VBox界面仔细找，因为一个成熟的虚拟机软件应该有提供调整磁盘容量的功能。 最后在VirtualBox自己左上角的管理菜单找到了此项功能，名字就叫“虚拟介质管理”。 虽然这确实和VMware的思路不太一样，因为我记得VM是在单个虚拟机的菜单里管理对应虚拟机的磁盘文件，而不是VBox这样把所有虚拟盘文件集中在一起管理。 这是个GUI管理工具，操作非常直观，所以扩容过程没什么好说的。 然后打开虚拟操作系统里的磁盘管理工具就出现问题了，磁盘管理工具不认为磁盘上还存在未分配的磁盘空间。 起初我以为是系统没有刷新或者怎么样导致的，用了几次刷新磁盘按钮，反复重启，然而都没有检测到还有未分配的磁盘空间。 从VBox的菜单来看，磁盘的大小是已经扩容过的了。 问题出在哪呢？ 搜了一圈，都是C**N里面的假设用户非常simple、非常naive的关键词博文，似乎所有人都不知道在软件里扩容完磁盘要进虚拟操作系统再分配一下似的，很失望。 我还等着扩容完磁盘继续设置虚拟机呢。 最后以“free space not enlarge after virtualbox disk”为关键词去Google上搜索。 顺带一提Google纠正了我的语法错误，改为了“free space not enlarged after virtualbox disk”的搜索结果。 然后就是非常精准的VBox论坛的结果： Windows doesn't see enlarged virtual disk. 顺带一提里面导向了这个解决问题的链接How to resize a Virtual Drive * 直接去这里找答案就行 第一个帖子往下翻，有一个老哥一眼看破了问题的关键，直击人心： Re: Windows doesn't see enlarged virtual disk. Postby Perryg » 26. Oct 2016, 16:29 Let me guess. You have snapshots, correct? If so then you need to read the third topic in the link provided. 我想了一下目前的虚拟机确实有好几个快照。 所以最后解决方案是删除快照备份。 还好这只是我自己的隔离用的虚拟机，而且虚拟机刚启用没多久，这些快照只是每次安装新软件之前习惯性的备份，不然删掉备份这种事情多少有点蛋疼。 总之，VBox的磁盘快照会影响磁盘扩容的功能，以上。 Knighthana 2021/08/11","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"VirtualBox","slug":"VirtualBox","permalink":"https://knighthana.github.io/tags/VirtualBox/"}]},{"title":"Ubuntu的advantage tools失败","slug":"Ubuntu的advantage tools失败","date":"2021-07-23T16:00:00.000Z","updated":"2023-04-20T10:30:49.954Z","comments":true,"path":"Dev-Env/Ubuntu的advantage tools失败.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/Ubuntu%E7%9A%84advantage%20tools%E5%A4%B1%E8%B4%A5.html","excerpt":"","text":"ERROR: File not found '/run/cloud-init/instance-data.json'. Provide a path to instance data json file using --instance-data 症状: 使用apt期间，在执行至Setting up ubuntu-advantage-tools时 ERROR: File not found '/run/cloud-init/instance-data.json'. Provide a path to instance data json file using --instance-data dpkg: error processing package ubuntu-advantage-tools (--configure): installed ubuntu-advantage-tools package post-installation script subprocess returned error exit status 1 Errors were encountered while processing: ubuntu-advantage-tools E: Sub-process /usr/bin/dpkg returned an error code (1) 解决方案： 先执行一遍 1sudo cloud-init init 参考： ubuntu-advantage-tools package in Ubuntu cloud-init-The-cross-cloud-Magic-Sauce-Scott-Moser-Chad-Smith-Canonical.pdf Instance Metadata capabilities 其他： apt和dpkg是系统中至关重要的包管理软件，无法理解为什么允许有这种莫名其妙的错误发生。 这个莫名其妙的新软件包\"ubuntu-advantage-tools\"因为找不到某个与另一程序\"cloud-init\"有关的文件就卡住了，然后dpkg也不管不问因此卡住仅仅return了一个1，进而所有的apt指令都失去效果，整个系统差点就不能用了。 查询发现cloud-init并不是什么对于操作系统运行至关重要的东西。 这套包管理系统简直是脆弱。 2021-07-24","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"APT","slug":"APT","permalink":"https://knighthana.github.io/tags/APT/"},{"name":"dpkg","slug":"dpkg","permalink":"https://knighthana.github.io/tags/dpkg/"},{"name":"advantage tools","slug":"advantage-tools","permalink":"https://knighthana.github.io/tags/advantage-tools/"}]},{"title":"在FreeBSD中通过pkg安装软件时遇到问题","slug":"在FreeBSD中通过pkg安装软件时遇到问题","date":"2021-06-30T16:00:00.000Z","updated":"2023-04-20T10:26:52.363Z","comments":true,"path":"Dev-Env/在FreeBSD中通过pkg安装软件时遇到问题.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E5%9C%A8FreeBSD%E4%B8%AD%E9%80%9A%E8%BF%87pkg%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%97%B6%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98.html","excerpt":"","text":"在FreeBSD中通过pkg安装软件时遇到pre-install script failed问题 打开尘封了一段时间的FreeBSD，试图pkg install发现版本号跟不上了。 一通换源和freebsd-update之后终于升级到了最新版本12.2-RELEASE，然后在安装软件的时候遇到了报错“pre-install script failed” 目前尚不清楚原因，但有前人的例子： 论坛网页1：Solved PRE-INSTALL script failed 论坛网页2：Solved Error adding new user - pw: user 'anne' disappeared during update 根据网页2中论坛用户SirDice的说法，这是因为有关权限和密码的数据库没有同步导致的。 解决方案有两个： Run /usr/sbin/pwd_mkdb -p /etc/master.passwd. Running vipw(8) and save-and-quit (without actually making any changes) also fixes it (easier to remember). vipw是用于编辑passwd文件的命令，估计是vi-passwd的缩写之类的 这个问题似乎经常在更新完系统版本之后发生，但是很隐蔽，感觉不出来是一个权限方面导致的问题。 Knighthana @ XDU 2021/07/01","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"FreeBSD","slug":"FreeBSD","permalink":"https://knighthana.github.io/tags/FreeBSD/"},{"name":"pkg","slug":"pkg","permalink":"https://knighthana.github.io/tags/pkg/"}]},{"title":"某些应用没有声音的问题","slug":"某些应用没有声音的问题","date":"2021-03-27T16:00:00.000Z","updated":"2023-04-20T05:02:55.000Z","comments":true,"path":"Dev-Env/某些应用没有声音的问题.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E6%9F%90%E4%BA%9B%E5%BA%94%E7%94%A8%E6%B2%A1%E6%9C%89%E5%A3%B0%E9%9F%B3%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"","text":"某些应用没有声音的问题 事件的起因是在网页上看电影的时候发现耳机没有声音。 动了两下音量按钮，发现耳机里有提示音。 声卡坏了吗？启动插在后面板上的桌面音响，发现电影的声音能够放出来。 因为之前发生过后面板插孔有声音而前面板插孔没有声音的情况，虽然这次好像能听到部分声音，但还是会怀疑是不是声卡设置的原因。 打开声卡驱动检查声卡设置“禁用前面板插孔检测”是不是出了问题，然而声卡驱动的设置和上次设置的一样。 那么发生了什么事情呢？ 为什么部分应用有声音，部分应用没有呢？ 哪些应用能在耳机播放声音，哪些不能呢？ 我打开音乐软件，开始播放我的歌单，发现耳机里面可以播放出声音。 也许是网页端的H5播放器的问题？或者是浏览器出了问题？ 然后在播放另一个网页视频的时候发现耳机里面有声音。 开始幻想是不是系统突然增加了什么前后插孔分离播放的功能。 检查一圈以后（必然）没有发现什么问题。 疑惑，非常疑惑。 一番检查无果以后，我打开了几个常用的媒体软件。 发现背景音一切正常，但是演员张嘴的时候就只有桌面音箱有声音了。 WTF？ 忽然产生了一个猜想。 打开音乐播放器，切换掉歌单，选了个有人演唱的。 果然......只有伴奏，没有人声。 这问题的特征可太明显了，我以前就遇到过，而且我很清楚这是什么原因造成的。 这是左右声道没有正常传输，问题出在音频线或者插头上。 但是这个问题多发于手机，因为手机耳机线的插头多出一个Mic接口，关于这个接口的位置几个标准的定义有差异，只要在手机上使用不同标准的耳机就会遇到。 但是计算机上的音频插头是统一的，除非线或者插头出了问题，否则很少会在计算机上遇到。 于是排查了硬件问题之后，就工作正常了。 一般来说硬件不太容易突然出问题，所以排障的时候不太会怀疑硬件。 但是今天可真是被教训了一番。 以上。 Knighthana 2021年3月28日， 于西电","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Hardware","slug":"Hardware","permalink":"https://knighthana.github.io/tags/Hardware/"},{"name":"Sound","slug":"Sound","permalink":"https://knighthana.github.io/tags/Sound/"}]},{"title":"Git的日志居然不是跟随仓库的","slug":"Git日志时间问题","date":"2021-03-23T16:00:00.000Z","updated":"2023-04-20T08:20:00.000Z","comments":true,"path":"Dev-Env/Git日志时间问题.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/Git%E6%97%A5%E5%BF%97%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98.html","excerpt":"","text":"Git的日志居然不是跟随仓库的...... 本来以为所有提交记录都会永远保存在git里面 结果今天发现不是这样的 凎哦！（吐槽：难道你以为git日志是区块链那种写上去擦不掉的东西吗？ 紧急把HP-Elite翻出来查了一下上面的日志 最早的记录是 commit: 9fce9f53a69768f4bb7fd58ed21cbfedbb9ee3ff Author: Knighthana Knighthana@outlook.com Date: Wed Jan 23 18:55:37 2019 +0800 很可惜Gulog别的记录找不到了 另外既然谈到了时间，我就顺便查了一下 有一个叫做gratra —— \"graphic-transformer\"的项目 这个项目居然在19年才开始做git版本管理......... 翻出来早期版本gratra_project_seal封口版，其中日期最早的文件是test.ppm，2018年3月30日 以及不晚于2018年6月，我完成了生成BMP格式的颜色转换后文件的功能 还有，2018年3月1日 2时25分08秒，/srv文件夹建立了 2018年3月1日，2时35分29秒，/usr/locale文件夹建立了 也就是说我大概是在半夜2点半的时候忙着装系统 Knighthana 2021年3月24日 于西电 另外这个情况很值得标记一下 难道说，假如将来我用git管理大型项目，就会遇到早年谁（谁？）糊了一坨上去，接着遇到仓库发生变动，然后提交记录就会消失不见了的问题 我得注意一下这个情况，以上 Knighthana 2021年3月24日 于西电 也就是说我大概是在半夜2点半的时候忙着装系统 很符合对当时作息时间的想象，不要命中带着趣味 Knighthana 2023/04/20","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://knighthana.github.io/tags/Git/"}]},{"title":"为MSYS2更改默认Shell","slug":"为MSYS2更改默认Shell","date":"2021-03-23T16:00:00.000Z","updated":"2023-04-20T10:28:13.075Z","comments":true,"path":"Dev-Env/为MSYS2更改默认Shell.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E4%B8%BAMSYS2%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4Shell.html","excerpt":"","text":"为MSYS2更改默认Shell 在msys2的目录下有一个msys_shell.cmd文件 打开，第6行就是默认shell设置 非常优雅的方式，这个设置可以同时影响到MSYS2,MINGW32和MINGW64 Knighthana 2021年3月24日 于西电 Change Default Shell Under MSYS2 for some reason, I need to install msys to use mingw; and I'm used to oh-my-zsh over zsh under unix-like system; well MSYS2 use bash as default shell; but appearently I can't change default shell with chsh under MSYS2. check the MSYS folder, and there will be a msys_shell.cmd file in sight. there is a set \"LOGINSHELL=bash\", edit it. Knighthana @ XDU 2021/03/24","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"Windows","slug":"Windows","permalink":"https://knighthana.github.io/tags/Windows/"},{"name":"shell","slug":"shell","permalink":"https://knighthana.github.io/tags/shell/"},{"name":"MSYS2","slug":"MSYS2","permalink":"https://knighthana.github.io/tags/MSYS2/"}]},{"title":"使用printf的%s方式打印int数组遇到的问题","slug":"使用printf的某个方式打印int数组时遇到的问题","date":"2021-02-18T16:00:00.000Z","updated":"2023-04-20T11:39:14.974Z","comments":true,"path":"Dev-Code/使用printf的某个方式打印int数组时遇到的问题.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/%E4%BD%BF%E7%94%A8printf%E7%9A%84%E6%9F%90%E4%B8%AA%E6%96%B9%E5%BC%8F%E6%89%93%E5%8D%B0int%E6%95%B0%E7%BB%84%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"","text":"使用printf的%s方式打印int数组遇到的问题 几乎所有的C语言程序手册中都钦定了char数组作为字符串的存储方式； 然而所谓的字符不过只是一些ASCII码而已，也就是说他们只不过是一些数字， 于是同样可以用int类型存储单个字符，这完全没问题，用%c去打印一个存储了码值的int变量，也可以打印出对应的字符； 字符串呢？也不过只是将字符的数字串成了一串数组，这样打印的时候把一串数字翻译成对应的字符，然后连着打印出来，就达到了看起来像是字符串的效果； 按照这样的说法，那么一个由char数组组成的字符串和一个由int数组组成的“字符串”，在字符串方面应该表现出相同的性状； 于是为了方便后续处理数据，将字符串存进int数组中，看起来应该也没有问题； 其实本来也没有问题，但是有时候就会有问题，比如： 通过printf(\"%s\")的方式打印字符串； 这个问题很难遇上，因为少有用int来存字符串这么鬼畜的想法，即使这么干了，也很少会有人想用%s来把它打印出来，而在这很少遇到的情况中即使遇上了这个问题也很难注意到，因为特征很不明显，而且调一调很有可能被其他更改糊弄过去，最后也不会发现有这样的问题； 很不巧我几次遇到了这个问题，最后总结了一下规律: 现象是用%s来打印以int数组形式存储的字符串的代码，通过gcc编译之后，一般只会打印一个首字母，或者core dumped； 现象确定了，原因呢？ 既然char数组一直都很正常，我做了一个假设，那就是printf宏处理%s的方式是假定它只能是一个char数组， 然后呢？ 如果我遇到将只以char数组形式存储的字符串打印出来的需求该怎么处理呢？ 因为char类型的特性，它的长度是确定的，1个字节，那么不难想到处理方法是每次读一个字节； 作出推测了，实验验证一下 既然是随便找几个字符串出来做实验，不妨用“baka” “hentai” “urusai”这几个字符串来玩，不过只需要两个字符串，所以就用前两个吧； char数组存储baka，int数组存储hentai，用printf(\"%s\", ...)的方式打印； 不出所料打印了baka，和一个h就没了下文； 下来才是重头戏， 先调用sizeof运算符，得到本机为每个int分配的空间大小为4字节长，也就是说一个int的空间能放进4个char h的ascii码是104，不过现在要用的是二进制码，应该是 0110,1000 以此类推得到e、n、t、a、i的二进制码， 然后每四位组合在一起，剩余的用0补齐， 得到了 01101000011001010110111001110100 01100001011010010000000000000000 两个非常长的二进制数字 由于开头均为0，按照补码规则这两个数字都是正数，然后计算一下他们的数值大小，用十进制可以分别表示为 1751477876 1634271232 （当然也可以用十六进制表示而且更方便，不过表示形式不重要，知道他是这么一个大小就可以了） 将这hentai[0]和hentai[1]赋值为这两个数字 其实这一步我是非常忐忑不安的，因为我知道关于机器具体如何处理字节级别的数据还得涉及到大端序和小端序的问题， 不过想这些也没用，先看看能输出什么； 果然输出了个tneh就没有下文了， 不过特征很明显，这是hentai前四个字母hent的倒序输出，而没有下文显然是把后面那个int里面末一个字节的0000,0000作为NULL来处理了，程序认为字符串应该在此处结束 于是根据这个规律调整一下二进制的计算方法 得到新的二进制数字为 01110100011011100110010101101000 00000000000000000110100101100001 这两个数字的大小用十进制可以分别表示为 1953391976 26977 再次赋值 于是打印出的结果为hentai，基本符合实验预测； 同时还知道了这台机器中int的存储方式是倒序的，也就是说一个int之中的4个字节实际上是倒着排列的； 大概就这样吧； 实验代码就丢进实验代码仓库了 终端被ctrl+z的进程怎么回到前台 用nano的时候想要按ctrl+x不小心按到了ctrl+z，于是进程挂在了后台， 用ps可以看到后台挂了一个editor进程 但是打editor是调不出这个在后台的进程的 方法是直接打fg把后台程序调入前台 当有多个后台任务的时候 jobs 得到任务号 fg 任务号 调出后台 bg 任务号 调入后台 Knighthana 2021年2月20日","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"},{"name":"shell","slug":"shell","permalink":"https://knighthana.github.io/tags/shell/"},{"name":"Linux-job","slug":"Linux-job","permalink":"https://knighthana.github.io/tags/Linux-job/"}]},{"title":"利用Linux控制终端代码实现特殊显示","slug":"Linux_Terminal_SGR","date":"2021-02-16T16:00:00.000Z","updated":"2023-11-16T17:00:00.000Z","comments":true,"path":"Dev-Code/Linux_Terminal_SGR.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/Linux_Terminal_SGR.html","excerpt":"","text":"利用Linux控制终端代码实现特殊显示 其实之前就知道类似\"\\033[32m\"这样的字符串可以打印出绿色字体，以便在输出中标记有特殊含义的字符串； 但是对这个原理其实一直不甚明了； 但是通过查阅了一些资料以后，算是对这个东西有一点了解了； 首先\\033这个写法并不是最简洁的写法，最简单好记的写法是\\e，这实际上是ASCII码中ESC字符的转义写法； ASCII码中ESC为27号字符，八进制为33(O)，C语言中用0开头的整数表示八进制数字，因此\\033就是表示这是个ESC字符； 后面的[则是一个固定要求，需要将ESC与[组合起来成为ESC [，表示控制图像释义(Set Graphics Rendition，SGR abbr.)序列， 在ESC[后跟有一个数字，这个数字决定了接下来终端打印出的字符的图像特色； 有关颜色的设置 先说颜色设置是因为颜色是最常用的功能，倒不是别的什么逻辑顺序的原因； 有关前景色的设置 前景色设置表格 数字 前景色 数字 前景色 30 黑色 90 浅灰色（亮黑色） 31 红色 91 粉红色（亮红色） 32 绿色 92 浅绿色（亮绿色） 33 黄色 93 浅黄色（亮黄色） 34 蓝色 94 浅蓝色（亮蓝色） 35 紫色 95 品红色（亮紫色） 36 青色 96 淡青色（亮青色） 37 白色 97 荧白色（亮白色） 大多数网上的资料只提到了30-37这八种前景色设置，其实还有90-97这八种前景色设置，但是9x的前景色相对于3x前景色也仅仅只是选取了更亮的色彩；所以我在表格中用括号标注了9x这些颜色的产生方式； 有关背景色的设置 背景色设置表格 数字 背景色 数字 背景色 40 黑色 100 深灰色 41 红色 101 浅红色 42 绿色 102 浅绿色 43 黄色 103 浅黄色 44 蓝色 104 浅蓝色 45 紫色 105 品红色 46 青色 106 淡青色 47 灰色 107 白色 背景色的规律和前景色的规律也是一模一样的，10x的背景色是4x背景色的浅色版本 控制功能 目前可以完全解释的功能 控制功能表格 数字 功能 数字 功能 0 所有属性设置为默认值 1 设置加粗 21 关闭加粗 2 设置不明显 22 关闭不明显 4 设置下划线 24 关闭下划线 7 设置反色 27 关闭反色 这些是由于现象不明显，所以推测的功能表格 数字 功能 数字 功能 5 设置闪烁 25 关闭闪烁 还没有搞清楚，但存在于手册中的功能 还有一些功能是存在的，但是我无法理解这些功能，这些功能的文字介绍可以通过manpages的console_codes(4) — Linux manual page查找到 这些功能中，我只测试了一部分，其他介绍来自Linux Manual Page中文版本，控制终端代码的调出命令为man -L zh-CN console_codes 有关中文版Linux Manual Page请参阅man pages zh，本文涉及到的部分是man4 console_codes 个人尚未测试的数字表格（引用自man-pages-zh(2021年2月17日版本)） 数字 功能 10 重设选定映像,显示控制标记,反转元素标记. 12 选择空映像,设置显示控制标记,重设反转标记.(在完成映像表转换之前反转标记引起每一字节的高位反转.) 21 设置正常亮度（和ECMA-48不兼容） 22 设置正常亮度 38 打开下划线，设置默认前景色 39 关闭下划线，设置默认前景色 49 设置默认背景色 测试结果 测试结果如图： 测试图片 测试代码我稍后应该会上传到我的github仓库中 未完的想法 另外我似乎发现了一些规律， 前景色是3x和9x，背景色是4x和10x，其中3x到4x距离为10，9x到10x距离也为10，不过这个现象很明显就是了， 主要是很多功能的开关在x和2x成对地出现，同时缺失了3、6处的功能介绍，而且这些数字是如此地分散，像是刻意互相避开了什么容易交叉的部分； 我不禁怀疑这些所谓的控制字其实只是在控制一个类似二进制串的东西，二进制串上的每一位的0或1是某种开关，而这个二进制串一起决定了字符的图像样式； 0的二进制是0，作为默认也没有什么可想的 1的二进制是0000,0001，21的二进制是0001,0101 2的二进制是0000,0010，22的二进制是0001,0110 4的二进制是0000,0100，24的二进制是0001,1000 这显然不像上述猜测中的简单的二进制开关，这中间应该有更加复杂的运算规则，像是与、或、同或、异或之类的运算之后，才写入最终结果 我可能需要一张足够大的输入输出表才能看出其中的规律 同时，manpages中提到了ECMA-48，这似乎是一个标准，也值得去查一下； 按说发现了这个线头，应该继续探究下去的， 但是夜太深了，以后再说吧 Knighthana 2021年2月17日 SGR\\e[38;a;b...m对于终端字符串色彩的控制 上文中提到，30-37是8种前景色，并且提到38的作用不完全符合介绍，用途不明， 事实上并非如此，那些介绍适用于小于 Linux 3.16 版本的内核，并不适于现在广泛应用中的5.x与6.x内核 根据最新 1man console_codes 的描述： Commands 38 and 48 require further arguments: ;5;x 256 color: values 0..15 are IBGR (black, red, green, ... white), 16..231 a 6x6x6 color cube, 232..255 a grayscale ramp ;2;r;g;b 24-bit color, r/g/b components are in the range 0..255 38的含义是“设定前景色”，但它不能单独使用，还需要之后用分号分割的数个数字来辅助确定颜色，同样地，48表示“设定背景色” 可以用5表示使用256色模式，256色调色板对应的数字可以通过\"xterm 256 color code\"一类的关键词搜索到 例如这个参考 256 Colors Cheat Sheet \\e[38;5;208可以得到一个非常不错的橙色 还可以通过使用2来使用R;G;B方式，这可以获得256×256×256的颜色选择空间 Knighthana 2023年11月17日","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"Terminal","slug":"Terminal","permalink":"https://knighthana.github.io/tags/Terminal/"},{"name":"SGR","slug":"SGR","permalink":"https://knighthana.github.io/tags/SGR/"}]},{"title":"html中A标签的target属性设置","slug":"HTML中A标签的target属性设置","date":"2021-02-15T16:00:00.000Z","updated":"2023-04-20T10:26:27.719Z","comments":true,"path":"Dev-Code/HTML中A标签的target属性设置.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/HTML%E4%B8%ADA%E6%A0%87%E7%AD%BE%E7%9A%84target%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE.html","excerpt":"","text":"html中A标签的target属性设置 事件起因和经过——对target属性产生兴趣 html中用&lt;a&gt;标签的target属性的值来指定如何打开一个新链接； 作为一个新手，首先想到的直接搜索，搜索结果中的问答网站的解答都让人云里雾里，于是我想看看如w3school这样的网站，在查阅了国内和国外类似的速成教程网站后，我发现还是不能很好地理解； 于是我查阅了mozilla的MDN Web Docs中有关a元素的部分，zh-CN版本的解释让我这个不从事html相关行业的人有些难以理解，最后在英文版本中我大概理解了这个标准到底是怎么规定的； 结果 于是我自己总结了一下，大概可以这么解释： target属性的几种取值（因framename不属于Html5因此没有记录） 值 行为 _self 在当前的展示框中打开（默认） _blank 在新的页面中（标签页或窗口）打开 _parent 在现有展示框的上一级打开，如果当前展示框没有上一级，那么就表现为_self _top 在最上层展示框中打开，如果没有最上层，那么就表现为_self 关于“展示框” 我用了一个从别的地方借的词“展示框”来指代原文英语的“context”，按照页面的解释，'browsing context (a tab, window, or &lt;iframe&gt;)' 也就是说context是一个可以解释为一个tab标签，一个window窗口，或者一个iframe——一个用来在html页面中展示另一个html页面的“新特性”框架的东西，因此我称之为“展示框”，来表示“在被框起来的范围展示”这样的含义； 其实个人觉得window——窗口这样的词更合适表示这样的含义，无论是压缩算法中的“窗口”，图形学中的“窗口”，都有“透过一个指定的窗从候选内容中选择性取出一部分（用来计算或者展示）”的含义，但是由于“窗口”这个词常常默认指代“在前台展示程序的窗口”或者说“打开的窗口”，而“框架”，“页面”这样的词也有别的常见指代，乱用容易引起歧义，所以不如另借一个词来表示html中的context； 打开新标签页是一个默认的行为吗？ 常见的网站，例如百度搜索、知乎、Bilibili，会在一些常用的链接中直接指定_blank这个值，因此就和谷歌一类不指定_blank的网站表现出不同的行为，会让人觉得点击一个链接弹出新的网页是理所当然的事情，但是其实并不是这样的，恰恰相反，_self才是target的默认值，也就是说直接在当前页面中打开才是一个“默认的”或者说“理所应当”的行为； 一些随想 翻译产生的迷惑 关于html中“上下文”的迷惑 mozilla中文页面中对于target的总览解释是这样的： 该属性指定在何处显示链接的资源。 取值为标签（tab），窗口（window），或框架（iframe）等浏览上下文的名称或其他关键词。以下关键字具有特殊的意义 其中“上下文”是个很让人迷惑的东西，什么叫“上下文”？ 我最近一次接触“上下文”，是在学习编译原理的过程中，了解到“上下文无关语法”，但这对我理解html中的“上下文”毫无帮助； 我为此专门谷歌了一下“上下文 html”，解释得都玄乎其玄，并不能找到一个满意的结果； 因此不是很情愿地打开英文网页，找到了这一段的原文： Where to display the linked URL, as the name for a browsing context (a tab, window, or &lt;iframe&gt;). The following keywords have special meanings for where to load the URL: context，这是一个很容易让我联想到content（内容）的单词，context一般说的是“语境”，怎么得到一个句子所处的语境呢？初中生都知道要了解语境得参阅上下文，因此这里context翻译成“上下文”也有着很显然的类似缘由， 但是呢？这里的context，从它所指代的tab、window、iframe来看，以及后面定语从句用where作先行词来看，更强调“环境”，或者这么说，“目前打开的页面所处的环境”这个表达是不是更贴合一些呢？ 说了这么多不是为了贬低翻译志愿者的工作，也没有指责的意思，我没法理解这个单词也许只是因为我没有网页方面的从业经历，所以无法意会到翻译者要传达的语义或者某些默认的行业规则，在这种情况下，由于“context”这一关键词默认用“上下文”指代了，而没有特别做出解释，因此下来的一段话都没法理解； 关于“祖先”的迷惑 事实上其他几个值我在专门查资料前就大概理解含义了，我是想找到为何有时_parent表现出_top一样的行为，有时_parent和_self的行为一样，所以才会查找专业的资料， MDN Web Docs页面中zh-CN版本中对于top的解释： _top: IHTML4中：加载的响应成完整的，原来的窗口，取消所有其它frame。 HTML5中：加载响应进入顶层浏览上下文（即，浏览上下文，它是当前的一个的祖先，并且没有parent）。如果没有parent框架或者浏览上下文，此选项的行为方式相同_self 我是试图通过概览来了解它的意思的，但是“它是当前的一个祖先，并且没有parent”这样一个句子打断了我的妄想； 原文是这样的： _top: the topmost browsing context (the \"highest\" context that’s an ancestor of the current one). If no ancestors, behaves as _self. 最上面一层，什么叫最上面，就是上面没有比它更高层次的，要是没有这种顶层，就直接用_self的行为，就这么简单； 关于翻译 写随想其实是想写点自己关于翻译的看法，但是写的过程中大概也发现了上面提到的文档可能是机翻的（如果是志愿者翻译的请无视我的错误），因此也没那么冲动了，但最后还是想写点东西的； 可能这篇文章看起来像是在批判翻译文，表达一种“不如不看中文文档直接看原文又不是看不懂”的思想，就像之前的类似事件：某几所高校采用英文教材取代原有的翻译教材，大大提高了教学效率，之前互联网社区也经常有人说，某些理工方面的专业教材看得人一头雾水，找原书拿来看却很容易就看懂了； 我大概就是想说这件事，一开始我的看法也是这样的：既然翻译得烂容易让人迷惑，为什么要看翻译呢？直接看原文不就好了，从小学开始学英语，初中继续学英语，高中也要学英语，大学还要学英语的人拿到原文难道看不懂么？ 但是... ... 但是我后来改变了想法； 现在我是不赞同取消翻译所有人都去看原文的这种行为的，就像这篇文章从头到尾写下来，其实最后我不赞同取消中文文档直接去看英文一样，理由很简单： 既然汉语是一门庞大的语言，那么它必然是有完备性的，不至于一有新技术就没法表示了，因为新技术是从现有技术中产生的，新技术都是基于现实的某种抽象，那么，英语能表示的新技术，汉语怎么会不能表示呢？ 这就像我一直嘲笑的某国语言中用该语言的拼音直接转写新事物英文还随意乱缩写一样，或者嘲笑“梵婀玲”这种比“小提琴”垃圾了不知道多少倍的翻译一样，我嘲笑这种行为，也就像我嘲笑说话时汉语夹几个英文单词这种行为； 在信息领域，“caculator”我们翻译做“计算器”，“computer”翻译做“计算机”，“internet”互联网，“key”密钥，“database”数据库，“software” “hardware”软件硬件，“parent child”亲代、子代； 难道汉语什么时候跟不上时代了？ 现在“高端人才”们要直接在先进领域用英语代替汉语，不能不让人想到以前鼓吹的“汉语拼音化”，“汉字不字母化无法进入信息时代”； 举个最简单的例子，如果当初清朝引进现代化学的几个人直接用了外文的音译来翻译化学元素“方便省事” “反正自己看得懂”，那现在的化学教育还怎么搞？ 是“氢氦锂铍硼”方便，还是“海卓真 海里阿姆 里索斯 百瑞里阿姆 博拉希尔姆”方便？用这样的翻译怎么给最广大群众普及化学常识？ 如果翻译不行，那是翻译自己的问题，而不是不该翻译，要让大家都去学原文，再高端的技术总有普及大众的一天，作为学习理工科的人，更应该善于用本国语言去解释外来事物，降低本国人民学习先进技术的难度，而不是像不懂事的孩子一样搞杀马特 毕竟“时髦”这样“时间身后披着的长发”的翻译比起杀马特不是更加信达雅一些吗？ Knighthana 2021年2月16日","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://knighthana.github.io/tags/HTML/"},{"name":"Web","slug":"Web","permalink":"https://knighthana.github.io/tags/Web/"}]},{"title":"使用git以ssh方式向GitHub Push本地库时需要输入账号密码的情况","slug":"Git推送时提示需要密码","date":"2021-01-30T16:00:00.000Z","updated":"2023-04-19T16:00:00.000Z","comments":true,"path":"Dev-Env/Git推送时提示需要密码.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/Git%E6%8E%A8%E9%80%81%E6%97%B6%E6%8F%90%E7%A4%BA%E9%9C%80%E8%A6%81%E5%AF%86%E7%A0%81.html","excerpt":"","text":"使用git以ssh方式向GitHub Push本地库时需要输入账号密码的情况 之前在Github的html页面新建了一个库，之后通过git clone https的方式将代码clone到本地继续工作，但是之后再次push的时候就遇到了需要输入用户名和密码的问题。 按说我早已经配置过了GitHub的ssh-key，而且本地保存的是对应的私钥，执行 1ssh git@github.com 可以收到 welcome but we dont support shell access 的提示，说明我登陆成功了 那么为什么只有这个库是需要输入账户名和密码才可以push的呢？ 在网上查询了一番，找到了原因，还是clone方式和预期的方式不符的原因。 在本地库中输入 1git remote -v 查询远程库，可以看到远程库是 https://github.com/* 说明使用的是https协议 因此需要更换本地库中的远端设置 12345git remote rm origingit remote add origin git@github.com:username/repo.gitgit push --set-upstream origin main 所以说 clone 的时候这个 \"git@\" 开头非常重要啊，不然协议就选错了 参考文章：Github：每次git push推送的时候都需要输入git的用户名和密码 参考文章：错误地使用了git的克隆方法导致的推送出错 另外，之前打成了 push origin master 疯狂提示没有这个分支，仔细一看，原来是master分支现在叫main分支，第一次感觉到这个鬼变化，呵呵 Knighthana 2021年1月31日 已将原来的“使用终端版本的git向GitHub Push本地库时需要输入账号密码的情况”标题改为“使用git以ssh方式向GitHub Push本地库时需要输入账号密码的情况” Knighthana 2023/04/20","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://knighthana.github.io/tags/Git/"}]},{"title":"移除右键菜单中的某些Wine条目","slug":"移除右键菜单中的某些Wine条目","date":"2019-11-09T16:00:00.000Z","updated":"2023-04-20T10:28:45.459Z","comments":true,"path":"Dev-Env/移除右键菜单中的某些Wine条目.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E7%A7%BB%E9%99%A4%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E4%B8%AD%E7%9A%84%E6%9F%90%E4%BA%9BWine%E6%9D%A1%E7%9B%AE.html","excerpt":"","text":"Remove Icons of Wine APP Wine is a powerful program, but not all the time. I had installed Tencent QQ in wine before, but it never works. So I uninstalled it, but the process didn't work well, wine added the QQ icon in my appfinder, but forgot to remove it. I must do this myself. It's apparently not enough to only delete the program files folder, but it don't work even I find all the QQ key in wine register. Some people says that we shall remove ~/.local/share/applications/wine-* It may works in other circumstances, but not this one. The last step before the problem solving is deleting items under the ~/.config/menus/applications-merged/ folder. Problem solved. Knighthana@XDU 2019/11/10","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"Wine","slug":"Wine","permalink":"https://knighthana.github.io/tags/Wine/"}]},{"title":"Windows鼠标右键菜单的注册表设置","slug":"Windows鼠标右键菜单的注册表设置","date":"2019-11-06T16:00:00.000Z","updated":"2023-04-20T04:56:35.000Z","comments":true,"path":"Dev-Env/Windows鼠标右键菜单的注册表设置.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/Windows%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E7%9A%84%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%AE%BE%E7%BD%AE.html","excerpt":"","text":"Windows鼠标右键菜单的注册表设置 一般来说Windows的右键菜单简洁一些比较好，因为这个菜单里面的某些功能还是很常用的，假如被一些不太常用的功能拖慢了响应速度，就非常非常过分地影响使用体验； （这里吐槽一下Windows右键菜单的“新建”菜单栏子项，显示速度异常地慢，也不知道是怎么搞得不对劲； 一般来说Windows的右键菜单可以在注册表\\HKEY_CLASSES_ROOT\\Directory\\Background\\shellex\\这个键值和它周围的键值里面找到配置的方法； 最简单的方式是把键值删掉，但是有些功能呢，又不是很想彻底删掉，这时候就可以考虑Windows扩展的右键菜单功能了； 方案1： 比如说吧，安装了git-scm之后，右键菜单里面就会出现一些奇奇怪怪的内容，如何把他们藏起来呢？ 方法很简单，在键值里加入一个字符串类型的变量，命名为\"Extended\"就好了； 用的时候如何调出来呢？ 在这个菜单本来应该出现的地方 Shift + RightClick 就可以了 方案2： 有些软件比较“热情”，它们的右键菜单用这个方法无法隐藏(其实是和键的属性有关)，比如OneDrive 这个方案有一些不太完美：在该菜单的键值里面的\"（默认）\"字符串变量的值前面加\"- \" 这样的话确实隐藏了...不过一般也调出不来了（总比删了没法恢复要好 参考文章： Windows下的右键菜单管理 Windows系统如何（临时）删除右键菜单里的项目 Knighthana 2019年11月7日 于西电","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://knighthana.github.io/tags/Windows/"},{"name":"Registry","slug":"Registry","permalink":"https://knighthana.github.io/tags/Registry/"}]},{"title":"Windows下编写C语言程序的准备工作","slug":"Windows下编写C语言程序的准备工作","date":"2019-11-05T16:00:00.000Z","updated":"2023-04-20T04:52:35.000Z","comments":true,"path":"Dev-Code/Windows下编写C语言程序的准备工作.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/Windows%E4%B8%8B%E7%BC%96%E5%86%99C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html","excerpt":"","text":"Windows下编写C语言程序的准备工作 在Windows上安装C编译器 下载并安装[Visual Studio Installer][https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=BuildTools&amp;rel=16] 选中这些需要安装的功能: \"MSVC\" \"Windows 10 SDK\" \"C++/CLI Support\" 等它装完（需要很长时间）; 按super键，输入\"developer powershell for vs 2019\"就可以打开自动配置好的编译器终端了. 安装git 以前安装过windows的git-scm，但嫌不够优雅后来就没用过，不如直接VSC+WSL一气呵成； 以前写的英文是这么说的，懒得再写一遍了： Since I have installed WSL, I don't need an extra UNIX-like environment, so I only need the git function; Search and download git-scm for windows; Install only git functions; Copy my existing ssh file to (Windows)~/.ssh/id_rsa and exec ssh-add /c/users/myusername/.ssh/id_rsa; Execssh -T git@github.com to check if ssh functions work well. (optional) Go to regedit.exe and check\"计算机_CLASSES_ROOT\", add a string value \"Extended\" in key \"git-gui\" and \"git-shell\"; 把Visual Studio Code调整成顺眼的状况（可以不用了，因为现在VSC支持登陆MS账号同步设置的功能了）： 安装一些有用的组件： Install Visual Studio Code; Install some useful plug-ins \"Language pack\" by Microsoft \"Remote-WSL\" by Microsoft \"Settings Sync\" by Shan Khan （现在可以不用装了） \"Git History\" by Microsoft 不太喜欢那个紫色的底部，我喜欢淡蓝色的，因此直接在设置的settings.json里面增加如下内容： 12345\"workbench.colorCustomizations\": { \"statusBar.background\" : \"#1874CD\", \"statusBar.noFolderBackground\": \"#071d77\", \"statusBar.debuggingBackground\": \"#8b008b\" }, Coding Gulog will be pushed later Knighthana 2019年11月06日 于西电","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"},{"name":"Windows","slug":"Windows","permalink":"https://knighthana.github.io/tags/Windows/"}]},{"title":"没有glut.h的问题","slug":"缺少glut.h的问题","date":"2019-10-16T16:00:00.000Z","updated":"2023-04-20T11:40:06.470Z","comments":true,"path":"Dev-Code/缺少glut.h的问题.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/%E7%BC%BA%E5%B0%91glut.h%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"","text":"No Glut.h Problem 使用原生态linux+gcc套件的时候会有许多用IDE的时候遇不到的问题，比如需要为gcc手动指定link目标（否则gcc不知道该往哪里链接就会抛锚）； 知道这一点的我小心翼翼地指定了： gcc test.c -lGL -lGLU -lglut 可喜可贺地遇到了报错： glut.h: No such file or directory 于是我改成了 #include &lt;gl/glut.h&gt; 报错稍有变化： gl/glut.h: No such file or directory 于是只好Google\"linux glut.h no such file\" 结果第一条： You must also be aware that C++ and Ubuntu are both case-sensitive. The correct include line in your program is: #include &lt;GL/glut.h&gt;. :blackrockshooterface: 改成 1#include &lt;GL/glut.h&gt; gcc test.c -lGL -lGLU -lglut 编译通过 Knighthana@XDU 2019/10/17","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"},{"name":"WSL","slug":"WSL","permalink":"https://knighthana.github.io/tags/WSL/"},{"name":"libgl","slug":"libgl","permalink":"https://knighthana.github.io/tags/libgl/"},{"name":"glut","slug":"glut","permalink":"https://knighthana.github.io/tags/glut/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://knighthana.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"注册表中的wow6432node","slug":"注册表的wow6432node","date":"2019-07-23T16:00:00.000Z","updated":"2023-04-20T10:29:00.375Z","comments":true,"path":"Dev-Env/注册表的wow6432node.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84wow6432node.html","excerpt":"","text":"registry wow6432node 当按照已有的教程修改注册表却没有起到作用时，确认路径无误的情况下，考虑是否已有教程是为32位系统写的，而现在的64位系统并不认这个注册表。 在64位系统的注册表HKEY_LOCAL_MACHINE6432node，这个位置放着的是为32位系统而写的注册表项目。 所以说，64位Windows对32位Windows的兼容性果真是通过跑32位子系统实现的。64位系统中的32位程序，二者关系并没有我想象的那么亲密呢。 这方法巧妙吗...不过暂时想不到更好的了。 Knighthana@Home 2019/07/24","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://knighthana.github.io/tags/Windows/"},{"name":"Registry","slug":"Registry","permalink":"https://knighthana.github.io/tags/Registry/"}]},{"title":"除数为零的段错误","slug":"除数为零的段错误","date":"2019-06-11T16:00:00.000Z","updated":"2023-04-20T11:41:37.990Z","comments":true,"path":"Dev-Code/除数为零的段错误.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/%E9%99%A4%E6%95%B0%E4%B8%BA%E9%9B%B6%E7%9A%84%E6%AE%B5%E9%94%99%E8%AF%AF.html","excerpt":"","text":"除数为零的段错误(C语言) 在C中使用了一个 i /= p*p 的语句，结果没有检查这时的p是不是0，然后就段错误了； 一直以为“除数不能为零”这种东西会有提示报错就一直没放在心上，而且一直也没怎么用过除法，但是现在就碰到了，而且没有任何提示，直接段错误，值得注意； 以后遇到段错误问题也可以考虑是不是除法的时候哪里有个除数是0。 Knighthana 2019年6月12日 于西电","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"}]},{"title":"如何修改git的默认编辑器","slug":"如何修改git的默认编辑器","date":"2019-06-10T16:00:00.000Z","updated":"2023-04-20T08:41:09.146Z","comments":true,"path":"Dev-Env/如何修改git的默认编辑器.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9git%E7%9A%84%E9%BB%98%E8%AE%A4%E7%BC%96%E8%BE%91%E5%99%A8.html","excerpt":"","text":"如何修改git的默认编辑器 提交了一段简单修改，但是commit环节出了问题，nano编辑中文的时候处理不了问题，比如吞字符，导致我的一个中文引号编辑总是出问题。 （真垃圾真垃圾 于是需要改默认编辑器 方法1：修改全局配置 git config -global core.editor vim 方法2：仅修改当前配置 打开git配置文件 1vim %gitfolder%/.git/config 然后修改 12[core]editor = vim Knighthana 2019年06月11日 于 西电","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://knighthana.github.io/tags/Git/"}]},{"title":"short和unsigned_short类型的补码","slug":"short和unsigned_short类型的补码","date":"2019-06-09T16:00:00.000Z","updated":"2023-04-20T11:35:04.766Z","comments":true,"path":"Dev-Code/short和unsigned_short类型的补码.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/short%E5%92%8Cunsigned_short%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A5%E7%A0%81.html","excerpt":"","text":"C语言中的short和unsigned short类型——补码 今天上课时复习到了补码，老师提问了一个问题：已知现在大多数计算机中short类型为16位，以补码方式存储，那么将一个short类型变量赋值为-32768，再将这个变量的值赋值给一个unsigned short类型变量，那么这个unsigned short类型变量的值应是多少？ 这个问题我从来没想过，那就试试吧： Ubuntu 18.04.2 on Windows 10 x86_64, gcc 7.4.0 12345678910#include &lt;stdio.h&gt;int main(int argc, int **argv){ short i; unsigned short j; i=-32768; j=i; printf(\"i=%hu, j=%hi\", i, j); return 0；} 输出: i=-32768, j=32768 补码的特征是没有负零，补码的“负零”这个值实际上是一个负数，而且这个负数无法用补码的正数方式表达出来，结果显然说明了当前环境下编译的C语言程序中，short类型占用了16bit（2字节），以补码方式存储。 i的存储方式应当是 1000 0000 0000 0000(B)，j的存储方式应当同样是 1000 0000 0000 0000(B) 按照unsigned short方式表示，是“1乘以2的15次方算术加15个0”，为32768(D)； 按照short方式表示，应该是 1 | 000 0000 0000 0000，为“负的——”等等，对这个二进制数进行逐位取反末尾加一又变回1|000 0000 0000 0000了，这不是个补码正数，没错，这个负数的相反数就是那个补码无法表达的正数（之一），因为16位补码的表示范围是-32768(D) ~ +32767(D)，没有+32768这个数字。 写代码中间忘了怎么输出short类型了，去查了一下K&amp;R C发现里面没有short类型也没有long类型，想起这书是C89前的标准了... ...只好去查了一下，发现short类型是把h写在原int类型表示符的前面，就是说，%hi，%hu。 Knighthana@XDU 2019/06/10","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"},{"name":"补码","slug":"补码","permalink":"https://knighthana.github.io/tags/%E8%A1%A5%E7%A0%81/"}]},{"title":"strcmp()函数无法接受空值","slug":"strcmp()函数无法接受空值","date":"2019-06-07T16:00:00.000Z","updated":"2023-04-20T11:31:35.119Z","comments":true,"path":"Dev-Code/strcmp()函数无法接受空值.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/strcmp()%E5%87%BD%E6%95%B0%E6%97%A0%E6%B3%95%E6%8E%A5%E5%8F%97%E7%A9%BA%E5%80%BC.html","excerpt":"","text":"strcmp()函数无法接受空值 如果在strcmp函数中将一个什么串和“空”对比，就会出现段错误； 这个问题值得留意； 很多大公司会在使用串函数之前套用一个检查函数； 但是默认情况下C语言的编辑器和编译器都不会帮代码撰写者检查使用的串操作函数， 在需要的情况下，我也许需要自己写一些检查函数。 knighthana 2019年6月8日 于 西电 function strcmp cannot accept NULL In project fakeshell, I found that if strcmp(NULL, [something]), there will be a segmentation fault. It's a problem should be noticed. There is a saying that many big companies will make a checkfunction before using str* functions. But C make no-check just for efficiency, I think I can make a check if necessary, but not every time. Knighthana@XDU 2019/06/08","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"}]},{"title":"如何忽略创建.gitignore文件之前那些在代码库中需要忽略的文件","slug":"Git如何忽略创建.gitignore文件之前那些在代码库中需要忽略的文件","date":"2019-06-06T16:00:00.000Z","updated":"2023-04-20T08:45:11.153Z","comments":true,"path":"Dev-Env/Git如何忽略创建.gitignore文件之前那些在代码库中需要忽略的文件.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/Git%E5%A6%82%E4%BD%95%E5%BF%BD%E7%95%A5%E5%88%9B%E5%BB%BA.gitignore%E6%96%87%E4%BB%B6%E4%B9%8B%E5%89%8D%E9%82%A3%E4%BA%9B%E5%9C%A8%E4%BB%A3%E7%A0%81%E5%BA%93%E4%B8%AD%E9%9C%80%E8%A6%81%E5%BF%BD%E7%95%A5%E7%9A%84%E6%96%87%E4%BB%B6.html","excerpt":"","text":"如何忽略创建.gitignore文件之前那些在代码库中需要忽略的文件 如果在代码库中有创建.gitignore之前就有的需要忽略的文件，简单的删除是不能阻止这些文件加入推送的； 需要使用以下代码先删掉本地的缓存，然后重新commit，这样就能使gitignore文件对所有文件生效了； .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。 解决方法就是先把本地缓存删除（改变成未track状态），然后再提交: git rm -r --cached . git add . git commit -m 'update .gitignore' Knighthana 2019年6月7日 于西电 Git Newly Ignore I want to ignore the .ignore file from my repo, so what should I do? Firstly I only changed the .gitignore file, but git status said that their is new modified not tracked. So I search the Web, Find a Blog [Git 忽略提交 .gitignore][https://www.cnblogs.com/youyoui/p/8337147.html] .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。 解决方法就是先把本地缓存删除（改变成未track状态），然后再提交: git rm -r --cached . git add . git commit -m 'update .gitignore' 原文出处：Git 忽略提交 .gitignore However I now realized a question, if I ignored the .gitignore file, there will be a lot of junk files in the directory. So the .gitignore file should be tracked. Knighthana@Home 2019/06/07","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://knighthana.github.io/tags/Git/"}]},{"title":"关掉WSL里面的铃声","slug":"关掉WSL里面的铃声","date":"2019-06-06T16:00:00.000Z","updated":"2023-04-20T11:41:20.426Z","comments":true,"path":"Dev-Env/关掉WSL里面的铃声.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/%E5%85%B3%E6%8E%89WSL%E9%87%8C%E9%9D%A2%E7%9A%84%E9%93%83%E5%A3%B0.html","excerpt":"","text":"关掉WSL里面的铃声 看起来各Linux发行版默认是关掉shell的bell的，但是这其中不包括WSL。 于是换了一个环境的我不得不面对shell又开始（又？）发出恼人的声音的问题（vim：其实我也...）。 没关系，关bell这事不久前才做过，我只需要找一下资料就好。 于是搜了一下，（又）找到了： 关闭vim的BELL声音 「VIM」关闭vim的BELL声音 可以在 vi/vim 中使用 :set noeb 命令（其中 noeb 是 noerrorbells 的缩写），这样当错误发生的时候将不会发出 bi 的一声。 这样也许已经足够了，但是当我们彻夜编程序的时候，尤其是在跟他人同住（比如学生宿舍）的时候这样的闪烁也会影响别人。这时候可以使用 :set vb t_vb= 命令，这下 vi 的出错发声就彻底被禁止了。 根据我试验的结果， 1set vb t_vb= 这一个命令就足够了，上面那个注释掉也没关系。 禁用WSL的shell提示音 禁用WSL的shell提示音 zsh 1.sudo vi ~/.zshrc 2.文件末尾添加unsetopt beep 3.source ~/.zshrc 由于我使用的是zsh，所以只抄了zsh的部分，bash的是 1set bell-style none 至此问题解决，提示音ZNMDJ（ Knighthana 2019年06月07日 不在西电","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"WSL","slug":"WSL","permalink":"https://knighthana.github.io/tags/WSL/"},{"name":"shell","slug":"shell","permalink":"https://knighthana.github.io/tags/shell/"},{"name":"vim","slug":"vim","permalink":"https://knighthana.github.io/tags/vim/"}]},{"title":"Take Space Key In Scanf","slug":"Take_Space_Key_Way_In_Scanf","date":"2019-06-05T16:00:00.000Z","updated":"2023-04-20T11:34:56.299Z","comments":true,"path":"Dev-Code/Take_Space_Key_Way_In_Scanf.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/Take_Space_Key_Way_In_Scanf.html","excerpt":"","text":"Take Space Key In Scanf How to colorful a C text in linux shell? 1printf(\"\\033[0;32;40m%s\\033[0m$\",pwd(user)); used in my code. 1\\033[0;32;40m means ordinary text, green text, black background. 1\\033[0m means change back to default settings. How to take a space key while using scanf? 1scanf(\"%[^\\n]\",buf); means that get input until a '', and save it into buf. 1scanf(\"%[^\\n]%*c\",buf); means that get input until a '', and save it into buf, then drop next character('').(I will use in my function). 1scanf(\"%*[^\\n]%*c\"); means thet get input until a '', and drop it, then get a character(''), drop it too. 1scanf(\"%*[^a]%*c%c\",&amp;ch); means that get input until a 'a', and drop it, then get a character( 'a'), drop it too. After that, get a character and save it into ch. input: bcdeaf output: f Refer: scanf读取含空格的字符串 Knighthana@XDU 2019/6/6","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"}]},{"title":"undefined reference to sem and stdout","slug":"未定义的引用：sem函数","date":"2019-06-04T16:00:00.000Z","updated":"2023-04-20T10:28:22.479Z","comments":true,"path":"Dev-Code/未定义的引用：sem函数.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%9Asem%E5%87%BD%E6%95%B0.html","excerpt":"","text":"一个系统信号量相关函数的问题，一个stdout相关的问题 未定义的引用：sem函数(Undefined Reference to Sem_*) GCC没有默认地支持C的API中的信号函数例如sem_init sem_post sem_wait （这很常见，GCC总是不会默认帮你加载所需的链接库） 直接gcc带有这些函数的代码，想都不用想，肯定会报 undefined reference to sem 的错误 解决这个问题需要给gcc带一个-pthread参数 标准输出stdout缓冲区flush的问题 在我设置的打印提示信息（fprintf(stderr, \"info\")）出现之前程序就段错误了，之前以为是打印的句子之前出现了错误，但是后来得证问题出在提示信息之后的语句中； 那为什么以前不出提示信息呢？ 这个问题是打印错误信息的语句没有考虑到C缓冲区的问题，事实上C输出缓冲区只会在里面有\\n，EOF，fflush(stdout)，还有程序执行完毕的时候才会把缓冲区里面的内容打印出来，所以如果提示信息里面没有\\n或者什么能清空缓冲区的东西，那么提示信息就会一直屯着，直到程序觉得可以输出了，那么如果在这之间程序出了问题，提示信息就永远不会打印出来，进而也会导致对出错位置判断失误 Knighthana 2019年06月05日 于西电","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"signal","slug":"signal","permalink":"https://knighthana.github.io/tags/signal/"},{"name":"stdout","slug":"stdout","permalink":"https://knighthana.github.io/tags/stdout/"},{"name":"gcc","slug":"gcc","permalink":"https://knighthana.github.io/tags/gcc/"}]},{"title":"博客维护更新记录","slug":"博客维护更新记录","date":"2019-05-25T16:00:00.000Z","updated":"2023-04-20T09:00:00.000Z","comments":true,"path":"Blog-Maintenance/博客维护更新记录.html","link":"","permalink":"https://knighthana.github.io/Blog-Maintenance/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95.html","excerpt":"","text":"博客维护更新记录 Give up Jekyll 早于2019年5月19日的某个时间，我放弃了使用Jekyll作为博客框架的行动。 之后转为手动维护。 详见放弃jekyll，重建咕客记录 Try Text2html For The First Day Today I start a new repo named text2html. Using C programing Language to edit text file is a challangable work, because I'm not used to progress string in the past. The string.h file is a cherish. strcpy strcpy function is the function that copy a string to another. e.g. strcpy(str1, str2) means copy str2 to str1 from the first letter, both of them. I got to know about that function very long ago, but what a shame that I forgot it. I almost start to use a loop and a if to write a function like this. strcat and strncat These functions are the functions which can add the string to another, automaticly deal with the '\\0' problem. e.g. strcat(str1, str2) means add str2 to str1 on the tail, and change the '\\0' tag. struct using Struct is a great invention. But I didn't use it until now. Struct helps me to divide the inner struct of the data, and focus on what the data means. I don't need to find out where is the start symbol, where is the end symbol, where to replace the text by using the struct. Just malloc a place for the struct, and let the annoying things get away. error: expected ':', ',', ';', '}' or '__attribute__' before '=' token Struct can't be assignment when initing. New conception Make all data on one structure. Use less pointer. Knighthana @ XDU 2019/05/26 Try Text2html: 一些进展 四年过去了，我逐渐了解到之前的想法，“用C写一个text2html”是个什么工程。 19年的时候，我把这个问题想简单了，随着这几年我学习的内容不断地增加，我了解到，如果想把一种语言的代码转换成另一种语言的代码，需要写一个编译器出来，这种事情听着就头大。 一边学习CPTT这个抽象的东西，我一边在想，用C去完成这种工作，是否有些不太容易？（还有：这样造轮子是不是在浪费时间） 今天得知了一个好消息——在一次github上的搜索中，我发现ruby gems中有一个项目叫作markdown2html，它基本能满足我对将markdown文本转化成为html的需求；生成的文本仅仅是html文本，我可以自行插入头部的标签和尾部标签，需要引用的css也就可以在那边声明 但是获得了更多坏消息： 我之前认为最大的阻力在于转换，或者说把markdown编译为html——虽然说确实如此，如果一行行地手敲&lt;p&gt;&lt;/p&gt;过去实在是太累了——然而我因此忽略了另外的一些问题，这些阻力也不小； 第一，转换仅仅只是转换，距离把网站搭建起来还差了很多，我需要自动在网页下方加上返回主页的链接，以及需要做一些可能的手动精修； 第二，我需要自动统计文章的日期，需要读取文章下方的Tag，然后根据这些内容每次更新我的index.html文件；不然博客页面显得太乱了； 第三，这东西还是不支持数学公式，我最近对GitHub自带的markdown渲染器感觉到不太爽的地方就是它的数学公式支持太糟糕了，稍微复杂一点的公式就无法渲染了，而且至今其他项目里还有一个简单的公式不知道为什么始终报错无法渲染； 我需要一个什么玩意？ 最理想的情况当然是写完markdown，敲一个./run，于是文章就自动从raw/*.md变成post/*.html，这包括语法转换什么的，还要自动插入博客的链接，毕竟我懒得在撰写文章的时候还要考虑自动跳转之类的东西，然后自动更新我的index.html，不仅要加入新的链接，还要更新按日期分类博客、按Tag分类博客的静态页面； 但目前是没有这么便捷的工具的。 头痛，虽然发现这个工具能减轻很多工作，但是更新博客还是变成了一种体力活。 所以我还是不会把所有的*.md转换成*.html，因为这实在是太消耗精力了。 Knighthana 2023/04/05 应该是最后一次更新这篇文章了 目前我已经将博客框架迁移到Hexo，它基本满足了我的所有博客方面的需求 此外，所有的博客维护日志都会放在 博客维护专题 里，这样也就可以满足记录更新注释功能的需求了 那就不再需要把大事记到同一个页面里面了 而且迁移博客的时候我发现了pandoc，这是一个非常强大的东西，一个超级的，面向文档类代码语言的编译器 好强啊...... 2023/04/20 返回主页","categories":[{"name":"Blog Maintenance","slug":"Blog-Maintenance","permalink":"https://knighthana.github.io/categories/Blog-Maintenance/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://knighthana.github.io/tags/Git/"},{"name":"WSL","slug":"WSL","permalink":"https://knighthana.github.io/tags/WSL/"},{"name":"Blog","slug":"Blog","permalink":"https://knighthana.github.io/tags/Blog/"}]},{"title":"Windows10中有关输入法图标的问题","slug":"Windows10中有关输入法图标的问题","date":"2019-05-21T16:00:00.000Z","updated":"2023-04-20T05:05:02.000Z","comments":true,"path":"Dev-Env/Windows10中有关输入法图标的问题.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/Windows10%E4%B8%AD%E6%9C%89%E5%85%B3%E8%BE%93%E5%85%A5%E6%B3%95%E5%9B%BE%E6%A0%87%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"","text":"Windows10中有关输入法图标的问题 Win10输入法跑到任务栏里面去了，本来它应该在通知区域里面的 Win10的设置很迷惑，又是控制面板又是设置，用户究竟应该在哪更改设置？ 解决方案也充满了巫术气息： 打开设置，选择“语言”； 拼写、键入和键盘设置； 输入设置； 高级键盘选项； 勾选“使用桌面语言图标（如果可用）”，如果选中了就去掉，如果没选中就选上再去掉； 大概Win10让我觉得好的地方只有一个Super键搜索功能很好用； Knighthana 2019年5月22日 于西电 Today the typewriting program came to taskbar and do not stay at the notify area. Searched on web, only to find a way about control panel, but the option has not exist anymore. (To M$ : What the F difference between control panel and settings? Finally, the step is: Settings ; Language ; Spelling, typing and keyboard settings ; Input ; Advanced Settings ; Use desktop Language bar (if available) : Tick it or not, then tick it again ; Emmmmmm, the Windows 10 settings are too complex and confusing(but the search fountion is so good). Knighthana @ XDU 2019/05/22","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"CJK","slug":"CJK","permalink":"https://knighthana.github.io/tags/CJK/"},{"name":"Windows","slug":"Windows","permalink":"https://knighthana.github.io/tags/Windows/"},{"name":"Input-Method","slug":"Input-Method","permalink":"https://knighthana.github.io/tags/Input-Method/"}]},{"title":"git克隆方法错误导致的推送出错","slug":"Git克隆方法错误导致的推送出错","date":"2019-05-19T16:00:00.000Z","updated":"2023-04-20T09:05:16.626Z","comments":true,"path":"Dev-Env/Git克隆方法错误导致的推送出错.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/Git%E5%85%8B%E9%9A%86%E6%96%B9%E6%B3%95%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E7%9A%84%E6%8E%A8%E9%80%81%E5%87%BA%E9%94%99.html","excerpt":"","text":"错误地使用了git的克隆方法导致的推送出错 在简单地用代码git clone git://********.git将远端库的代码克隆到本地之后，我遇到了无法push的问题； 在查阅了网上的文章之后，我发现这是克隆方式错误导致的， 如果想要克隆一个自己的项目，就应该使用git clone git@git://*******.git这样的代码，这样才能保证正常使用终端推送代码； 以及ssh的默认安全设置要求id_rsa文件必须是仅用户本人可读写，即600权限，如果后两位不为0，那么就不能正常使用ssh的功能 最后，测试公钥私钥是否配置正常需要的代码是ssh git@github.com而不是ssh username@github.com knighthana 2019年5月20日 于西电 Git Cannot Push Caused By Wrong Cloning Method Today I cloned my repo. from github.com, and simply used git clone git://username/reponame.git ( BTW: \"git://\" means \"http://\" ) . When I ended my job and tried to push my works to github it said that I can't push. Warning text : fatal:remote error: You can't push to git://github.com/username/reponame.git Use https://github.com/username/reponame.git I don't know what happened at first. My direct sense told me that it maybe related to the remote repo settings. I search it on the Internet, find that article 解决fatal:remote error:You can't push to git://github.com/username/*.git问题的办法. It's apparently that I used a wrong method to clone for I have future push plan. So, if I want to clone my own repo from online git repo, I'd better use git clone git@github.com:username/userrepository.git but not git clone git:// How to fix that? 12git remote rm origingit remote add origin git@github.com:username/reponame.git So it has been solved. My work can be continued in new environment. By the way, there was still some waves before I finally succeed in pushing my local repo to remote repo. When I tried to use ssh -t git@github.com, there was a warning information said : @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: UNPROTECTED PRIVATE KEY FILE! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Permissions 0644 for '/home/username/.ssh/id\\_rsa' are too open. I delightly found that there is such a restriction about id_rsa file which I never noticed. I copied my id_rsa and id_rsa.pub from another computer with a U size Flash Disk whose fileformat is FAT32 ( maybe NTFS but not *nix FS for sure ), and the file was copied through my Windows 10 OS's desktop. The rsa file was copied in my WSL environment at last, but the operation permission set was 777. I thought that the files' operation permission should defaultly be 644 ( refer to another Gulog \"WSL operation permission\" ). Until now, the system gave me a lesson that if an id_rsa file was set any read or write permission for other users, it won't be trusted. I changed it's operation permission to 600, and the problem was solved. And ... don't try to ssh username@github.com. I must be drunk, or I wouldn't have typed that command. Knighthana @ XDU 2019/05/20","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://knighthana.github.io/tags/Git/"}]},{"title":"xfwm的标题栏自助设置","slug":"xfwm的标题栏自助设置","date":"2019-05-19T16:00:00.000Z","updated":"2023-04-20T10:31:15.798Z","comments":true,"path":"Dev-Env/xfwm的标题栏自助设置.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/xfwm%E7%9A%84%E6%A0%87%E9%A2%98%E6%A0%8F%E8%87%AA%E5%8A%A9%E8%AE%BE%E7%BD%AE.html","excerpt":"","text":"XFWM Theme Title Bar Cannot Be Customized Yesterday I said tommorrow ... (Sorry, I am sleepy) Yesterday I tried to solve the problem on my WSL X environment. I have downloaded the OS-X like xfwm theme from Github:B00merang-Project. But the theme has a fixed title bar setting. The title bar looks like CHM|0, but I am used to operate on CMH|*. Finally I found a solution on Xfce Wiki. howto 按钮布局 也可以为特定主题定义固定的按钮布局。但需要提醒应该避免强制特定的按钮布局或者标题对齐及其他降低用户选择的设定（除非主题真的需要那样，比如下面会提到的 b5 主题） config file looks like 123456789# button_layout :# O = Option menu# T = Stick# H = hide# S = shade# M = maximize# C = close# | = titlebutton\\_layout=OTS|HMC 现实的例子是，B5 主题只使用了关闭按钮。也就是 themerc 文件中写的是button_layout=C| Solution: Edit \"~/.themes/themename/xfwm4/themerc\" Comment button_layout=CHM|0 Problem solved. window screenshot fullscreen screenshot Icons from McMojave-circle McMojave-circle GitHub Page Knighthana @ XDU 2019/05/20","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"WSL","slug":"WSL","permalink":"https://knighthana.github.io/tags/WSL/"},{"name":"xfce4","slug":"xfce4","permalink":"https://knighthana.github.io/tags/xfce4/"},{"name":"xfwm","slug":"xfwm","permalink":"https://knighthana.github.io/tags/xfwm/"},{"name":"macOS-sytle","slug":"macOS-sytle","permalink":"https://knighthana.github.io/tags/macOS-sytle/"}]},{"title":"WSL中文件权限的问题","slug":"WSL中文件权限的问题","date":"2019-05-18T16:00:00.000Z","updated":"2023-04-20T05:07:45.000Z","comments":true,"path":"Dev-Env/WSL中文件权限的问题.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/WSL%E4%B8%AD%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"","text":"WSL中文件权限的问题 最近在使用WSL(WSL是WSL，那么一个WSL就是A WSL，AWSL)来做开发。 遇到了一个问题，就是文件权限方面的，WSL的默认文件权限似乎是777，正常的Linux中应当是目录755文件644。 中间用了很多治标不治本的办法。 最后用一行放在\"~/.zshrc\"里的带有判断的用于修改umask的代码解决了。umask就是默认用于设置文件权限的，umask \"n n n\" 的作用类似默认对文件进行 chmod \"7-n 7-n 7-n\" 操作。 遗留了一个问题：为何这些代码放在\"~/.profile\"里的时候没有起作用，目前猜想这应当和WSL的登陆机制有关。 Knighthana 2019年5月19日 于西电 2021年2月16日增补： Windows Subsystem Linux如何在NTFS格式磁盘上实现Linux独有磁盘格式如ext4的权限功能？简单来说是元数据 详细情况参阅WSL 的文件权限 Recently I use WSL ( Windows Subsystem for Linux ) for my Linux development. The problem cames firstly when I use \"mkdir\" command to creat a folder, its permission mode is 777. I don't know what happened, the only thing I know is that it's a WSL bug. At first I make an alias in my .bashrc file like alias mkdir=\"mkdir -m 766\", but it hits the ground target not the root. I configed my WSL, such as changing sourcem, changing to zsh ( installing Oh-My-Zsh for sure ), opening X11. And the hatch blowed away. I searched for that problem, and finded that WSL makes a fault config about \"umask\". I typed umask, to find that the umask set was 000 ( ordinarily it should be 022 ). I input umask 022 in \"~/.profile\" , but it don't help. At last I type this in \"~/.zshrc\" : 1234#Fix BUG 2019/5/19 17:23if [[ \"$(umask)\" == '000' ]]; then umask 022fi Finally the problem seems solved. But there is still a question remains : Why it don't work in \"~/.profile\". Knighthana @ XDU 2019/5/19","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"WSL","slug":"WSL","permalink":"https://knighthana.github.io/tags/WSL/"},{"name":"Windows","slug":"Windows","permalink":"https://knighthana.github.io/tags/Windows/"}]},{"title":"shell输出重定向","slug":"shell输出重定向","date":"2019-05-18T16:00:00.000Z","updated":"2021-03-23T16:00:00.000Z","comments":true,"path":"Dev-Env/shell输出重定向.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/shell%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91.html","excerpt":"","text":"Shell Buffer Redirection Under WSL, if I want to run xfce4, the terminal will give a lot of information. The information is very useful when developing, or errors accured, but not neccessary when I using it as the other days. I knew that the output can be redirect to files, but I didn't know what should I do if I don't want to keep it, so I went to find ways for redirecting the stdout and stderr to null. Try command &gt; /dev/null to redirect stdout. But it won't help on stderr. Try command &gt; /dev/null 2&gt;&amp;1 to redirect stdout and stderr. It said that \"注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。\" on Runnob. Knighthana @ XDU 2019/05/19 注释 原来我WSL历史命令里面最早的那条 1startxfce4 &gt; /dev/null 2&gt;&amp;1 是从这里来的啊。 今天编译Craft的时候还纳闷了半天当初咋想到的。 Knighthana 2021年3月24日 于西电","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://knighthana.github.io/tags/shell/"}]},{"title":"重建博客的准备","slug":"重建博客的准备","date":"2019-05-18T16:00:00.000Z","updated":"2023-04-20T09:10:00.000Z","comments":true,"path":"Blog-Maintenance/重建博客的准备.html","link":"","permalink":"https://knighthana.github.io/Blog-Maintenance/%E9%87%8D%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%87%86%E5%A4%87.html","excerpt":"","text":"Preparing For My Blog I made a lot of preparation for my Blog today. But it's quite a difficult task ... 放弃用英文写作了，我用中文写吧。 整理了一下 以上是历史版本，实际上，为什么放弃了Jekyll呢？只是使用ruby的gem时，配置有一些问题导致管理权限不清，gem的时候总是失败，然后Jekyll也运行不起来。 于是我想，为何不直接自己做自己的网页呢？我曾经有过在小学的时候用MS Office Word绘制网页的经历，现在绘制一些新的网页放自己的博客，应该也不是什么难事。 于是一场艰难的长征开始了。 那时候的我其实已经把一台完全是 xfce4 + Ubuntu 的机器当作日常使用的机器了，所以第一个问题就是，我没有Front Page之类的专用软件。 那么走老路吧，继续用文字处理程序画网页，我先是使用了LibreOffice绘制我的第一个页面，index.html——丑。 然后我用纯文本编辑器打开了html文档，查看了一下，发现里面全都是我看不懂的标签，而且我当时甚至不知道这些标签的层叠关系，加上Office给头部加了很多可有可无的东西，我彻底懵逼了，我仅仅找到了我 当作标题的那一行东西而已。 那怎么办呢，我只有硬着头皮做下去了。 主页太丑？那就不管了，继续丑着吧。 markdown文本转不成html？那就继续markdown保存下去。 我试着运用BlueFish编辑器，但是提升的便利有限。 咕了很久之后的一天，我去掉了html文档中的很多我一眼看过去就知道明显没用的东西，比如不合现有规范但是又编辑器自动生成的&lt;font&gt;标签，还有像是文件创建编辑日期之类的东西（虽然现在想起来觉得也许有必要留下来），以及搜索如何添加分割线，如何把分割线弄得好看一点，如何设置margin，如何设置缩进，如何使用多个&lt;p&gt;标签分段，而不是在&lt;p&gt;中使用&lt;br&gt;这种不规范的方式来 分段，以及后来的，硬着头皮引用css文件，然后我在style标签中的经验让我在修改css时异常顺手； 然后咕了很久之后的一天，我向朋友吐槽说，虽然markdown在Chrome中可以浏览，但是完全就是乱码，为什么我在md开头的&lt;meta&gt;标签不起作用？ 我的朋友告诉我，&lt;meta&gt;标签需要放在&lt;head&gt;标签里面才能起作用。于是我发现了有&lt;head&gt;标签和&lt;body&gt;两个标签，那么显然功能也不一样。但是已经清楚这个规律了，我于是终于开始动手把原先的md文档转为html文档。 然后在处理&lt;code&gt;的时候我发现了一个不应该有的text-indent，但是怎么修改都有问题。 于是我发现了&lt;div&gt;标签，这个标签配合style真是好用。 问题可能就在于每次手动指定style有些麻烦，另外就是一个一个md文档地改非常麻烦了。 我已经想到了一个绝妙的办法来做，但是地方不太够我写不下了（ 更新：博客目前的维护记录已移植其他页面 这篇文章的时间太早了，查都查不到，我怀疑搞不好是19年之前的东西，因此不对其做更多的修改了 博客目前的维护记录已移植页面博客维护更新记录 注释 本篇日期已不可查证 最早的记录是 commit d41e6050d9528dadfae88f9b3db0df4c899323c8 Author： Knighthana knighthana@outlook.com Date: Sun May 19 23:32:57 2019 +0800 增加了两篇Gulog，把标题的大小改写了一下，另外随便整理了一下 因此早于或等于2019年5月19日 Knighthana 2021年3月24日 于西电 早学会用代码引用标记，少打一堆html实体符号啊！ Knighhtana 2023/04/20/","categories":[{"name":"Blog Maintenance","slug":"Blog-Maintenance","permalink":"https://knighthana.github.io/categories/Blog-Maintenance/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://knighthana.github.io/tags/HTML/"},{"name":"Blog","slug":"Blog","permalink":"https://knighthana.github.io/tags/Blog/"},{"name":"Jekyll","slug":"Jekyll","permalink":"https://knighthana.github.io/tags/Jekyll/"},{"name":"gem","slug":"gem","permalink":"https://knighthana.github.io/tags/gem/"}]},{"title":"Linux下来自中文Windows操作系统的zip文件文件名出现乱码情况的解决方案","slug":"Linux_Zip_GBK","date":"2019-01-17T16:00:00.000Z","updated":"2021-03-23T16:00:00.000Z","comments":true,"path":"Dev-Code/Linux_Zip_GBK.html","link":"","permalink":"https://knighthana.github.io/Dev-Code/Linux_Zip_GBK.html","excerpt":"","text":"Linux下来自中文Windows操作系统的zip文件文件名出现乱码情况的解决方案 如何把在Windows下打包的，文件名被编码为GBK的文件转化为使用Linux下惯用的UTF-8编码的文件名的文件呢？ 目前使用的可行的方法 1uzip -O cp936 * 引用自： Linux 下 zip 文件解压乱码如何解决？ - Latm Ake的回答 - 知乎 由于zip格式中并没有指定编码格式，Windows下生成的zip文件中的编码是GBK/GB2312等，因此，导致这些zip文件在Linux下解压时出现乱码问题，因为Linux下的默认编码是UTF8。 目前网上流传一种unzip -O cp936的方法，但一些unzip是没有-O这个选项的。 我使用的版本 unzip 6.0 debian modified 版本有这个选项 我发现另外两种解决方案可用。 python方案 此方案目前来看非常完美。 12345678910111213141516171819202122#!/usr/bin/env python# -*- coding: utf-8 -*-import osimport sysimport zipfile#print \"Processing File \" + sys.argv[1]file=zipfile.ZipFile(sys.argv[1],\"r\");for name in file.namelist(): utf8name=name.decode('gbk')#print \"Extracting \" + utf8name pathname = os.path.dirname(utf8name) if not os.path.exists(pathname) and pathname!= \"\": os.makedirs(pathname) data = file.read(name) if not os.path.exists(utf8name): fo = open(utf8name, \"w\") fo.write(data) fo.closefile.close() Windows 用户屏蔽两条 print 语句，Linux 用户不用屏蔽7z方案 需要安装p7zip和convmv，在Fedora下的命令是su -c 'yum install p7zip convmv' 在ubuntu下的安装命令是sudo apt-get install p7zip convmv 安装完之后，就可以用7za和convmv两个命令完成解压缩任务。LANG=C 7za x your-zip-file.zip convmv -f GBK -t utf8 --notest -r . 第一条命令用于解压缩，而LANG=C表示以US-ASCII这样的编码输出文件名，如果没有这个语言设置，它同样会输出乱码，只不过是UTF8格式的乱码(convmv会忽略这样的乱码)。第二条命令是将GBK编码的文件名转化为UTF8编码，-r表示递归访问目录，即对当前目录中所有文件进行转换。 编辑于 2014-12-20 下面的几个方法目前（2018-1-12）还没试过，将来有机会可以试试。 不过目前系统中有很多从手机上拷贝过来的音乐文件的文件名和歌曲信息仍然是乱码，而这些文件没法用这个方法，而且conmv的话，由于文件名已经是UTF8的乱码了，所以暂时没有解决方案。如果Python方案可行的话，等我学会Python以后咕且试试。 写于2018/01/12 Knighthana@Hp-Elite in XDU 对于日期“2018/01/12”的疑问： 2018年1月12日是大学一年级期末考试期间， 我不认为我2018年1月的这个时期就开始考虑写咕客了 因为我可以确认，2019年1月18日之前几天的时间内，我才刚刚把咕客的编辑器换成BlueFish 合理怀疑这里本应写为2019年1月， 但是由于git的记录查不到那么早，尤其是似乎git log似乎记录只记录在本机而不是仓库里永久保存 即使是在我写下这篇文章的那台运行着Ubuntu 16.04 LTS的惠普便携式计算机上也只能查到最早2019年5月19日23时32分57秒的记录 所以彻底没法考证了（虽然我基本可以确认这里是写错了 先这样记着吧 Knighthana 2021年3月24日 于西电","categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"编码方式","slug":"编码方式","permalink":"https://knighthana.github.io/tags/%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/"},{"name":"zip","slug":"zip","permalink":"https://knighthana.github.io/tags/zip/"},{"name":"7z","slug":"7z","permalink":"https://knighthana.github.io/tags/7z/"}]},{"title":"Useful tools and arguments","slug":"Tool_Note","date":"2018-04-17T16:00:00.000Z","updated":"2021-03-29T16:00:00.000Z","comments":true,"path":"Dev-Env/Tool_Note.html","link":"","permalink":"https://knighthana.github.io/Dev-Env/Tool_Note.html","excerpt":"","text":"Useful tools and arguments Linux gksudo used as sudo-in-CLI in GUI, to run a application as an administor. 2018-4-18 alien fakeroot alien --target=amd64 package.iX86.rpm alien is a useful tool to transform rpm packages to deb packages, but if used on amd64, iX86 packages cannot be transform under default settings, give an --target=amd64 argument is quite good idea. By the way, in man alien the --target=architecture is described not straight-understand. 2018-4-24 rsync rsync - a fast, versatile, remote (and local) file-copying tool 某些时候用于替代mv和cp非常方便的工具 2021-3-30","categories":[{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"}],"tags":[{"name":"gksudo","slug":"gksudo","permalink":"https://knighthana.github.io/tags/gksudo/"},{"name":"alien","slug":"alien","permalink":"https://knighthana.github.io/tags/alien/"},{"name":"rsync","slug":"rsync","permalink":"https://knighthana.github.io/tags/rsync/"}]},{"title":"博客的第一天","slug":"博客的第一天","date":"2018-03-23T16:00:00.000Z","updated":"2023-04-20T09:25:00.000Z","comments":true,"path":"Blog-Maintenance/博客的第一天.html","link":"","permalink":"https://knighthana.github.io/Blog-Maintenance/%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9.html","excerpt":"","text":"博客的第一天 使用Jekyll搭建的博客开始运作了（虽然不久之后就放弃了Jekyll 新建的博客看起来非常的粗糙（先这样吧 在Ubuntu中使用Windows Ubuntu默认apt源下载的Virtual Box有无法阅读磁盘文件的问题 但是通过从Oracle网站下载并运行deb文件的方式安装的Virtual Box可以正常工作 目前尚不知道原因（目前仍不知道原因 写程序处理物理实验数据（最终咕了 刚刚开始用Qtiplot，用起这个画图软件来感觉很好 但是画的图有问题，是坏值的原因 我需要写一个程序来去掉坏值 凌晨了，就这样吧（原来开始通宵的历史有这么早了 Knighthana 2018年3月24日 星期六 于 西电 大学生活动中心 2018/3/24/Saturday First Day! My Blog With the help of the Jekyll team and lizer's easy-using website, I finally built up my own blog. However, apparently, it's crude, very crude. I can't wait to set down something I met these days. Windows in Ubuntu ----------------- There is an uncertain reason that the Virtual-Box downloaded by apt can't work well on that HP-Elite laptop with Ubuntu. Each time I open the VirtualBox, there'll be an warning that it can't read the virtual disk. I tried to switch the virtual disk mode to static, failed again. At first I thought it was because of the Inter Rapid Storage Technology. But before I reboot the equipment, an idea came up. I went to the Oracle official website and downloaded an deb package. apt remove, dpkg -i ... Finally, a Windows7 was installed. Hard to think about the strange questions. Coding for physic experiment ---------------------------- After drawing the charts with QtiPlot for my physic experiment, Looking at the charts, I know there is something wrong. What's wrong? There're bad values should have been expeled. Drawing is just to be acquaintant with the new toy QtiPlot. I, still, need to code. I wish I know how to do it on Python, but I am not acquatant with Python. Using C may be a good idea. While I was coding, the twenty-forth day of March has gone. Pen should be put down. I need to continue my coding.Though it's very early a morning. Knighthana 2018-3-24 at XDU SAST KPB 更新 姑且吐槽一下，当年看起来是没搞明白怎么用markdown的标题样式 逮着个等号就抄了，后来我变成了井号派，回来看到第一篇还真是诧异啊 另外看浏览器里的排版页面，Hexo居然把这个识别出来了 不过次要标题就别用减号了啊，用了减号就别缩进了啊，这一缩进不就识别不出来了吗 当年好像总以为标题下面的文字得跟随标题缩进，不知道是咋理解的 可能以为这是个树形的文档吧 真是 too young too simple 不过想来，如果按照目前的方式写markdown文件的话，确实没法单独标出一块不属于某个标题的内容 算是个小小的瑕疵？ 另外，倒着改文章格式，从最新一篇一篇篇地改到这里， 这是整个博客最早的一篇文章了吧， five years ago, 这是一切的开始...... 现在终于可以准备让博客以另一个面貌重新上线了！ 还有上面那些括号的吐槽是哪年写的啊，每次做更改倒是记一下日期啊淦！ 查了一下GitHub那边的日期记录，怀疑应该是2021年2月16日或者2021年5月30日，或者2022年6月13日？ Knighthana 2023/04/20","categories":[{"name":"Blog Maintenance","slug":"Blog-Maintenance","permalink":"https://knighthana.github.io/categories/Blog-Maintenance/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://knighthana.github.io/tags/Blog/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://knighthana.github.io/tags/Ubuntu/"},{"name":"Jekyll","slug":"Jekyll","permalink":"https://knighthana.github.io/tags/Jekyll/"}]}],"categories":[{"name":"Dev-Code","slug":"Dev-Code","permalink":"https://knighthana.github.io/categories/Dev-Code/"},{"name":"Dev-Env","slug":"Dev-Env","permalink":"https://knighthana.github.io/categories/Dev-Env/"},{"name":"KnowledgeMark","slug":"KnowledgeMark","permalink":"https://knighthana.github.io/categories/KnowledgeMark/"},{"name":"Book Mark","slug":"Book-Mark","permalink":"https://knighthana.github.io/categories/Book-Mark/"},{"name":"subject-note","slug":"subject-note","permalink":"https://knighthana.github.io/categories/subject-note/"},{"name":"Blog Maintenance","slug":"Blog-Maintenance","permalink":"https://knighthana.github.io/categories/Blog-Maintenance/"},{"name":"Cooking","slug":"Cooking","permalink":"https://knighthana.github.io/categories/Cooking/"}],"tags":[{"name":"C","slug":"C","permalink":"https://knighthana.github.io/tags/C/"},{"name":"草台教程","slug":"草台教程","permalink":"https://knighthana.github.io/tags/%E8%8D%89%E5%8F%B0%E6%95%99%E7%A8%8B/"},{"name":"BoaWebServer","slug":"BoaWebServer","permalink":"https://knighthana.github.io/tags/BoaWebServer/"},{"name":"设计模式","slug":"设计模式","permalink":"https://knighthana.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"LinuxMint","slug":"LinuxMint","permalink":"https://knighthana.github.io/tags/LinuxMint/"},{"name":"2023","slug":"2023","permalink":"https://knighthana.github.io/tags/2023/"},{"name":"Docker","slug":"Docker","permalink":"https://knighthana.github.io/tags/Docker/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://knighthana.github.io/tags/Hadoop/"},{"name":"career","slug":"career","permalink":"https://knighthana.github.io/tags/career/"},{"name":"ls","slug":"ls","permalink":"https://knighthana.github.io/tags/ls/"},{"name":"git","slug":"git","permalink":"https://knighthana.github.io/tags/git/"},{"name":"be aware","slug":"be-aware","permalink":"https://knighthana.github.io/tags/be-aware/"},{"name":"ArchLinux","slug":"ArchLinux","permalink":"https://knighthana.github.io/tags/ArchLinux/"},{"name":"KVM","slug":"KVM","permalink":"https://knighthana.github.io/tags/KVM/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://knighthana.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Math","slug":"Math","permalink":"https://knighthana.github.io/tags/Math/"},{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://knighthana.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"DSP","slug":"DSP","permalink":"https://knighthana.github.io/tags/DSP/"},{"name":"鼠标","slug":"鼠标","permalink":"https://knighthana.github.io/tags/%E9%BC%A0%E6%A0%87/"},{"name":"互相关","slug":"互相关","permalink":"https://knighthana.github.io/tags/%E4%BA%92%E7%9B%B8%E5%85%B3/"},{"name":"光流法","slug":"光流法","permalink":"https://knighthana.github.io/tags/%E5%85%89%E6%B5%81%E6%B3%95/"},{"name":"HTML","slug":"HTML","permalink":"https://knighthana.github.io/tags/HTML/"},{"name":"pandoc","slug":"pandoc","permalink":"https://knighthana.github.io/tags/pandoc/"},{"name":"markdown","slug":"markdown","permalink":"https://knighthana.github.io/tags/markdown/"},{"name":"随机过程","slug":"随机过程","permalink":"https://knighthana.github.io/tags/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/"},{"name":"排队论","slug":"排队论","permalink":"https://knighthana.github.io/tags/%E6%8E%92%E9%98%9F%E8%AE%BA/"},{"name":"生灭过程","slug":"生灭过程","permalink":"https://knighthana.github.io/tags/%E7%94%9F%E7%81%AD%E8%BF%87%E7%A8%8B/"},{"name":"管理","slug":"管理","permalink":"https://knighthana.github.io/tags/%E7%AE%A1%E7%90%86/"},{"name":"日语","slug":"日语","permalink":"https://knighthana.github.io/tags/%E6%97%A5%E8%AF%AD/"},{"name":"vim","slug":"vim","permalink":"https://knighthana.github.io/tags/vim/"},{"name":"Hexo","slug":"Hexo","permalink":"https://knighthana.github.io/tags/Hexo/"},{"name":"Node.js","slug":"Node-js","permalink":"https://knighthana.github.io/tags/Node-js/"},{"name":"nexmoe theme","slug":"nexmoe-theme","permalink":"https://knighthana.github.io/tags/nexmoe-theme/"},{"name":"CUDA","slug":"CUDA","permalink":"https://knighthana.github.io/tags/CUDA/"},{"name":"NVIDIA","slug":"NVIDIA","permalink":"https://knighthana.github.io/tags/NVIDIA/"},{"name":"Linux","slug":"Linux","permalink":"https://knighthana.github.io/tags/Linux/"},{"name":"Chrome","slug":"Chrome","permalink":"https://knighthana.github.io/tags/Chrome/"},{"name":"man","slug":"man","permalink":"https://knighthana.github.io/tags/man/"},{"name":"cURL","slug":"cURL","permalink":"https://knighthana.github.io/tags/cURL/"},{"name":"GPG","slug":"GPG","permalink":"https://knighthana.github.io/tags/GPG/"},{"name":"APT","slug":"APT","permalink":"https://knighthana.github.io/tags/APT/"},{"name":"Slack","slug":"Slack","permalink":"https://knighthana.github.io/tags/Slack/"},{"name":"遗传算法","slug":"遗传算法","permalink":"https://knighthana.github.io/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"},{"name":"计算智能","slug":"计算智能","permalink":"https://knighthana.github.io/tags/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD/"},{"name":"Git","slug":"Git","permalink":"https://knighthana.github.io/tags/Git/"},{"name":"CJK","slug":"CJK","permalink":"https://knighthana.github.io/tags/CJK/"},{"name":"编译原理","slug":"编译原理","permalink":"https://knighthana.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"计算机程序设计","slug":"计算机程序设计","permalink":"https://knighthana.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"lookahead","slug":"lookahead","permalink":"https://knighthana.github.io/tags/lookahead/"},{"name":"top-down","slug":"top-down","permalink":"https://knighthana.github.io/tags/top-down/"},{"name":"predictive parsing","slug":"predictive-parsing","permalink":"https://knighthana.github.io/tags/predictive-parsing/"},{"name":"具象语法树","slug":"具象语法树","permalink":"https://knighthana.github.io/tags/%E5%85%B7%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/"},{"name":"抽象语法树","slug":"抽象语法树","permalink":"https://knighthana.github.io/tags/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/"},{"name":"AST","slug":"AST","permalink":"https://knighthana.github.io/tags/AST/"},{"name":"Torch","slug":"Torch","permalink":"https://knighthana.github.io/tags/Torch/"},{"name":"Lua","slug":"Lua","permalink":"https://knighthana.github.io/tags/Lua/"},{"name":"马尔可夫链","slug":"马尔可夫链","permalink":"https://knighthana.github.io/tags/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/"},{"name":"Newton-Raphson","slug":"Newton-Raphson","permalink":"https://knighthana.github.io/tags/Newton-Raphson/"},{"name":"sqrt()","slug":"sqrt","permalink":"https://knighthana.github.io/tags/sqrt/"},{"name":"Carmack","slug":"Carmack","permalink":"https://knighthana.github.io/tags/Carmack/"},{"name":"书页相关","slug":"书页相关","permalink":"https://knighthana.github.io/tags/%E4%B9%A6%E9%A1%B5%E7%9B%B8%E5%85%B3/"},{"name":"vscode","slug":"vscode","permalink":"https://knighthana.github.io/tags/vscode/"},{"name":"Windows","slug":"Windows","permalink":"https://knighthana.github.io/tags/Windows/"},{"name":"Blog","slug":"Blog","permalink":"https://knighthana.github.io/tags/Blog/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://knighthana.github.io/tags/Ubuntu/"},{"name":"Fedora","slug":"Fedora","permalink":"https://knighthana.github.io/tags/Fedora/"},{"name":"Ruby","slug":"Ruby","permalink":"https://knighthana.github.io/tags/Ruby/"},{"name":"gems","slug":"gems","permalink":"https://knighthana.github.io/tags/gems/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://knighthana.github.io/tags/OpenSSL/"},{"name":"fcitx5","slug":"fcitx5","permalink":"https://knighthana.github.io/tags/fcitx5/"},{"name":"font","slug":"font","permalink":"https://knighthana.github.io/tags/font/"},{"name":"离散时间马尔可夫链","slug":"离散时间马尔可夫链","permalink":"https://knighthana.github.io/tags/%E7%A6%BB%E6%95%A3%E6%97%B6%E9%97%B4%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/"},{"name":"code edit","slug":"code-edit","permalink":"https://knighthana.github.io/tags/code-edit/"},{"name":"Python","slug":"Python","permalink":"https://knighthana.github.io/tags/Python/"},{"name":"Computer System","slug":"Computer-System","permalink":"https://knighthana.github.io/tags/Computer-System/"},{"name":"XML","slug":"XML","permalink":"https://knighthana.github.io/tags/XML/"},{"name":"DOM","slug":"DOM","permalink":"https://knighthana.github.io/tags/DOM/"},{"name":"SAX","slug":"SAX","permalink":"https://knighthana.github.io/tags/SAX/"},{"name":"shell","slug":"shell","permalink":"https://knighthana.github.io/tags/shell/"},{"name":"home path","slug":"home-path","permalink":"https://knighthana.github.io/tags/home-path/"},{"name":"config","slug":"config","permalink":"https://knighthana.github.io/tags/config/"},{"name":"Network","slug":"Network","permalink":"https://knighthana.github.io/tags/Network/"},{"name":"DNS","slug":"DNS","permalink":"https://knighthana.github.io/tags/DNS/"},{"name":"CurryRice","slug":"CurryRice","permalink":"https://knighthana.github.io/tags/CurryRice/"},{"name":"生物学","slug":"生物学","permalink":"https://knighthana.github.io/tags/%E7%94%9F%E7%89%A9%E5%AD%A6/"},{"name":"宝石","slug":"宝石","permalink":"https://knighthana.github.io/tags/%E5%AE%9D%E7%9F%B3/"},{"name":"WSL","slug":"WSL","permalink":"https://knighthana.github.io/tags/WSL/"},{"name":"英语","slug":"英语","permalink":"https://knighthana.github.io/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"VirtualBox","slug":"VirtualBox","permalink":"https://knighthana.github.io/tags/VirtualBox/"},{"name":"Kernel","slug":"Kernel","permalink":"https://knighthana.github.io/tags/Kernel/"},{"name":"Software","slug":"Software","permalink":"https://knighthana.github.io/tags/Software/"},{"name":"syscall","slug":"syscall","permalink":"https://knighthana.github.io/tags/syscall/"},{"name":"KD树","slug":"KD树","permalink":"https://knighthana.github.io/tags/KD%E6%A0%91/"},{"name":"Font","slug":"Font","permalink":"https://knighthana.github.io/tags/Font/"},{"name":"离散对数","slug":"离散对数","permalink":"https://knighthana.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"},{"name":"NP难问题","slug":"NP难问题","permalink":"https://knighthana.github.io/tags/NP%E9%9A%BE%E9%97%AE%E9%A2%98/"},{"name":"计算机科学","slug":"计算机科学","permalink":"https://knighthana.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"RaspberryPi","slug":"RaspberryPi","permalink":"https://knighthana.github.io/tags/RaspberryPi/"},{"name":"SSH","slug":"SSH","permalink":"https://knighthana.github.io/tags/SSH/"},{"name":"Minecraft","slug":"Minecraft","permalink":"https://knighthana.github.io/tags/Minecraft/"},{"name":"Fabric","slug":"Fabric","permalink":"https://knighthana.github.io/tags/Fabric/"},{"name":"Java","slug":"Java","permalink":"https://knighthana.github.io/tags/Java/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://knighthana.github.io/tags/Microsoft/"},{"name":"3E","slug":"3E","permalink":"https://knighthana.github.io/tags/3E/"},{"name":"libc","slug":"libc","permalink":"https://knighthana.github.io/tags/libc/"},{"name":"w3m","slug":"w3m","permalink":"https://knighthana.github.io/tags/w3m/"},{"name":"dpkg","slug":"dpkg","permalink":"https://knighthana.github.io/tags/dpkg/"},{"name":"advantage tools","slug":"advantage-tools","permalink":"https://knighthana.github.io/tags/advantage-tools/"},{"name":"FreeBSD","slug":"FreeBSD","permalink":"https://knighthana.github.io/tags/FreeBSD/"},{"name":"pkg","slug":"pkg","permalink":"https://knighthana.github.io/tags/pkg/"},{"name":"Hardware","slug":"Hardware","permalink":"https://knighthana.github.io/tags/Hardware/"},{"name":"Sound","slug":"Sound","permalink":"https://knighthana.github.io/tags/Sound/"},{"name":"MSYS2","slug":"MSYS2","permalink":"https://knighthana.github.io/tags/MSYS2/"},{"name":"Linux-job","slug":"Linux-job","permalink":"https://knighthana.github.io/tags/Linux-job/"},{"name":"Terminal","slug":"Terminal","permalink":"https://knighthana.github.io/tags/Terminal/"},{"name":"SGR","slug":"SGR","permalink":"https://knighthana.github.io/tags/SGR/"},{"name":"Web","slug":"Web","permalink":"https://knighthana.github.io/tags/Web/"},{"name":"Wine","slug":"Wine","permalink":"https://knighthana.github.io/tags/Wine/"},{"name":"Registry","slug":"Registry","permalink":"https://knighthana.github.io/tags/Registry/"},{"name":"libgl","slug":"libgl","permalink":"https://knighthana.github.io/tags/libgl/"},{"name":"glut","slug":"glut","permalink":"https://knighthana.github.io/tags/glut/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://knighthana.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"补码","slug":"补码","permalink":"https://knighthana.github.io/tags/%E8%A1%A5%E7%A0%81/"},{"name":"signal","slug":"signal","permalink":"https://knighthana.github.io/tags/signal/"},{"name":"stdout","slug":"stdout","permalink":"https://knighthana.github.io/tags/stdout/"},{"name":"gcc","slug":"gcc","permalink":"https://knighthana.github.io/tags/gcc/"},{"name":"Input-Method","slug":"Input-Method","permalink":"https://knighthana.github.io/tags/Input-Method/"},{"name":"xfce4","slug":"xfce4","permalink":"https://knighthana.github.io/tags/xfce4/"},{"name":"xfwm","slug":"xfwm","permalink":"https://knighthana.github.io/tags/xfwm/"},{"name":"macOS-sytle","slug":"macOS-sytle","permalink":"https://knighthana.github.io/tags/macOS-sytle/"},{"name":"Jekyll","slug":"Jekyll","permalink":"https://knighthana.github.io/tags/Jekyll/"},{"name":"gem","slug":"gem","permalink":"https://knighthana.github.io/tags/gem/"},{"name":"编码方式","slug":"编码方式","permalink":"https://knighthana.github.io/tags/%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/"},{"name":"zip","slug":"zip","permalink":"https://knighthana.github.io/tags/zip/"},{"name":"7z","slug":"7z","permalink":"https://knighthana.github.io/tags/7z/"},{"name":"gksudo","slug":"gksudo","permalink":"https://knighthana.github.io/tags/gksudo/"},{"name":"alien","slug":"alien","permalink":"https://knighthana.github.io/tags/alien/"},{"name":"rsync","slug":"rsync","permalink":"https://knighthana.github.io/tags/rsync/"}]}