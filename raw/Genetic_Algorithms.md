# 计算智能课上遗留遗传算法问题的课后思考

计算智能课上讲到遗传算法，在“遗传算法用于求解数值优化问题”部分有点跟不上老师的速度，课间和回来之后翻书重新看这一部分，希望能有所理解。

课上PPT举的例子具体数值和教材上不太一样，但不影响理解。

要用遗传算法解决问题，第一步需要映射，将所求的目标映射到二进制空间；因为遗传过程中需要的交叉变异需要通过位运算进行，二进制数字才能比较好地进行位运算。

例题，无约束单目标优化问题：

$ max f(x_1, x_2) = 21.5 x_1 \cdot sin(4\pi x_1)+x_2 \cdot  sin(20\pi x_2) $

$ s.t. -2.9 \leq x_1 \leq 12.0 $

$ 4.2 \leq x_2 \leq 5.7 $

*s.t. 是指 subject to （such that），“受约束”*

要求精度达到小数点后五位

第一步，将区间按照精度要求进行映射，粗俗一点地解释就是将运算区间映射到题目指定“分辨率”的二进制数字串，为什么是二进制数字串？因为我们需要通过后面对二进制数串（所谓“遗传信息”）进行位操作，体现“遗传”的思想。

这个二进制数串的长度应该充分反映题目中要运算的各个数值，本题中我们需要对两个数值使用遗传算法，因此需要求出这两个数值各自占用的比特长度，然后将它们相加，获得本题需要的比特长度。

$ (b_j - a_j) \times 10^5 $

$ x_1: (12.0-(-2.9)) \times 100000 = 1490000 $

$ x_2: (5.7-4.2) \times 100000 = 150000 $

$b_j$为变量$x_j$的最大值，$a_j$为$x_j$的最小值，用$x_j$的最大值减去$x_j$的最小值，就求出了原始数值浮动的区间，然后再乘以题目要求的精度带来的倍数——$10^5$，于是得到了本题所用的区间长度，此时的区间长度是用十进制数字表示的

第二步，将十进制数字区间映射到二进制数字区间，十进制到二进制肯定不会那么“恰巧”是一个整进制数，于是我们只能求出最近的二进制边界整进制数值，也即

$ 2^{m_j -1} < (b_j - a_j) \times 10^5 \leq 2^{m_j} -1 $

代入本题数值，即求

$ 2^{x_{1a}} < 1490000 \leq 2^{x_{1b}}-1 $ 和 $2^{x_{2a}} < 150000 \leq 2^{x_{2b}}-1$ 中的$x_{1b}$和$x_{2b}$

求得$x_{1b}$为21bit，$x_{2b}$为18bit

需要的总比特位$m=m_1 +m_2$，代入数值，于是得到总比特长度$(21+18)bit=39bit$

接下来是随机生成符合长度要求（也仅仅只是符合长度要求）的二进制数串。数串的内容完全随机。书上的例子是给了十个个体。

如果要对这些二进制数串代表的内容进行评估，就需要一个将其映射回原来十进制数字的“还原算法”，姑且认为是开动了蛋白质工厂照着基因生产蛋白质。

二进制遗传信息到十进制数字表征的算法如下：

$ x_j = a_j + （j位二进制数串对应的十进制数字） \times \frac{b_j -a_j}{2^{m_j} -1} $

例如，假设在计算的某一步我们获得了以下遗传信息，需要将其转化为十进制数字

注意，这个二进制数串只是举例时随机拿出的，并不具有特别的含义，而且我们仅仅将二进制数串看做一个零一序列，在进行转换之前不在意其数字意义

|$x_1$|$x_2$|
|---|---|
|21bit|18bit|
|0000 0101 0100 1010 0100 1|1011 1101 1111 1100 01|
|<-------------39bit---------------->|

接下来开始转换

于是前21bit的$x_1$对应的转换(000001010100101001001)B=(43337)D

后18bit的$x_2$对应的转换(101111011111110001)B=(194545)D

$x_1=-2.9+43337 \times \frac{(12.0-(-2.9))}{2^{21} -1}=-2.59210$

$x_2=4.2+194545 \times \frac{5.7-4.2}{2^{18}-1}=5.31320$

于是我们从没有数学含义的二进制零一数串转化，得到了两个具有数学含义的十进制数字

接下来是评估，评估方法和题目有关，所谓的评估标准，在遗传算法中称为“适应度”，例如本题对应的“适应度”函数eval就是：

