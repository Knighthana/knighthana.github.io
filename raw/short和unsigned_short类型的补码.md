---
title: short和unsigned_short类型的补码
date: 2019-06-10 00:00:00
cover: /img/Cover-CPLang.jpg
categories:
  - Dev-Code
tags:
  - C
  - 补码
---

# C语言中的`short`和`unsigned short`类型——补码

 今天上课时复习到了补码，老师提问了一个问题：已知现在大多数计算机中`short`类型为16位，以补码方式存储，那么将一个`short`类型变量赋值为-32768，再将这个变量的值赋值给一个`unsigned short`类型变量，那么这个`unsigned short`类型变量的值应是多少？
 
 这个问题我从来没想过，那就试试吧：
 
 Ubuntu 18.04.2 on Windows 10 x86\_64, gcc 7.4.0

```C
#include <stdio.h>
int main(int argc, int **argv)
{
	short i;
	unsigned short j;
	i=-32768;
	j=i;
	printf("i=%hu, j=%hi", i, j);
	return 0；
}
```

输出: 

> i=-32768, j=32768

 补码的特征是没有负零，补码的“负零”这个值实际上是一个负数，而且这个负数无法用补码的正数方式表达出来，结果显然说明了当前环境下编译的C语言程序中，short类型占用了16bit（2字节），以补码方式存储。

 i的存储方式应当是 1000 0000 0000 0000(B)，j的存储方式应当同样是 1000 0000 0000 0000(B)

 按照unsigned short方式表示，是“1乘以2的15次方算术加15个0”，为32768(D)；
 
 按照short方式表示，应该是 1 | 000 0000 0000 0000，为“负的——”等等，对这个二进制数进行逐位取反末尾加一又变回1|000 0000 0000 0000了，这不是个补码正数，没错，这个负数的相反数就是那个补码无法表达的正数（之一），因为16位补码的表示范围是-32768(D) ~ +32767(D)，没有+32768这个数字。

 写代码中间忘了怎么输出short类型了，去查了一下K&R C发现里面没有short类型也没有long类型，想起这书是C89前的标准了... ...只好去查了一下，发现short类型是把h写在原int类型表示符的前面，就是说，`%hi`，`%hu`。

 Knighthana@XDU

 2019/06/10
